<!doctype html><html lang=en-US><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Pandaqi Games: The Big Typescript Update | Pandaqi Blog</title>
<link rel=icon type=image/png href=https://pandaqi.com/blog//favicon.png><link rel=stylesheet type=text/css href=/blog/css/critical.min.css></head><body><header id=site-header><nav class=menu><ul><li><a href=https://pandaqi.com/blog/ class="masked-link big-mask mask-2" style=--rotation:1deg>Home</a></li><li><a href=/blog/boardgames/ class="masked-link big-mask mask-3" style=--rotation:-0.5deg>Boardgames</a></li><li><a href=/blog/news-and-updates/ class="masked-link big-mask mask-6" style=--rotation:-0.5deg>News & Updates</a></li><li><a href=/blog/reviews-and-thoughts/ class="masked-link big-mask mask-4" style=--rotation:0deg>Reviews & Thoughts</a></li><li><a href=/blog/tutorials/ class="masked-link big-mask mask-7" style=--rotation:-1deg>Tutorials</a></li><li><a href=/blog/videogames/ class="masked-link big-mask mask-6" style=--rotation:0deg>Videogames</a></li></ul></nav></header><main class="padding center-block"><article class=single-article><h1>Pandaqi Games: The Big Typescript Update</h1><aside class=metadata><nav class=breadcrumbs><span class=metadata-label><span class=emoji>ü•ê</span> Breadcrumbs ||</span>
<a href=https://pandaqi.com/blog/>Home</a>
/
<a href=/blog/>Blog</a>
/
<a href=/blog/news-and-updates/>News and updates</a>
/
<a href=/blog/news-and-updates/pandaqi-games-the-big-typescript-update/>Pandaqi games the big typescript update</a></nav><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/pandaqi.com\/blog\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"\/blog\/","name":"blog"}},{"@type":"ListItem","position":4,"item":{"@id":"\/blog\/news-and-updates\/","name":"news-and-updates"}},{"@type":"ListItem","position":5,"item":{"@id":"\/blog\/news-and-updates\/pandaqi-games-the-big-typescript-update\/","name":"pandaqi-games-the-big-typescript-update"}}]}</script><div><span class=metadata-label><span class=emoji>&#8987;</span> Published ||</span>
<time datetime=2023-10-25T00:00:00>Wednesday, Oct 25, 2023</time></div><div><span class=metadata-label><span class=emoji>üìñ</span> Table of Contents ||</span>
<a href=# id=toc-toggle>Show</a></div></aside><aside id=table-of-contents class=masked-link-block><header><h2>Table of Contents</h2></header><nav id=TableOfContents><ul><li><a href=#typescript>TypeScript</a></li><li><a href=#layout-system>Layout System</a><ul><li><a href=#resources>Resources</a></li><li><a href=#consistency>Consistency</a></li><li><a href=#design-through-webpages>Design through Webpages</a></li></ul></li><li><a href=#smarter-asset-building>Smarter asset building</a><ul><li><a href=#the-rules-issue>The rules issue</a></li><li><a href=#which-is-a-bigger-issue>Which is a bigger issue</a></li><li><a href=#the-solution>The solution</a></li><li><a href=#relieving-some-dead-weight-of-old>Relieving some dead weight of old</a></li></ul></li><li><a href=#faster-generation>Faster generation</a><ul><li><a href=#async-for-the-win>Async for the win</a></li><li><a href=#better-coding-practices>Better coding practices</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></aside><div><p>If you thought we were done with huge updates to <a href=https://pandaqi.com>Pandaqi Games</a> for this year&mdash;as did I&mdash;then you were wrong.</p><p>This past year, the number of interactive/randomly generated board games has skyrocketed. I&rsquo;ve planned 10+ for next year, of which several are already completely finished.</p><p>In other words, Pandaqi needed another big upgrade behind the scenes.</p><ul><li>I ran into serious issues (or possible improvements) making all these projects.</li><li>This isn&rsquo;t just some hobby anymore&mdash;these games take months of my time and are professional quality by now.</li></ul><p>If you haven&rsquo;t visited my website, it might be nice to do so before reading this article. Check out some of the latest board games to better understand what I mean.</p><ul><li>They might allow you to randomly generate a playing board (on the main page)</li><li>Or you can press a button to generate material (a PDF with cards/tiles to print)</li><li>And the digital rulebook might have &ldquo;playful examples&rdquo;: interactive parts that help you understand the rules in a fun and quick way.</li></ul><p>All of that&mdash;before this update&mdash;ran on JavaScript and the Hugo static website generator.</p><p>With that knowledge, let&rsquo;s start the article!</p><h2 id=typescript>TypeScript</h2><p>First of all, everything was converted to TypeScript. In some cases this simply meant changing the extensions (from <code>.js</code> to <code>.ts</code>), in other cases TypeScript immediately pointed at 30 errors or sections of unclear code that I had to fix.</p><p>Which is exactly the reason why I wanted to make the change.</p><p>As I&rsquo;ve programmed more and more, I&rsquo;ve decided that (statically) typed languages are definitely the way to go. Yes, the freedom and speed of &ldquo;do whatever you want&rdquo; might feel great at first, and the verbose syntax of typed languages might seem daunting. But in the end, merely <em>converting</em> my existing projects to TypeScript revealed another large group of (potential) errors.</p><p>By forcing yourself to give everything well-defined types and sticking to those, you force yourself to think more about how to solve a problem <em>better</em>, and you can have way more faith in the correctness of your code.</p><p>That&rsquo;s the second reason: faith in your own systems.</p><p>Over the years, Pandaqi has grown huge, with many moving parts. The oldest games and pages use terrible code and architecture. Once you&rsquo;ve started with that, however, you&rsquo;re somewhat stuck with it. This meant that there were interconnected dependencies and single points of failure <em>all over the place</em>.</p><p>Any time I updated Pandaqi, I was simply afraid that all games had stopped working. Which isn&rsquo;t great.</p><p>So yes, all the game (generation) code + all the tooling behind the scenes was converted to TypeScript. I couldn&rsquo;t really use &ldquo;automatic&rdquo; features (such as inferring types from usage) on half the projects&mdash;the oldest ones&mdash;because of how badly they were coded. Newer projects were a breeze to convert.</p><p>I was afraid this would make the compile/build/reload process much slower (on my already terrible laptop). Instead it got &mldr; faster?</p><h2 id=layout-system>Layout System</h2><p>For my first handful of games, I simply coded what I needed <em>right then and there</em>.</p><p>Need to place some text on a card? Directly interface with the canvas (using <code>context.fillText(...)</code>).</p><p>Need to place an image? Again, directly grab the URL, then place it (using <code>context.drawImage(...)</code>)</p><p>Obviously, after several games I saw the patterns here and pulled these into reusable functions across games. I had never written a layout system or resource manager before, however, so I made some terrible choices.</p><p>For example, the <code>ResourceLoader</code> could asynchronously load and save resources &mldr; but only in their raw state. I had to pass three parameters to <em>every drawing function</em>, no matter how big or small:</p><ul><li>Context to draw to</li><li>Resource loader</li><li>ID of resource to draw</li></ul><p>Similarly, there were three different functions for adding text with only <em>minor</em> differences.</p><p>No more! If we&rsquo;re going to create these amazing games (fully generated by website code), we need a better system.</p><h3 id=resources>Resources</h3><p>As such, I did a rewrite of all the tools that is so large that it&rsquo;s not even a rewrite anymore: I just created a layout system from scratch.</p><ul><li>All resources are now their own class/object. This means I can just do &ldquo;resourceLoader.getResource(id)&rdquo; once, save that inside some variable, and draw that one image as often as I want. It also means much easier manipulation and other benefits discussed below.</li><li>Text is just another resource. So, to draw text, I create a <code>ResourceText</code> and do whatever I want with it. One unified way to display text!</li><li>A <code>Color</code> object with proper converters (to other formats) and tools. (I already had a Color object, but it was so limited that only one game actually used it.)</li><li>I created a whole library of <code>Geometry</code> helpers. (Shapes, pathfinding, testing intersection, etcetera.) Any of these can easily be turned into a resource to draw.</li></ul><p>Every resource has a simple <code>toCanvas</code> function which takes a canvas to draw to and a <code>LayoutOperation</code>. That object contains the actual specifics for <em>how</em> to draw the resource (position, scale, clip it, effects, &mldr;).</p><p>This feels, after years of experience, like the best approach. This separates WHAT you want to display with HOW you want to display it.</p><ul><li>Resources are extremely light and (almost) never copied or duplicated. (They have NO logic that doesn&rsquo;t belong there, such as drawing them on a canvas.)</li><li>LayoutOperation is also very light and focused. (It only has logic for <em>executing</em> a drawing operation.)</li><li>But I can display the same image in different places merely by giving a different <em>operation</em> to the exact same resource. (And this operation can be calculated/generated beforehand easily. Again, separation of steps: data and execution.)</li><li>And this works equally for all resources, which means syntax will always be the same.</li></ul><p>This allowed me to rewrite tens of lines of custom code&mdash;for <em>every image/text/whatever</em>&mdash;to only two very clear and robust lines. (Create a LayoutOperation with specifics, draw the resource using that operation.)</p><h3 id=consistency>Consistency</h3><p>When creating games and layouts, it is <em>very common</em> to work with sets of coordinates&mdash;vectors <code>(x,y)</code> or <code>(x,y,z)</code>.</p><p>Not only for <em>actual coordinates</em> (such as an element&rsquo;s position), but also dimensions, size, offset, etcetera.</p><p>Until a few months ago, I simply created a raw object each time I needed this :p (So just <code>{ x: number, y: number }</code> everywhere.)</p><p>It gets even worse if you go back further. I thought it was faster and easier to write coordinates as an array: <code>[x,y]</code></p><p>Well, now that I have all my tooling and useful functions/classes, this all had to change. While updating all the games to TypeScript, I converted all these coordinates to my <code>Point</code> class. (By far the most used class.)</p><p>I converted colors to a <code>Color</code> class, manually defined shapes to their proper <code>Shape</code> class, etcetera.</p><p>The general goal is simply to not create manual/custom objects <em>ever</em>. It leads to errors, TypeScript doesn&rsquo;t like it (as a variable can have anything inside), and it&rsquo;s hard to change or update later.</p><p>This conversion isn&rsquo;t 100% done. Some very old games would need an entire rewrite to be consistent, and I just don&rsquo;t think it&rsquo;s worth the effort. But most of the codebase has been converted and is now completely consistent.</p><h3 id=design-through-webpages>Design through Webpages</h3><p>Even with this better system, I still wasn&rsquo;t satisfied with placing everything by hand. Many layouts work more like a <em>grid</em> or a set of <em>containers</em>. Like &mldr; a web page!</p><p>I found myself often wishing I could just randomly generate some material for a game like a <em>web page</em>.</p><p>Continuing that thought, I decided to create my own little layout system on top of what I already had.</p><p>How does it work?</p><p>Just like resources have a <code>toCanvas</code>, they also have a <code>toHTML</code>. It converts the resource into an HTML representation, including the correct CSS properties for whatever layout operation I ask it to do.</p><p>Additionally, I created a <code>LayoutNode</code>. This can hold some more common properties (such as CSS flexbox stuff) and can have <em>children</em>.</p><p>Using LayoutNodes (which can optionally hold a resource), I can build a layout like a tree. Maybe I want some icon to be aligned to the <em>right</em> inside a container. Maybe I want some <em>padding</em> around this set of elements. It&rsquo;s easy to do with CSS!</p><p>Once I have that tree, I &mldr;</p><ul><li>Call <code>toHTML</code> to convert the whole tree of layout nodes</li><li>Then feed that into a third-party &ldquo;html to canvas&rdquo; library. (The latest and fastest I could find.)</li><li>Which eventually spits out the whole thing as a canvas. (Which can just go back into the rest of my system for building a PDF and such.)</li></ul><p>At first, I tried to write a &ldquo;renderer&rdquo; myself. My own little render engine that would parse the tree and put it on the canvas. This worked fine for easy things, but something like the CSS flexbox is just a <em>pain</em> to implement. That&rsquo;s why I went with the conversion approach in the end.</p><p>Similarly, the structure used to be way more difficult and less consistent. I basically went through three versions of this Layout + Resource system (in only a few weeks) before finding the simplest and fastest solutions to the problems.</p><p>The most important thing here is that this is just a flexible component. I can create the <em>whole</em> design like this &mldr; or just a part. I can use the Phaser library (which is awesome, by the way) for some things, but then stamp my own Layout on top for something else.</p><p>It&rsquo;s just a set of nodes that can be changed and converted to HTML/Canvas at any time.</p><p>This system will surely be improved, changed, etcetera as time goes on.</p><h2 id=smarter-asset-building>Smarter asset building</h2><p>When I just started using Hugo (and converted this website to it), I preferred keeping everything together. Each game had just <em>one</em> folder with the page, the images, the assets, the JS, everything collected there.</p><p>I found it weird to put the page itself in <code>content</code>, but then all the JS completely elsewhere in <code>assets</code>. If I ever needed to change systems or migrate, I thought it was easier if <em>everything</em> related to one project was in a single place.</p><p>Oh, how wrong I was. (Well, it&rsquo;s still valid criticism, it just doesn&rsquo;t outweigh the disadvantages of keeping everything in the same folder.)</p><p>Over time, I had to do some website/Go trickery to even make this work.</p><h3 id=the-rules-issue>The rules issue</h3><p>For example, the online rules for games are inside their own <code>rules</code> subfolder (within the project). Sensible, right? They often have JS code, however, for the interactive examples. This is <em>also</em> inside that subfolder.</p><p>But Hugo (my static site generator) doesn&rsquo;t really like this, so it took many lines of code and trial and error to find a system in which Hugo consistently found and build this custom JS (if it existed).</p><p>Even worse, it doesn&rsquo;t work on reload. Whenever I made a change, I had to stop/restart the entire server (<code>CTRL+C</code>, type <code>hugo serve</code> again) to see the changes!</p><p>Hugo only automatically reloads/rebuilds what is in <em>assets</em>.</p><p>Similarly, Visual Studio Code doesn&rsquo;t understand this and can&rsquo;t find the tools I import. As such, after switching these rules scripts to TypeScript, it complained about <em>everything</em> and couldn&rsquo;t actually typecheck for me.</p><p>VS Code <em>also</em> wants assets to be together in one place.</p><h3 id=which-is-a-bigger-issue>Which is a bigger issue</h3><p>How did I do that for other scripts? Such as the board or material generators?</p><p>Well, I&rsquo;m ashamed to admit, but &mldr;</p><ul><li>I created a subfolder inside the game project.</li><li>Which was simply a <em>page</em> that I made <em>invisible</em> (through two lines of frontmatter)</li><li>Because it was now a page, Hugo could find the JS file inside.</li><li>Which was just an entry point that pointed to the <em>actual</em> JS in the <code>assets</code> folder</li></ul><p>A loooot of files and folders to do something incredibly simple.</p><h3 id=the-solution>The solution</h3><p>So I moved <em>all</em> code to the <code>assets</code> folder. It has a subfolder <code>games</code> containing any game that needs code. Within such a game, it can have the folders &mldr;</p><ul><li><code>js_board</code> for random board generation</li><li><code>js_game</code> for an actual game or material generation for a game</li><li><code>js_rules</code> for the interactive rules example</li><li><code>js_shared</code> for anything shared across multiple projects. (For example, if I make spin-off games that re-use a lot of the same code.)</li></ul><p>The entry point for <em>all</em> games is always called <code>main.ts</code></p><p>After all this moving around and renaming, building the assets is suddenly very simple. Hugo can easily find the <code>main.ts</code> file, and, if it exists, build it automatically and add it to the game page.</p><p>Because this is all in <code>assets</code> &mldr;</p><ul><li>It works with (hot) reloading</li><li>I can easily find-and-replace across the whole codebase</li><li>VS Code understands the whole codebase and can correctly type check / infer / (auto) import</li><li>I can remove all those nasty subfolders needed for the old structure</li><li>It seems to be waaaay faster now</li><li>The structure and naming is consistent and predictable</li></ul><p>I&rsquo;ll probably do the same with the CSS in the next update. (These files are currently also within the project folder itself, transpiling SASS to CSS, which also works only 10% of the time when hot reloading.)</p><p>I simply ran out of time to do it now, as Pandaqi remains something I do on the side, not profitable as it stands now.</p><h3 id=relieving-some-dead-weight-of-old>Relieving some dead weight of old</h3><p>I made a few games&mdash;most notably the &ldquo;Pirate Games&rdquo; (Pirate Riddlebeard and Pirate Drawingbeard)&mdash;in a weird transitional period. Both for the website and myself.</p><p>As such, those games used one &ldquo;big minified JS library&rdquo; that was stored somewhere on the website. For example, this library contained the Phaser framework, a PDF library, a (Perlin) Noise library, etcetera. All smashed together, minified, then imported to all those games.</p><p>Yeah, not great.</p><p>In fact, I&rsquo;d forgotten exactly what this library contained, which is another reason I didn&rsquo;t touch this hairball of code for a while.</p><p>But with this update, I saw a chance to finally untangle that mess.</p><p>I updated those games to modern coding standards.</p><aside class="example masked-link-block"><span class=label>Example ||</span><p>I&rsquo;d used <code>var</code> everywhere instead of <code>let</code> or <code>const</code>. Which, you guessed it, led to tens of &ldquo;silent errors&rdquo; with variables being inaccessible or in the wrong scope.</p><p>Because OF COURSE I used one incredibly long switch statement to handle the 30+ different types of hints that those Pirate Games could generate. And you know which variables aren&rsquo;t scoped the way you&rsquo;d expect? Yes, those inside blocks of a switch statement.</p></aside><p>In doing so, I rediscovered exactly what this &ldquo;big library&rdquo; contained. Fortunately, the mess wasn&rsquo;t as big as I thought. It relied on things that I had already incorporated in my general tools and used in other systems. (Such as the Phaser framework and a system for exporting things to PDF.)</p><p>As such, I simply imported the needed modules <em>separately</em>, until I could remove that big dependency (without generating more TypeScript errors).</p><p>This might seem a minor thing, but it&rsquo;s a big deal for me. It made the games much easier to maintain going forwards and removed, again, a bunch of unnecessary (large) files and folders from corners of the system. I want to continue those Pirate Games (with better and more beautiful improvements and ideas), but that was a mountain to climb as long as I didn&rsquo;t even know <em>what</em> these games depended on.</p><p>When I tested it, I was honestly surprised that the transition went flawlessly in one try&mdash;all games reliant on that old library still worked 100%. And they were much faster now.</p><p>Speaking of that &mldr;</p><h2 id=faster-generation>Faster generation</h2><p>I didn&rsquo;t plan to work on this at first. I&rsquo;ve always adhered to minimal and efficient code, so there&rsquo;s really no part of the website that is slow by any means.</p><p>But I accidentally improved things, which asked me to further research and implement this.</p><p>What did I do?</p><h3 id=async-for-the-win>Async for the win</h3><p>As I mentioned, older games would just repeat some custom code all the time. One culprit was &ldquo;convert canvas to image&rdquo;: 5-10 lines of code to convert the canvas I generated into an actual image.</p><p>In the new system, everything just imports a function from my tools: <code>convertCanvasToImage</code>.</p><p>Thanks to JavaScript promises and the <code>decode</code> function on images, this piece of code can now easily run <em>asynchronously</em> (for as many canvases as I want). As it&rsquo;s decoding the first images, it can already start on later ones.</p><p>This obviously makes the whole thing <em>much faster</em>. Some games might have 50+ cards. Converting them all in parallel is much faster than converting one at a time (before starting on the next).</p><p>You know what this also means? That the return value from this function <em>might be in the wrong order</em> :p</p><p>Some of the games relied on the images being returned in the same order as they were put in. It took me a while to figure out that <em>this</em> was why those games had broken!</p><p>But it got me thinking. This speedup could be accomplished for many more games by simply switching more parts of the process to be async.</p><p>My example above is merely about the <em>final conversion</em>: I&rsquo;ve already generated the canvases and need to put them into some PDF.</p><p>The <em>actual generation</em> can also often be asynchronous! One playing card does not rely on the others. I can <em>generate</em> those 50 cards in parallel as well.</p><p>Applying this across the codebase resulted in a huge performance boost. My most intensive material generators (the most cards and most visual effects) that took 10 seconds before, now run in less than a second.</p><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>Obviously, it wasn&rsquo;t as easy as just putting <code>async</code> in front of a bunch of functions. Much logic inside those generators relied on things being done in sequence. Now that they weren&rsquo;t, I had to make sure to clone/copy the right objects at the right times. Still, not a terribly difficult conversion for such boosts.</p></aside><h3 id=better-coding-practices>Better coding practices</h3><p>The import and build system for JavaScript is incredibly powerful. I&rsquo;m learning that more and more, as I come from a background of languages that <em>don&rsquo;t</em> have this or do it in a much less <em>useful</em> way.</p><p>As such, my original approach was to create <strong>classes</strong> for everything. I want a general PathFind tool? Well, create a <code>PathFind</code> class that you can import and create, then give it a <code>getPath</code> function!</p><p>In reality, however, such a class is complete overkill. What else is the class going to do? Nothing! All it has to do is find a path based on parameters that you must always input (such as start and end point).</p><p>This is just a <strong>function</strong>.</p><p>All across the codebase, I tried to make the right decisions about what something should be. In the end, this means there are a few major useful classes, but everything else are just exported functions.</p><p>Why does this matter?</p><ul><li>Less verbose. (I don&rsquo;t need to create a new class and <em>then</em> call some function on it.)</li><li>Smaller/faster programs. (If you don&rsquo;t require all members and methods of a class, then including the whole thing is a waste of time and space. As it stands, compilers can&rsquo;t figure out yet whether you actually <em>use</em> everything inside a class. Maybe they never will.)</li><li>Less error-prone. (A function only relies on its input parameters. If there&rsquo;s a bug, I only need to check the body of the function and what my tool gives it, as nothing else matters or might interfere.)</li></ul><h2 id=conclusion>Conclusion</h2><p>Another huge update. Many days spent rewriting, renaming, improving, learning better ways to do something, and making sure old projects hadn&rsquo;t broken.</p><p>In the end, though, it was worth it&mdash;as always.</p><p>The website structure is much cleaner.</p><ul><li>No mess of subfolders or extra files needed to make things work.</li><li>Related things in the same place, exactly where you&rsquo;d expect them.</li><li>Simpler Hugo code to find, combine and build it all.</li></ul><p>While I can actually trust my code, both old and new.</p><ul><li>Everything is fully type-checked</li><li>Everything uses the same set of tools, with minimal side effects (due to exporting pure functions, not classes or whatever)</li><li>Where possible, everything is updated to modern standards and better coding practices.</li></ul><p>Sometimes I wonder what I&rsquo;m doing, when I work on my oldest projects. They are simply much worse (both in front and behind the scenes) than anything I made more recently. Is it even worth it?</p><p>Yes, some of them will probably be completely removed at some point. But it&rsquo;s always a great learning moment to update those old projects, and after such updates, it just became <em>much</em> easier to maintain the project going forward. Something you haven&rsquo;t touched in 10 years will most likely be &ldquo;too broken to work&rdquo;. Something that&rsquo;s relatively up-to-date is much more likely to get the &ldquo;let&rsquo;s improve this old game and make it shine&rdquo;-treatment.</p><p>All of this makes the website much faster to build. I know, one day I&rsquo;ll have the money to buy an actually functioning computer with an SSD drive and I don&rsquo;t have to worry about every ounce of performance. For now, though, my 10-year-old broken laptop is happy and about 66% faster building the new website.</p><p>Until the next update, hopefully far away into the future,</p><p>Pandaqi</p></div></article><div><nav class=pagination><ul><li><a href=/blog/news-and-updates/pandaqi-games-2023-update-iii/ class="masked-link big-mask mask-2" style=--rotation:-1.5deg>&lt;&lt; Previous Page</a></li><li>Continue reading</li><li><a href=/blog/news-and-updates/why-my-games-were-removed-from-the-play-store/ class="masked-link big-mask mask-7" style=--rotation:2deg>>> Next Page</a></li></ul></nav></div></main><footer id=site-footer><div class="padding center-block"><h3>More Pandaqi</h3><p>You could <a href=https://pandaqi.com>visit the game studio</a>.
Or my <a href=https://pandaqi.com/tutorials/>free tutorial website</a>.
Or my <a href=https://rodepanda.com/>portfolio</a> with easy access to absolutely everything I ever made.</p><h3>Latest</h3><nav class=latest><ul><li><a href=/blog/reviews-and-thoughts/should-you-let-your-kids-win/>Should you let your kids win?
(üí¨)</a></li><li><a href=/blog/boardgames/slippery-slopes/>Slippery Slopes
(üêò)</a></li><li><a href=/blog/news-and-updates/pandaqi-games-2024-update/>Pandaqi Games: 2024 Update
(üéÆ)</a></li><li><a href=/blog/reviews-and-thoughts/why-rules-should-be-less-strict/>Why rules should be less strict
(üí¨)</a></li><li><a href=/blog/boardgames/mammoth-messages/>Mammoth Messages
(üêò)</a></li><li><a href=/blog/boardgames/kangaruse/>Kangaruse
(ü¶ò)</a></li><li><a href=/blog/news-and-updates/my-journey-to-becoming-a-game-designer/>My Journey to Becoming a Game Designer
(üé≤)</a></li><li><a href=/blog/news-and-updates/pandaqi-games-solving-the-nightmare-of-text/>Pandaqi Games: Solving the Nightmare called Text
(üéÆ)</a></li><li><a href=/blog/boardgames/waitless-games/creature-quellector/>Creature Quellector
(üêâ)</a></li><li><a href=/blog/boardgames/waitless-games/finger-food/>Finger Food
(üñêÔ∏è)</a></li></ul></nav><h3>Sections</h3><nav><ul><li><a href=/blog/boardgames/>Boardgames
(üé≤)</a></li><li><a href=/blog/news-and-updates/>News & Updates
(üì¢)</a></li><li><a href=/blog/reviews-and-thoughts/>Reviews & Thoughts
(üí≠)</a></li><li><a href=/blog/tutorials/>Tutorials
(üë©‚Äçüéì)</a></li><li><a href=/blog/videogames/>Videogames
(üéÆ)</a></li></ul></nav><h3>Credits</h3><p>Theme by me (<a href=https://pandaqi.com>Pandaqi</a> üêº) &#183;
with ‚ù§Ô∏è &#183;
using <a href=https://gohugo.io>Hugo</a> &#183;
&copy; 2018&ndash;2024 Pandaqi Blog</p></div></footer><link rel=stylesheet type=text/css href=/blog/css/style.css><script src=/blog/js/main.bundle.min.js async defer></script></body></html>