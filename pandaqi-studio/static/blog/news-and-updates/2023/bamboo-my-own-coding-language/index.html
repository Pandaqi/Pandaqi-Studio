<!doctype html><html lang=en-US><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Bamboo: my own coding language | Pandaqi Blog</title>
<link rel=icon type=image/png href=https://pandaqi.com/blog//favicon.png><link rel=stylesheet type=text/css href=/blog/css/critical.min.css></head><body><header id=site-header><nav class=menu><ul><li><a href=https://pandaqi.com/blog/ class="masked-link big-mask mask-2" style=--rotation:2deg>Home</a></li><li><a href=/blog/boardgames/ class="masked-link big-mask mask-4" style=--rotation:1.5deg>Boardgames</a></li><li><a href=/blog/news-and-updates/ class="masked-link big-mask mask-3" style=--rotation:0deg>News & Updates</a></li><li><a href=/blog/reviews-and-thoughts/ class="masked-link big-mask mask-4" style=--rotation:0.5deg>Reviews & Thoughts</a></li><li><a href=/blog/tutorials/ class="masked-link big-mask mask-4" style=--rotation:2deg>Tutorials</a></li><li><a href=/blog/videogames/ class="masked-link big-mask mask-2" style=--rotation:1deg>Videogames</a></li></ul></nav></header><main class="padding center-block"><article class=single-article><div class=thumbnail-media><figure class=thumb-image><picture><img src=pq_bamboo-header.webp loading=lazy decoding=async alt="Thumbnail / Header for article: Bamboo: my own coding language" title="Thumbnail / Header for article: Bamboo: my own coding language" width=1560 height=521></picture></figure></div><h1>Bamboo: my own coding language</h1><aside class=metadata><nav class=breadcrumbs><span class=metadata-label><span class=emoji>ü•ê</span> Breadcrumbs ||</span>
<a href=https://pandaqi.com/blog/>Home</a>
/
<a href=/blog/>Blog</a>
/
<a href=/blog/news-and-updates/>News and updates</a>
/
<a href=/blog/news-and-updates/2023/>2023rd</a>
/
<a href=/blog/news-and-updates/2023/bamboo-my-own-coding-language/>Bamboo my own coding language</a></nav><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/pandaqi.com\/blog\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"\/blog\/","name":"blog"}},{"@type":"ListItem","position":4,"item":{"@id":"\/blog\/news-and-updates\/","name":"news-and-updates"}},{"@type":"ListItem","position":5,"item":{"@id":"\/blog\/news-and-updates\/2023\/","name":"2023"}},{"@type":"ListItem","position":6,"item":{"@id":"\/blog\/news-and-updates\/2023\/bamboo-my-own-coding-language\/","name":"bamboo-my-own-coding-language"}}]}</script><div><span class=metadata-label><span class=emoji>&#8987;</span> Published ||</span>
<time datetime=2023-02-25T00:00:00>Saturday, Feb 25, 2023</time></div><div><span class=metadata-label><span class=emoji>üìñ</span> Table of Contents ||</span>
<a href=# id=toc-toggle>Show</a></div></aside><aside id=table-of-contents class=masked-link-block><header><h2>Table of Contents</h2></header><nav id=TableOfContents><ul><li><a href=#whats-my-purpose>What&rsquo;s my purpose?</a></li><li><a href=#specification>Specification</a><ul><li><a href=#literals>Literals</a></li><li><a href=#math>Math</a></li><li><a href=#variables>Variables</a></li><li><a href=#indexing>Indexing</a></li><li><a href=#conditionals>Conditionals</a></li><li><a href=#conditional-operators>Conditional Operators</a></li><li><a href=#loops>Loops</a></li></ul></li><li><a href=#functions>Functions</a></li><li><a href=#logging>Logging</a></li><li><a href=#an-introduction-to-parsing>An introduction to Parsing</a><ul><li><a href=#how-to-implement-this>How to implement this?</a></li><li><a href=#whats-functional-parsing>What&rsquo;s functional parsing?</a></li><li><a href=#chaining-parsers>Chaining parsers</a></li><li><a href=#examples>Examples</a></li><li><a href=#but-wait-this-only-gives-yesno>But wait, this only gives yes/no?</a></li><li><a href=#the-node-interface>The Node interface</a></li></ul></li><li><a href=#an-application-of-parsing>An application of Parsing</a><ul><li><a href=#where-to-start>Where to start?</a></li><li><a href=#building-our-grammar>Building our grammar</a></li><li><a href=#finally-results>Finally, results!</a></li></ul></li><li><a href=#the-issue-of-whitespace>The issue of whitespace</a><ul><li><a href=#spaces>Spaces</a></li><li><a href=#newlines>Newlines</a></li><li><a href=#semi-functional>Semi-Functional</a></li></ul></li><li><a href=#where-are-we-now>Where are we now?</a><ul><li><a href=#variables-1>Variables</a></li><li><a href=#blocks>Blocks</a></li><li><a href=#functions-1>Functions</a></li><li><a href=#proper-memory-management>Proper memory management</a></li><li><a href=#lists--bags>Lists & Bags</a></li></ul></li><li><a href=#performance>Performance</a><ul><li><a href=#silly-repetition>Silly repetition</a></li><li><a href=#smart-order>Smart order</a></li><li><a href=#simpler-grammar>Simpler grammar</a></li></ul></li><li><a href=#did-it-do-anything>Did it do anything?</a><ul><li><a href=#statements-before>Statements Before</a></li><li><a href=#functions-before>Functions Before</a></li><li><a href=#statements-after>Statements After</a></li><li><a href=#too-many-functions>Too many functions</a></li><li><a href=#delayed-evaluation>Delayed evaluation</a></li><li><a href=#the-final-benchmark>The final benchmark</a></li></ul></li><li><a href=#lists--bags-1>Lists & Bags</a><ul><li><a href=#assignments>Assignments</a></li><li><a href=#the-final-bag>The final bag</a></li><li><a href=#how-to-implement-that>How to implement that?</a></li></ul></li><li><a href=#the-final-stretch>The final stretch</a><ul><li><a href=#implementing-bags>Implementing bags</a></li><li><a href=#resolving-keys>Resolving keys</a></li><li><a href=#adding-built-in-functions>Adding built-in functions</a></li></ul></li><li><a href=#syntax-highlighting>Syntax Highlighting</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></aside><div><p>Bamboo is my own lightweight scripting language. This article is about the whole process of creation, from start to finish. If you want to use it, read the <a href=../bamboo-docs/>documentation</a>.</p><p>I created it for my tutorial website (<a href=https://pandaqi.com/tutorials>Pandaqi Tutorials</a>).</p><p>Why? Because I needed a language for my interactive examples. One that was so <em>simple</em> and <em>small</em> that even those without any coding knowledge could follow. One that didn&rsquo;t require you to know a specific language before you&rsquo;re able to follow the tutorial. One that reads like simple English sentences.</p><p>Of course, &ldquo;create my own language&rdquo; is very ambitious. It&rsquo;s easy to say, hard to execute. In fact, I&rsquo;ve been interested by this since I was a child, but always found the task too daunting to even attempt.</p><p>So how did I finally do it? What techniques did I use? What problems did I encounter?</p><p>This article gives the (mostly fun) <strong>overview of the journey</strong>. I made many mistakes. I hit many stupid errors. I introduce syntax, only to tell you why that was a <em>bad idea</em> a few sections later. If you just want the end result, scroll all the way to the end. But as always, the full journey of mistakes and realizations is way more educational (and interesting) to read.</p><p>This article can be technical at points, but mostly talks about general ideas. So let&rsquo;s start there.</p><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>You can find the end result <a href=https://github.com/pandaqi/pq-daw>on GitHub</a>.</p></aside><h2 id=whats-my-purpose>What&rsquo;s my purpose?</h2><p>I need a language that &mldr;</p><ul><li>Can be executed in a browser using JavaScript</li><li>Reads like basic English sentences</li><li>Is fast/easy enough that I can add interactive windows everywhere in the tutorials (without issue)</li><li>Only supports the barebones of coding &mldr;</li><li>&mldr; but still has enough functionality to actually explain all crucial programming concepts</li></ul><p>Of course, I wanted to cheat at first. Just write a few &ldquo;regular expressions&rdquo; to make my specific examples work.</p><p>But I knew&mdash;in my heart&mdash;this was a terrible idea. Learning happens when people get to actually <em>do</em> and <em>experience</em>. I wanted my readers to be able to play around and write anything they like. I wanted the language to be an actual language, not a gimmick or a magic trick.</p><p>Also, as mentioned, I just wanted to <em>learn</em> how these things are done. Now I had a good excuse to do so.</p><p>With that in mind, I started writing a <strong>specification</strong>.</p><h2 id=specification>Specification</h2><p>I don&rsquo;t know how to write a formal or &ldquo;correct&rdquo; specification. As I said, never even attempted to design a language before! As such, I just wrote the general things I&rsquo;ll need.</p><h3 id=literals>Literals</h3><p>All languages start with &ldquo;atoms&rdquo; or &ldquo;terminals&rdquo;. These are your actual tiny pieces of information. They are &ldquo;literal&rdquo;, they are &ldquo;done&rdquo; (hence <em>terminal</em>). They don&rsquo;t need to evaluate or calculate any further.</p><p>Almost all languages have the same set. I saw no need to change this, although I did change the <em>names</em>.</p><ul><li><code>Number</code> (integers/floats): 1, 2, 3.5</li><li><code>Text</code> (string): &ldquo;bla bla&rdquo;</li><li><code>Truth</code> (bool): true/false</li><li><code>List</code> (array): [elem1, elem2, &mldr; ]</li><li><code>Bag</code>: {key1:elem1, key2:elem2, &mldr; }</li></ul><p>The more I thought about it, the more my language became about <em>changing names</em>. For people new to programming, the word &ldquo;array&rdquo; is probably uncommon or unexpected. It&rsquo;s just a list&mdash;why isn&rsquo;t it called a list?</p><p>Of course, I&rsquo;ve programmed for a long time and understand why languages are designed the way they are. But our purpose is not to create the fastest or most versatile language. It&rsquo;s to create the simplest one for the non-initiated.</p><p>As such, notation for lists and bags could still change.</p><h3 id=math>Math</h3><p>Math works using the regular symbols. There&rsquo;s really no (better) alternative. I do want written alternatives for all symbols: <code>2 plus 2</code> is parsed the same as <code>2 + 2</code>.</p><h3 id=variables>Variables</h3><p>The symbol <code>=</code> is quite well-known, so I want to support it. But, again, let&rsquo;s add a written alternative.</p><p>At first, I wanted to use the keyword <code>is</code>. But then I realized I got into trouble with <em>conditionals</em>: the word &ldquo;is&rdquo; is much better suited there. Writing code to allow both assignments <em>and</em> variables to use the exact same template is &mldr; not a good idea.</p><p>I left it open for a while.</p><p>A moment later, I wanted to find syntax for assignment (<code>a += 2</code>). The <code>+=</code> symbol is far more confusing to beginners. I really wanted an alternative to that.</p><p>This led to the following rules:</p><ul><li><code>put &lt;value> into &lt;var></code> => assignment</li><li><code>change &lt;var> by &lt;value></code> => update</li></ul><p>It reads exactly like what it <em>does</em>. It&rsquo;s more verbose, and restricting, than other languages. But I think it&rsquo;s enough.</p><h3 id=indexing>Indexing</h3><p>How do we work with lists or bags? (Arrays or dictionaries.)</p><p>They need to support a few key properties</p><ul><li>Indexing => getting one specific item</li><li>Assignment => putting one specific item in it</li><li>Size => getting the length</li><li>Keys/Values => getting these somehow</li></ul><p>I specified these as follows.</p><ul><li><code>item &lt;index> of &lt;var></code></li><li><code>put &lt;value> into &lt;var> at &lt;index></code></li><li><code>length of &lt;var></code></li><li><code>labels of &lt;var></code> and <code>items of &lt;var></code></li></ul><p>Moreover, we need an easy way to <em>iterate</em> over these. But I&rsquo;ll leave that for when we get to <strong>loops</strong>.</p><h3 id=conditionals>Conditionals</h3><p>These also read like a sentence: <code>if &lt;a> is &lt;b> then</code></p><p>Here I encountered my next question: when do statements end? When do blocks start and end?</p><p>Forgetting to add semicolons or braces is <em>another</em> common hurdle for beginners. I knew quite quickly that I wanted to use &mldr;</p><ul><li>Newlines to separate statements</li><li>Tabs/Indentation for blocks</li></ul><p>How I was going to code that &mldr; I had no clue. But it seemed like the only reasonable solution if I want the language to be as accessible as possible.</p><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>Coding it would probably be easier if I require some word to finish the block, like <code>end</code>. But I want to avoid that, if possible.</p></aside><h3 id=conditional-operators>Conditional Operators</h3><p>Inverting is easy: add the word <code>not</code> in front.</p><p>Logical &ldquo;or&rdquo; and &ldquo;and&rdquo; just use those words: <code>or</code> and <code>and</code></p><p>More complicated checks&mdash;such as &ldquo;greater than&rdquo;&mdash;are still up for discussion. Writing them out is <em>very</em> verbose. For the moment, I decided on this compromise:</p><ul><li><code>below</code> for &ldquo;less than&rdquo;</li><li><code>above</code> for &ldquo;greater than&rdquo;</li></ul><p><em>What about else? And else if?</em> They&rsquo;re not necessary. I rarely ever use these anymore. So they go away.</p><aside class="example masked-link-block"><span class=label>Example ||</span><p>Instead, you write your code using guard clauses. If something is not true, return out of the function. If something else is not true, go away. This way, you get the same functionality, but with less syntax and less nesting / levels of indentation.</p></aside><h3 id=loops>Loops</h3><p>I wrote down a few different syntaxes. I didn&rsquo;t like any of them for my language.</p><p>You have the traditional for loop. But that&rsquo;s a <em>bunch</em> of syntax.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=ln>1</span><span class=cl><span class=k>for</span><span class=p>(</span><span class=kd>var</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>    <span class=p>...</span> <span class=k>do</span> <span class=nx>stuff</span> <span class=p>...</span>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=p>}</span></span></span></code></pre></div><p>I liked the &ldquo;do-while&rdquo; loop best. Because it reads like a sentence again: &ldquo;do the following, while something is true&rdquo;. But even that isn&rsquo;t great. It creates this huge distance between one part of your loop (the declaration) and the rest (when it terminates).</p><p>Considering it some more, I realized I barely use loops that way anyway. It&rsquo;s not needed. We can just &mldr;</p><ul><li>Add one <code>repeat</code> keyword.</li><li>Then break out of it with a simple <code>stop</code>.</li></ul><p>For ranging over lists and stuff, we can add some (tiny) syntactic sugar.</p><ul><li><code>for all items in &lt;var></code></li><li><code>for &lt;number> ... &lt;number></code></li></ul><p>I think that&rsquo;s more than enough. The main idea is that I want a simple keyword or sentence structure for each type of statement. (Because I think that will help when coding. But I don&rsquo;t really know yet, as I haven&rsquo;t started implementation.)</p><h2 id=functions>Functions</h2><p>This was my biggest fear :p These are complex, they need <em>some</em> syntax, and I wasn&rsquo;t sure how to approach it.</p><p>For now, I decided to rename them to <em>machines</em>. You put something in, to get something out. I think this analogy will work well, but it might change. (People expect a <em>machine</em> to always produce the same result. If you press &ldquo;home&rdquo; on your phone, it always goes to the home screen.)</p><p>To <strong>define</strong> a function: <code>machine &lt;name> wants &lt;params></code></p><p>To <strong>call</strong> it: <code>give &lt;arguments> to &lt;name></code></p><p>To <strong>return</strong> from them: <code>output &lt;result></code></p><p>How is a list of arguments given? You guessed it: just words separated by <code>and</code>.</p><p>This is enough. Like any language, you can chain these to <em>save</em> the result value.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=ln>1</span><span class=cl><span class=nx>machine</span> <span class=nx>adder</span> <span class=nx>wants</span> <span class=nx>a</span> <span class=nx>and</span> <span class=nx>b</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>    <span class=nx>output</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=nx>end</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=nx>put</span> <span class=p>(</span><span class=nx>give</span> <span class=mi>5</span> <span class=nx>to</span> <span class=nx>adder</span><span class=p>)</span> <span class=nx>into</span> <span class=nx>result</span></span></span></code></pre></div><p>But it has a few issues.</p><ul><li>The line above isn&rsquo;t how a normal sentence works. (The order is confusing.)</li><li>Returning without giving back a value can be confusing this way.</li></ul><p>I wrote some ideas to improve that.</p><ul><li>To call and get the return value: <code>give &lt;arguments> to &lt;name> and output to &lt;var></code></li><li>To hard return out of a function: <code>unplug</code></li></ul><p>You&rsquo;d get code like below.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=ln>1</span><span class=cl><span class=nx>machine</span> <span class=nx>login</span> <span class=nx>wants</span> <span class=nx>username</span> <span class=nx>and</span> <span class=nx>password</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>    <span class=k>if</span> <span class=nx>not</span> <span class=nx>username</span> <span class=nx>then</span> <span class=nx>unplug</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>    <span class=nx>output</span> <span class=s2>&#34;Logged in!&#34;</span>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=nx>end</span>
</span></span><span class=line><span class=ln>5</span><span class=cl>
</span></span><span class=line><span class=ln>6</span><span class=cl><span class=nx>give</span> <span class=s2>&#34;Pandaqi&#34;</span> <span class=nx>and</span> <span class=s2>&#34;1234&#34;</span> <span class=nx>to</span> <span class=nx>login</span> <span class=nx>and</span> <span class=nx>output</span> <span class=nx>to</span> <span class=nx>result</span>
</span></span><span class=line><span class=ln>7</span><span class=cl><span class=nx>tell</span> <span class=nx>result</span></span></span></code></pre></div><h2 id=logging>Logging</h2><p>Yes, the final piece of the puzzle. Some way to actually <em>output</em> or <em>use</em> the result. I ended up on the word <code>tell</code>.</p><p>Other things like &ldquo;sing&rdquo; or &ldquo;shout&rdquo; are fun, but too childish. Turning it into a sentence is too verbose and won&rsquo;t always work (depending on how you name your variables).</p><p>Looking at this, my syntax seems a mix of Lua, Python and Go.</p><p>Let&rsquo;s make it!</p><h2 id=an-introduction-to-parsing>An introduction to Parsing</h2><p>This specification isn&rsquo;t watertight. I knew things would change, but I needed to just <em>start somewhere</em>. Do some research, get an intuition for this, see problems as they arise.</p><p>Writing your own language is a tough problem. Which means I did what I always do: break it down into the smallest possible steps and prioritize that. Once I have <em>some</em> starting point (from my research), just execute that.</p><p>Below is what I learned from that initial research.</p><p>To create a language, you need &mldr;</p><ul><li><strong>A Tokenizer</strong> (or lexer): something that reads your big blob of <em>code</em> and chops it into tiny pieces, or &ldquo;tokens&rdquo;.</li><li><strong>An Abstract Syntax Tree</strong> (or AST): something that converts those tokens into a tree, which it can simply evaluate (from leaves to branches) to get the final result.</li><li><strong>String parsing functionality</strong>: because my language is built on top of JavaScript, I get this for free. For any native functionality, I just call the JavaScript for it!</li></ul><p>A Tokenizer uses <em>patterns</em> to recognize the little parts that make up your code. For example, when it finds &ldquo;number + number&rdquo;, it recognizes that as one token&mdash;the &ldquo;add operation&rdquo;.</p><p>The AST is a quite direct result of that. It provides actual nodes for all the tokens. You give these nodes a simple function like <code>evaluate</code> or <code>getResult</code>, which extracts the value. Because it&rsquo;s a tree, nodes higher on the tree contain nodes below them. Executing your code simply means a long list of recursive function calls.</p><aside class="example masked-link-block"><span class=label>Example ||</span><p>When you call <code>evaluate()</code> on the top node, it calls its child, which calls its child, and so forth&mdash;until it finds an actual value.</p><p>Then it returns the value all the way up the chain. Any node that wants to do something with it, does so. And it keeps bubbling up, and up, until it reaches the top node with the <em>end result</em> of our code.</p></aside><aside class="example masked-link-block"><span class=label>Example ||</span><p>A node like &ldquo;add operation&rdquo; will contain two values:</p><ul><li>The first value</li><li>The second value</li></ul><p>Its <code>evaluate</code> function then simply returns &ldquo;value1 + value2&rdquo;.</p></aside><p>The tree structure is important to remember here. Those values for the add operation? They might not be actual values. They might be an operation themselves, or another expression.</p><p>If your tokenizer did its job, it will have matched the <em>smallest</em> parts first (one value, one operator, etc.), and continued from there until it matched the <em>largest</em> patterns (a whole statement, a whole code block).</p><p>This means the tree follows automatically.</p><h3 id=how-to-implement-this>How to implement this?</h3><p>Most languages use a <em>recursive descent parser</em> (or a variation on it). If you read the explanation above, you already know what it does.</p><ul><li>It&rsquo;s recursive: it calls function after function</li><li>It descends: with each function call, it goes <em>deeper</em> into the code (towards smaller and smaller patterns)</li></ul><p>If you look this up, you&rsquo;ll find the usual nonsense that seems to come with any academic field (such as computer science). Article after article that tells you the <em>exact same theoretical definitions</em>, without giving an example or any practical tips! It&rsquo;s like one person wrote the theory, and all other websites just copied it blindly.</p><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>Once we start talking about &ldquo;the left recursion problem&rdquo;, you&rsquo;ll see me get even angrier about this :p</p></aside><p>In the end, it took a while before I found a few videos/articles that clicked with me. They actually <em>showed</em> how to do it and were 100% <em>practical</em>.</p><p>I chose to follow this methodology, which is called <strong>functional parsing</strong>.</p><h3 id=whats-functional-parsing>What&rsquo;s functional parsing?</h3><p>Your parser only has <em>functions</em> that go <code>String -> [Tree, leftoverString]</code></p><p>In other words, each parser function</p><ul><li>Receives a string (the part of your code you haven&rsquo;t parsed yet)</li><li>And returns two things.<ul><li>The tree parsed so far</li><li>And the string left over</li></ul></li></ul><p>As expected, it&rsquo;s best to just go left to right. To just check if the first character of the string matches whatever we want to check.</p><p>And if a parser fails? We just return an empty array (<code>[]</code>).</p><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>This approach has advantages and disadvantages, like everything. It&rsquo;s very clean, fast and makes for simple code. It also cannot do some things that are extremely easy in non-functional parsing.</p></aside><p>Let&rsquo;s use a simple example. We write a parser <code>char</code> that checks if the first character of the string is a specific character.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=ln> 1</span><span class=cl><span class=kr>const</span> <span class=kr>char</span> <span class=o>=</span> <span class=p>(</span><span class=nx>c</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=nx>str</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>        <span class=kr>const</span> <span class=nx>matches</span> <span class=o>=</span> <span class=nx>str</span><span class=p>.</span><span class=nx>length</span> <span class=o>&amp;&amp;</span> <span class=nx>str</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=nx>c</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=nx>matches</span><span class=p>)</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>            <span class=k>return</span> <span class=p>[</span><span class=nx>str</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nx>str</span><span class=p>.</span><span class=nx>slice</span><span class=p>(</span><span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>
</span></span><span class=line><span class=ln>11</span><span class=cl><span class=kr>char</span><span class=p>(</span><span class=s2>&#34;c&#34;</span><span class=p>)(</span><span class=s2>&#34;cat&#34;</span><span class=p>);</span> <span class=c1>// [&#34;c&#34;, &#34;at&#34;]
</span></span></span><span class=line><span class=ln>12</span><span class=cl><span class=c1></span><span class=kr>char</span><span class=p>(</span><span class=s2>&#34;z&#34;</span><span class=p>)(</span><span class=s2>&#34;cat&#34;</span><span class=p>);</span> <span class=c1>// []
</span></span></span></code></pre></div><p>Our parsing program will exist out of many of these <em>tiny function generators</em>. On their own, they are obviously too simple and can&rsquo;t achieve much. But when <em>chained</em> together (in a few ways), it can do parsing magic.</p><h3 id=chaining-parsers>Chaining parsers</h3><p>Here you see why we return a <em>function</em>, instead of a <em>value</em>. Because most of the time, we don&rsquo;t know exactly what we&rsquo;re going to find. That&rsquo;s the whole point.</p><p>We have multiple patterns to check. We want the first one that succeeds (and parse it), or if all of them fail, parsing has failed.</p><p>That&rsquo;s why I started the parsing library with a few crucial helper functions. I was lucky enough to find a <em>great</em> resource about functional parsing in JavaScript here: <a href=https://github.com/lupomontero/parsing>GitHub Parser Library</a></p><p>I copied its code, rewrote it so I understood what it did, then built everything else on top of it.</p><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>In general, you&rsquo;ll see the code for the parser is pretty verbose and explicit. Just vanilla JavaScript. No tricks used to make it shorter or to produce &ldquo;one-liners&rdquo;. To help me understand it better and prevent mistakes.</p></aside><p>Here&rsquo;s the summary.</p><ul><li><code>seq</code>: receives a list of parser functions. It tries them all in sequence and they must all succeed.</li><li><code>choice</code>: receives a list of parser functions. It tries them all and returns the first one that succeeds. (It only fails if all of them fail.)</li><li><code>nothing</code>: will accept the input as correct without actually parsing/changing it (useful for defaults or failsafes)</li><li><code>some</code>: executes a parser once, then repeats until it fails. (It only fails if the first one fails, otherwise any number of matches is fine.)</li></ul><p>This is, essentially, all you need. I won&rsquo;t share the source code for these functions, as it&rsquo;s just too long and precise to be nice and easy to explain. This is a general overview, not an in-depth technical course. You can find it the <a href=https://github.com/pandaqi/bamboo>source code</a>, in the file <code>Parser</code>. (Or in that other GitHub project I linked, which is smaller and perhaps more beginner-friendly.)</p><p>But I&rsquo;ll give examples on how to <em>use</em> them in practice.</p><h3 id=examples>Examples</h3><p>Let&rsquo;s start very simple. We want to check if we&rsquo;ve encountered a boolean: &ldquo;true&rdquo; or &ldquo;false&rdquo;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=ln> 1</span><span class=cl><span class=c1>// checks if the next symbols are exactly the string &#34;c&#34; we provided
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>chars</span> <span class=o>=</span> <span class=p>(</span><span class=nx>c</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=nx>str</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=nx>str</span><span class=p>.</span><span class=nx>length</span> <span class=o>&lt;</span> <span class=nx>c</span><span class=p>.</span><span class=nx>length</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=p>[];</span> <span class=p>}</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>        <span class=kr>const</span> <span class=nx>match</span> <span class=o>=</span> <span class=p>(</span><span class=nx>str</span><span class=p>.</span><span class=nx>slice</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>length</span><span class=p>)</span> <span class=o>==</span> <span class=nx>c</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=nx>match</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=p>[];</span> <span class=p>}</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>        <span class=k>return</span> <span class=p>[</span><span class=nx>str</span><span class=p>.</span><span class=nx>slice</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>length</span><span class=p>),</span> <span class=nx>str</span><span class=p>.</span><span class=nx>slice</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>length</span><span class=p>)];</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>
</span></span><span class=line><span class=ln>11</span><span class=cl><span class=c1>// first try matching true, then try false
</span></span></span><span class=line><span class=ln>12</span><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>bool</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=nx>str</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>        <span class=k>return</span> <span class=nx>choice</span><span class=p>(</span><span class=nx>chars</span><span class=p>(</span><span class=s2>&#34;true&#34;</span><span class=p>),</span> <span class=nx>chars</span><span class=p>(</span><span class=s2>&#34;false))(str);
</span></span></span><span class=line><span class=ln>15</span><span class=cl><span class=s2>    }
</span></span></span><span class=line><span class=ln>16</span><span class=cl><span class=s2>}
</span></span></span><span class=line><span class=ln>17</span><span class=cl><span class=s2>
</span></span></span><span class=line><span class=ln>18</span><span class=cl><span class=s2>bool()(&#34;</span><span class=kc>false</span><span class=s2>&#34;); // [&#39;false&#39;, &#39;&#39;]
</span></span></span><span class=line><span class=ln>19</span><span class=cl><span class=s2>bool()(&#34;</span><span class=nx>what</span><span class=s2>&#34;); // []
</span></span></span><span class=line><span class=ln>20</span><span class=cl><span class=s2>bool()(&#34;</span><span class=kc>true</span><span class=err>&#34;</span><span class=p>);</span> <span class=c1>// [&#39;true&#39;, &#39;&#39;]
</span></span></span></code></pre></div><p>That&rsquo;s the idea. You find the tiniest possible parts of your language and write a simple &ldquo;parser&rdquo; to find them. Then you chain them together into <em>bigger</em> parts (like &ldquo;expression&rdquo; or &ldquo;assignment&rdquo;), until you&rsquo;re all the way at the top and can parse your whole code.</p><p>For example, let&rsquo;s take the next step. We want to check if the next set of symbols is a <em>literal</em>. A literal value, which is either a boolean, a string, or a number. Then you&rsquo;d write &mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=ln> 1</span><span class=cl><span class=c1>// for simplicity, let&#39;s assume all our numbers are floating point: XX.XXXX
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=c1>// we match any sequence of digits, a dot, and then more digits
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>number</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=nx>str</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>        <span class=k>return</span> <span class=nx>seq</span><span class=p>(</span><span class=nx>some</span><span class=p>(</span><span class=nx>digits</span><span class=p>()),</span> <span class=kr>char</span><span class=p>(</span><span class=s2>&#34;.&#34;</span><span class=p>),</span> <span class=nx>some</span><span class=p>(</span><span class=nx>digits</span><span class=p>()))(</span><span class=nx>str</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>
</span></span><span class=line><span class=ln> 9</span><span class=cl><span class=c1>// for simplicity, let&#39;s assume we can&#39;t have empty strings
</span></span></span><span class=line><span class=ln>10</span><span class=cl><span class=c1>// this will match any set of symbols that are &#34;valid in a string&#34;, but at least one
</span></span></span><span class=line><span class=ln>11</span><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>string</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=nx>str</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>        <span class=k>return</span> <span class=nx>seq</span><span class=p>(</span><span class=nx>some</span><span class=p>(</span><span class=nx>stringchars</span><span class=p>()))(</span><span class=nx>str</span><span class=p>);</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>15</span><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>
</span></span><span class=line><span class=ln>17</span><span class=cl><span class=c1>// this will check if something is a boolean first, then a string, then a number
</span></span></span><span class=line><span class=ln>18</span><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>literal</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=nx>str</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>        <span class=k>return</span> <span class=nx>choice</span><span class=p>(</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>            <span class=nx>bool</span><span class=p>(),</span>
</span></span><span class=line><span class=ln>22</span><span class=cl>            <span class=nx>string</span><span class=p>(),</span>
</span></span><span class=line><span class=ln>23</span><span class=cl>            <span class=nx>number</span><span class=p>()</span>
</span></span><span class=line><span class=ln>24</span><span class=cl>        <span class=p>)(</span><span class=nx>str</span><span class=p>);</span>
</span></span><span class=line><span class=ln>25</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>26</span><span class=cl><span class=p>}</span></span></span></code></pre></div><h3 id=but-wait-this-only-gives-yesno>But wait, this only gives yes/no?</h3><p>Yes! So far, the parser just gives us a &ldquo;fail&rdquo; (empty result) or a &ldquo;succeed&rdquo; (the whole string parsed).</p><p>But we want to actually <em>use</em> that data, right? We want to actually turn them into tokens, with meaning and properties.</p><p>That&rsquo;s why these helper functions get a second argument. Besides a list of <strong>parsers</strong>, you can add a <strong>return function</strong>.</p><ul><li>This function receives the parsed result.</li><li>Within it, you can do <em>anything you want</em> with that result.</li><li>And whatever you output from that function is then saved in the left side of the output (the &ldquo;parsed so far&rdquo;-side)</li></ul><p>Again, an example will show this. Let&rsquo;s say we match a literal. Then we want to convert it into a node with the right value.</p><p>In this case, that&rsquo;s just an instance of the class <code>Literal</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=ln> 1</span><span class=cl><span class=c1>// the returner functions are incredibly simple, but a crucial part for making this work
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=c1>// @NOTE: the arguments to &#34;choice&#34; are now in an array, because we need to add the returner as an argument
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>literal</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    <span class=kr>const</span> <span class=nx>returner</span> <span class=o>=</span> <span class=p>(</span><span class=nx>res</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=nx>Literal</span><span class=p>(</span><span class=nx>res</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>
</span></span><span class=line><span class=ln> 8</span><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=nx>str</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>        <span class=k>return</span> <span class=nx>choice</span><span class=p>([</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>            <span class=nx>bool</span><span class=p>(),</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>            <span class=nx>string</span><span class=p>(),</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>            <span class=nx>number</span><span class=p>()</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>        <span class=p>],</span> <span class=nx>returner</span><span class=p>)(</span><span class=nx>str</span><span class=p>);</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>15</span><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Now remember the general idea of this algorithm. It&rsquo;s <em>recursive descent</em>. So this value&mdash;this node&mdash;is returned to whatever function called us. If an &ldquo;expression&rdquo; matched this literal, it will receive the value and can save it inside its own node. One level up, a &ldquo;statement&rdquo; might have matched this expression&mdash;it gets the value and saves it inside its own node.</p><p>That&rsquo;s how the nodes are automatically built and linked into a tree. Each node will not only have its data &mldr; you can also add other useful properties!</p><h3 id=the-node-interface>The Node interface</h3><p>In my case, I knew I also wanted a syntax highlighter. In fact, that&rsquo;s where I started. That was my &ldquo;smallest possible step&rdquo;: if I can tokenize a few numbers to recognize that <em>they are numbers</em> (and give them some CSS class), then I&rsquo;ll at least have a starting point.</p><p>Which means all nodes have a <code>toString()</code> function. This returns its value inside some HTML nodes saying <em>what is inside</em>, so I can style that.</p><p>They also all have a <code>toResult()</code> function. This returns its actual value.</p><p>At first, I gave all nodes a <code>toType()</code> function as well. But then I realized I was being stupid. I can easily <em>link</em> value and type, instead of storing and retrieving it separately! I should do that!</p><p>So I created one (very simple) <code>Value</code> class, which simply holds a value and its type. This is what&rsquo;s saved at the leaves of the tree (the literals, the actual data), and passed upwards.</p><p>This means <code>toResult()</code> gives you a <code>Value</code> object instead. (From which I can read either the value or its type, whatever I want.)</p><h2 id=an-application-of-parsing>An application of Parsing</h2><p>First, I setup a very simple <code>&lt;pre></code> with attribute <code>contentEditable=true</code>. This is an HTML attribute that, well, allows you to directly edit the contents of anything.</p><p>Why is this important? Why don&rsquo;t we just use a text input field? For syntax highlighting. Because it&rsquo;s a <code>&lt;pre></code> element, we can put <em>HTML tags</em> inside (to style our tokens), and whitespace is preserved.</p><p>When it receives input, it grabs the content (<code>innerHTML</code>) and feeds it to the parser. This will return that tree.</p><p>I call <code>toString()</code> on it and put the result back into the node.</p><p>There&rsquo;s a crucial step here that I copied from somebody else&rsquo;s code! When you replace the content of that <code>&lt;pre></code> with the parsed content, it&rsquo;s obviously &mldr; different. It&rsquo;s now encapsulated in many nodes. It might have grown in size due to CSS styling.</p><p>So you need to</p><ul><li>Keep the selection where it was.</li><li>And strip <em>out</em> all the tags before you feed it into the parser again.</li></ul><p>This is 100+ lines of copied code that I don&rsquo;t completely understand, but it works!</p><h3 id=where-to-start>Where to start?</h3><p>Okay, by this point I have many of those atomic parsing functions. I can get literals, I can recognize characters, I can see things as numbers (both integers and floats), that&rsquo;s great.</p><p>Now we need to combine it into a <strong>grammar</strong>. A grammar is a set of rules for the language that define <em>patterns</em> and give them a <em>name</em>. These go from most <em>general</em> to most <em>specific</em>. Remember our algorithm again: this means the most specific ones are most important. Lower on the list = higher priority.</p><p>This is best illustrated with arithmetic. We&rsquo;ve all learned the order of operations:</p><ul><li>First evaluate anything in brackets&mdash;any &ldquo;groups&rdquo;</li><li>Then multiplication (and division)</li><li>Then addition (and subtraction)</li></ul><p>In grammar notation, we get</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=ln>1</span><span class=cl><span class=nx>Expr</span> <span class=o>::=</span> <span class=nx>Term</span> <span class=o>+</span> <span class=nx>Expr</span> <span class=o>|</span> <span class=nx>Term</span> <span class=o>-</span> <span class=nx>Expr</span> <span class=o>|</span> <span class=nx>Term</span>  <span class=c1>// Expression =&gt; plus and minus
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=c1></span><span class=nx>Term</span> <span class=o>::=</span> <span class=nx>Factor</span> <span class=o>*</span> <span class=nx>Term</span> <span class=o>|</span> <span class=nx>Factor</span> <span class=o>/</span> <span class=nx>Term</span> <span class=o>|</span> <span class=nx>Factor</span> <span class=c1>// Term =&gt; multiply and divide
</span></span></span><span class=line><span class=ln>3</span><span class=cl><span class=c1></span><span class=nx>Factor</span> <span class=o>::=</span> <span class=p>(</span><span class=nx>Expr</span><span class=p>)</span> <span class=o>|</span> <span class=nx>Literal</span> <span class=c1>// Factor =&gt; grouping or final value
</span></span></span></code></pre></div><p>An expression is either a term <code>+</code> an expression, a term <code>-</code> an expression, or it&rsquo;s just a term. Yes, the <code>|</code> means &ldquo;or&rdquo;. (The <code>choice</code> parser we defined earlier!)</p><p>The grammar is written this way on purpose. These definitions depend on each other. This opens the possibility for an <strong>endless loop</strong>.</p><ul><li>Expression checks for another expression</li><li>Which will check for another expression</li><li>And so on</li><li>&mldr;</li></ul><p>How do we prevent this? By adding the dependency <em>later</em>. The &ldquo;Expr&rdquo; is on the <em>right</em> of the &ldquo;Term&rdquo;. This means that we don&rsquo;t cycle endlessly, because an expression never matches only itself. It always matches <em>something else</em> plus itself. Which means it keeps consuming more parts of the string and <em>will</em> terminate.</p><h3 id=building-our-grammar>Building our grammar</h3><p>You can continue this pattern and add, for example, exponentiation and variables. (Where exponents come before multiplication, of course. And variables resolve to values, so they are functionally on the same priority level as literals.)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=ln>1</span><span class=cl><span class=nx>Expr</span> <span class=o>::=</span> <span class=nx>Term</span> <span class=o>+</span> <span class=nx>Expr</span> <span class=o>|</span> <span class=nx>Term</span> <span class=o>-</span> <span class=nx>Expr</span> <span class=o>|</span> <span class=nx>Term</span> 
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=nx>Term</span> <span class=o>::=</span> <span class=nx>Exp</span> <span class=o>*</span> <span class=nx>Term</span> <span class=o>|</span> <span class=nx>Exp</span> <span class=o>/</span> <span class=nx>Term</span> <span class=o>|</span> <span class=nx>Exp</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=nx>Exp</span> <span class=o>::=</span> <span class=nx>Factor</span> <span class=o>^</span> <span class=nx>Exp</span> <span class=o>|</span> <span class=nx>Factor</span>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=nx>Factor</span> <span class=o>::=</span> <span class=p>(</span><span class=nx>Expr</span><span class=p>)</span> <span class=o>|</span> <span class=nx>Literal</span> <span class=o>|</span> <span class=nx>Variable</span></span></span></code></pre></div><p>And what is code &mldr; if not just a long list of expressions? The <code>*</code> behind a definition is the same as our <code>some</code> function: match least once, and as much as possible.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=ln>1</span><span class=cl><span class=nx>Code</span> <span class=o>::=</span> <span class=p>(</span><span class=nx>Block</span><span class=p>)</span><span class=o>*</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=nx>Block</span> <span class=o>::=</span> <span class=p>(</span><span class=nx>Statement</span><span class=p>)</span><span class=o>*</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=nx>Statement</span> <span class=o>::=</span> <span class=p>(</span><span class=nx>Expr</span><span class=p>)</span><span class=o>*</span></span></span></code></pre></div><p>This is obviously not the full grammar. But now we have a functional parser. We start by matching the <em>code</em> pattern, which will automatically match further and further, down to the variables and literals.</p><p>If written correctly, there should never be an endless loop. And it should be like magic :p</p><p>Coding this was a lot like trying to code in the language Rust. Either you hit some stupid limitation with the &ldquo;rules&rdquo; of the system &mldr; or your code runs and you are 100% sure it works flawlessly. If all parser functions are correct&mdash;and that&rsquo;s easy to check, they are usually only two lines&mdash;the result will always be correct.</p><h3 id=finally-results>Finally, results!</h3><p>With this knowledge, I could now extend my syntax highlighter to actually calculate formulas.</p><p>That was my next &ldquo;tiny step&rdquo;. First tokenizing, then syntax highlighting, then calculating simple math.</p><p>During this process, I hit a few noteworthy walls.</p><ul><li>Accidentally rounding things here and there. (For example, I called <code>parseInt</code> on a string which could also be a float.)</li><li><strong>Type coercion.</strong> To be accessible, my language has to allow basically any type to operate on any other type. This meant defining what it meant to, for example, multiply a boolean and a string.</li><li>The biggest of them all &mldr; <strong>whitespace</strong></li></ul><h2 id=the-issue-of-whitespace>The issue of whitespace</h2><p>Honestly, I never expected the biggest demon of parsing to be <em>whitespace</em>. But here we are. Let me explain.</p><h3 id=spaces>Spaces</h3><p>Whitespace is for humans &mldr; mostly. The computer doesn&rsquo;t care if you type <code>2+2</code> or <code>2 + 2</code>. But we do: things are more readable, and more like natural language, with spaces and newlines.</p><p>This is true for <em>most</em> things, but not all. Variables, for example, need a clear start and end. Otherwise we <em>cannot</em> know if something is a variable.</p><p>For example, let&rsquo;s say you type <code>ifvaristruethen</code>. How is the parser supposed to know it&rsquo;s an if-statement with a variable <code>var</code>? With our rules so far, it would just assume the whole thing refers to one variable. We might filter out the <code>if</code> at the start, or the <code>true</code> as a boolean, but that would mean <em>forbidding</em> those sequences of characters from all variables!</p><p>All my kneejerk reactions to whitespace don&rsquo;t work:</p><ul><li>Split the code on whitespaces? Can&rsquo;t be done. Many patterns work across whitespaces, so you need match further than just your current word.</li><li>Collapse all whitespace? Can&rsquo;t be done. Due to the example above, but also because syntax highlighting would stop working. (You&rsquo;d type something with whitespace &mldr; and then it parses the result and gives your code back without any space :p)</li></ul><p>Just to keep going, I started capturing whitespace within patterns. For example, my pattern to match the ADDITION operator, will match both <code>2+2</code> and <code>2 + 2</code>. The extraneous whitespace is saved on the node, so it can put it back when needed.</p><p>This is fine, and probably 90% of the final solution. I just need to be smart about which nodes capture the white space, and how to deal with that efficiently.</p><h3 id=newlines>Newlines</h3><p>The same happened with newlines. My kneejerk reaction was to split all statements on newlines.</p><p>But this doesn&rsquo;t work for the same reasons. A &ldquo;block of code&rdquo; (the second-highest pattern in our grammar) <em>will</em> usually work over multiple lines.</p><p>Instead, newlines need to be smartly integrated with the patterns as well.</p><p>But &mldr; the <em>last</em> line of our code will not have a newline (usually). So &mldr; aargh!</p><p>In the end, I added a <code>lineterminator</code> parser.</p><ul><li>It checks for newline symbols (<code>\n</code> and <code>\r</code>) <em>or</em> the end of the input string.</li><li>Every <em>statement</em> needs to end with one.</li><li>(And a block is just a list of statements)</li><li>(In other languages, you might use a symbol like a semicolon (<code>;</code>) to split statements.)</li></ul><p>The hardest part was teaching the program about blocks. I didn&rsquo;t want to introduce symbols for denoting blocks (like <code>{</code> and <code>}</code>). That would&rsquo;ve been rather easy to parse:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=ln>1</span><span class=cl><span class=kr>const</span> <span class=nx>block</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=nx>str</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>        <span class=nx>seq</span><span class=p>([</span><span class=kr>char</span><span class=p>(</span><span class=s2>&#34;{&#34;</span><span class=p>),</span> <span class=nx>whitespace</span><span class=p>(),</span> <span class=nx>some</span><span class=p>(</span><span class=nx>statement</span><span class=p>()),</span> <span class=nx>whitespace</span><span class=p>(),</span> <span class=kr>char</span><span class=p>(</span><span class=s2>&#34;}&#34;</span><span class=p>)])</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=p>}</span></span></span></code></pre></div><p>This made my life considerably harder.</p><p>I did research. I read the <a href=https://docs.python.org/3/reference/lexical_analysis.html>Python docs</a>. (They are surprisingly well-written and easy to follow.)</p><p>But because I was fully functional in my approach, their method didn&rsquo;t work for me. All I have are <em>functions</em>, which both tokenize <em>and</em> build the tree at the same time.</p><p>Most languages, though, separate this:</p><ul><li>Tokenizer: produces just a long list of tokens</li><li>TreeBuilder: goes through the list to combine the right ones into a tree.</li></ul><p>At this point, I took some time off to consider if I wanted to research and rewrite. Yes, a more powerful (and generally adopted) method would be nice. But it felt like too big of a step&mdash;something that was currently above my understanding and available time for this project. The current code was simple and clean, which I liked.</p><h3 id=semi-functional>Semi-Functional</h3><p>As I read more docs (and general article about parsing), I realized none of them even mentioned the idea of &ldquo;blocks&rdquo; :p They all evaluated line by line. A &ldquo;line statement&rdquo; was the highest group.</p><p>Slowly it dawned on me that this was the solution. Instead of going Code -> Blocks -> Statements, I could make Statements the highest level.</p><p>When parsing, I catch all statements. Then I loop over them, keeping track of indentation. When I see the next line increases, I start a new block. All statements from now on are part of that block. Until the indentation decreases again, and this block is done.</p><p>A <code>Block</code> node is then nothing more than:</p><ul><li>Its defining statement (such as <code>for ...</code> or <code>if ...</code>)</li><li>The list of statements that belong to it</li></ul><p>The defining statement determines the type of block. What it actually does with its statements.</p><ul><li>An <code>if</code> statement will only execute the statements if its condition is correct</li><li>A <code>for</code> statement will execute its statements as many times as the loop wants</li><li>Etcetera</li></ul><p>It&rsquo;s optional. The first level for example&mdash;without indentation&mdash;is just a block of statements with no other meaning attached.</p><p>I thought it was a nice compromise. We&rsquo;re still 99% functional, but this solves our last big issues.</p><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>I just needed to fiddle a bit with what constitutes &ldquo;a space&rdquo; and how many spaces is a &ldquo;tab&rdquo; and all that. Again, whitespace is the real issue with parsing!</p></aside><h2 id=where-are-we-now>Where are we now?</h2><p>The code can recognize indented code as its own block, and attach meaning to it. This is how it chops the whole code into chunks. On top of that, it can evaluate mathematical expressions.</p><p>A good start. Nowhere near a complete language, of course. We need a few crucial things:</p><ul><li><strong>Variables</strong>: retrieving and assigning</li><li><strong>Blocks</strong>: the if-statement, for-loops, etcetera.</li><li><strong>Functions</strong>: ability to call and retrieve result</li><li><strong>Lists & Bags</strong>: ability to declare, index, use these two data types</li></ul><p>With all this groundwork&mdash;fortunately&mdash;these have become rather easy.</p><h3 id=variables-1>Variables</h3><p>For this, I used a good old JavaScript dictionary. Just one big variable called &ldquo;MEMORY&rdquo;.</p><ul><li>When a variable is declared, it enters it into MEMORY. When updated, it just enters the new value.</li><li>When a variable is retrieved, it asks for the key ( = the name) in MEMORY. If not found, throw some errors.</li></ul><p>I ended up making this variable local to the parser. Seemed neater than attaching it to the window, especially because that might mess with things if there are <em>multiple</em> examples on my page. (The other ones would also have the memory stored by others.)</p><p>In fact, when I implemented that, I realized variables are the <em>only</em> thing that need to have access to memory! So they get a reference to the current memory, and the other 99% of the program knows nothing about this.</p><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>Functions are also just variables, but with a <em>function</em> stored inside of them instead of a <em>value</em>.</p></aside><h3 id=blocks>Blocks</h3><p>The if-statement evaluates its conditional. If the answer is not <code>true</code>, it bails out. Otherwise, it goes through its statements and executes them.</p><p>The for-statement is an endless loop through its statements. If it finds a <code>stop</code>, it, well, stops.</p><p>This was tougher than I thought. How do we find this <code>stop</code> keyword nicely? How do we track it back to the loop it belongs to?</p><p>The &ldquo;simple&rdquo; alternative would be to keep track of this with a separate stack on the parser. Each time you start a loop, add it to the stack. Each time you find a stop keyword, it pops the last known loop off that stack.</p><p>But this means adding more and more variables <em>outside</em> of my nice functional structure. I want to at least <em>try</em> other approaches. So in the end, I stayed true to my course of &ldquo;functional programming&rdquo;.</p><p>When the <code>stop</code> keyword is found, that statement evaluates to a value of type &ldquo;stop&rdquo;. This bubbles up. Any block/statement that encapsulates this expression, will receive that value and pass it on. This means that it will, at some point, reach the node calling this loop. That checks for the keyword and abandons ship if found.</p><p>Yes, this means I finally decided what &ldquo;blocks&rdquo; should actually return! Before, they just returned an array with all their statements. (So each line just pushed its final value to that array. These were all concatenated until we had one huge array with the result for each line.)</p><p>Now it only returns the last (valid) result. However, I still save <em>each</em> result in a separate &ldquo;feedback&rdquo; array. Because this is extremely helpful information when debugging&mdash;both when I create this language, and when somebody else will eventually use it.</p><h3 id=functions-1>Functions</h3><p>These were harder to grasp. I had to think about it for a bit before I even knew how to <em>approach</em> it.</p><p>In the end, this was the recipe,</p><ul><li>Save the <strong>node</strong> in MEMORY.</li><li>That FunctionNode has a <code>params</code> variable.</li><li>When called, I first set the params to whatever was given.</li><li>And then I call <code>toResult</code> => this executes all statements within its block</li><li>Crucially, these statements now use the <em>params</em> object for variables. (Regular MEMORY isn&rsquo;t accessible to them.)</li><li>As this is just a JavaScript function, I can look for my keywords (<code>output</code> and <code>unplug</code>), and just return the value they have in their node.</li></ul><p>As expected, the reality was more complicated and riddle with rewrites.</p><p>Because it&rsquo;s not just functions &mldr; every block needs its own &ldquo;memory context&rdquo;. Variables defined inside it are only available there. (And variables defined outside a function aren&rsquo;t available inside it.)</p><p>So I needed to actually think more about memory than &ldquo;one big dictionary everything uses&rdquo;. Who would&rsquo;ve thought?</p><h3 id=proper-memory-management>Proper memory management</h3><p>This is how the final system works.</p><ul><li>When a Block is <em>initialized</em>, it checks its subtype. (Just an expression? If-statement? Loop?)</li><li>Most types create a new memory context. (Example: the body of an if-statement is a new context.) It pushes this onto the stack of memory contexts.</li><li>Then it evaluates what&rsquo;s inside, like usual.</li><li>But the variables and functions ask for the <em>latest memory context</em> (instead of just the big one from before)</li><li>The block is <em>done</em>? If it created a context, it &ldquo;pops&rdquo; the last one off the stack. (That should be their context, otherwise something went horribly wrong.)</li></ul><p>When defining a function, I can just give it a reference to the context created for its block. When you pass parameters to the function, it puts them into that dictionary.</p><p>This works! Although there are some details to figure out.</p><p>Now it only checks the latest context. But &mldr; as I said earlier, variables declared in a &ldquo;higher&rdquo; context should be available too. So I rewrote it to &mldr;</p><ul><li>Walk back from the latest context until the first one&mdash;the &ldquo;global&rdquo; memory.</li><li>It executes this for variables, but not for functions (they only have what you give them).</li><li>This meant I had to create a simple &ldquo;Memory&rdquo; class that also remembers what type of block <em>made</em> it.</li></ul><p>Secondly, I encountered my first name clash. Passing parameters uses &ldquo;and&rdquo; (<code>give a and b to function</code>) &mldr; just like conditionals (<code>if a and b</code>).</p><p>Dang it. I think it&rsquo;s the best word for both occasions. Thinking about it, I realized the booleans had to change. I&rsquo;m so used to programming that I actually made some assumptions here with which newcomers might struggle.</p><p>Namely, how &ldquo;logical AND&rdquo; and &ldquo;logical OR&rdquo; work. For me, <code>if a and b</code> is second nature and instantly means &ldquo;if both a and b are true&rdquo;. For people new to coding or logical statements? Not so much.</p><p>As such, the syntax for booleans changed.</p><ul><li>Logical AND: <code>if both a and b</code></li><li>Logical OR: <code>if either a or b</code></li></ul><p>I actually prefer it now. One of the crucial parts of programming is <em>naming</em> things well. This syntax kind of nudges you in that direction. Something like <code>if both userLoggedIn and passwordCorrect</code> is quite nice, if you ask me.</p><h3 id=lists--bags>Lists & Bags</h3><p>I left these for last &mldr; because I had no clue how to do them. Like before, the easiest syntax to parse (with lots of fixed symbols and operators) is also the one I didn&rsquo;t want to use.</p><p>But can we do something else? Does it exist? Or am I making this needlessly complicated?</p><p>How would a regular human being, with no experience coding, think about typing a list?</p><p>They&rsquo;d probably use bullet points, commas or just a white space. Is that something?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=ln>1</span><span class=cl><span class=nx>save</span> 
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=o>*</span> <span class=nx>a</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=o>*</span> <span class=nx>b</span>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=o>*</span> <span class=nx>c</span>
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=nx>into</span> <span class=nx>myListVariable</span></span></span></code></pre></div><p>Hmm, I don&rsquo;t know.</p><p>For a bag, they might want to use a word. Like <code>5 labeled KEY1</code> or <code>KEY1 unlocks 5</code>. I kinda like that. Although I&rsquo;m reconsidering the name &ldquo;bag&rdquo;, as the term &ldquo;label&rdquo; doesn&rsquo;t really fit with it.</p><p>I do notice a pattern here. Every sentence can be written in two ways: the two related values can be ordered 1,2 or 2,1. I guess this has become a <em>feature</em> of this language :p To make it a feature, I&rsquo;ll try to apply this to <em>everything</em> and keep the wording consistent.</p><p>@TODO: Specify, then implement</p><h2 id=performance>Performance</h2><p>Ah, the thing I&rsquo;ve been ignoring. As I neared &ldquo;completion&rdquo; on my language features, the slowdown became noticeable. Especially when you add subexpressions (through brackets; <code>(5+5)*3</code>), as it means it cycles through the whole chain of patterns multiple times, to evaluate stuff in the right order.</p><p>I wrote some testing functions for my parsers. That&rsquo;s always a nice thing&mdash;it showed me some corner cases I forgot to handle&mdash;but it also allows me to <em>time</em> every parsing function or expression.</p><p>And indeed, all of them were very fast, except for the subexpressions.</p><p>But &mldr; how to optimize? The code is already very short and efficient. It calls a lot of tiny functions, then bubbles upward with the value, and <em>that&rsquo;s it</em>. There are currently only <em>two</em> variables maintained outside of the function chain (block indentation and current memory context).</p><p>Like usual, I researched online until I discovered everyone else was doing things in a different way. They obviously knew what they were doing&mdash;I didn&rsquo;t :p</p><p>Here&rsquo;s the problem.</p><h3 id=silly-repetition>Silly repetition</h3><p>I input every individual option for a pattern <em>separately</em>. For example, a conditional can be &mldr;</p><ul><li>not Cond</li><li>both Expr and Cond</li><li>either Expr or Cond</li><li>Expr is Cond</li><li>Expr</li></ul><p>If the first fails, it starts over from the start and checks the second, then the third, and so forth until it fails or succeeds.</p><p>But &mldr; there&rsquo;s a lot of overlap here. We can bundle the overlapping options!</p><ul><li>not Cond</li><li>[both | either | nothing] Expr [and Cond | or Cond ]</li></ul><p>What&rsquo;s this? The &ldquo;not Cond&rdquo; is a bit special (it&rsquo;s a unary operator, which only has <em>one</em> input). Nothing to do about that.</p><p>But the others have now become a single search. A conditional &mldr;</p><ul><li>Starts with &ldquo;both&rdquo;, &ldquo;either&rdquo; or nothing</li><li>Followed by an expression (for sure)</li><li>Then optionally &ldquo;and&rdquo; + a condition, or &ldquo;or&rdquo; + a condition</li></ul><p>Instead of doing 5 individual searches, we only do the &ldquo;expensive&rdquo; search two times. And only when necessary.</p><p>Well, this was a bit of a pain to rewrite. Because it made the parsing chain a bit harder to understand. Let&rsquo;s hope it&rsquo;s worth it. (I&rsquo;ll benchmark that soon.)</p><h3 id=smart-order>Smart order</h3><p>A second optimization is to check the cheapest patterns first: the ones that almost instantly fail or succeed.</p><p>For example, <code>not Cond</code> fails quickly. Because if it doesn&rsquo;t find that exact word (<code>not</code>), it immediately stops and never even gets to that expensive Conditional evaluation!</p><p>The only pitfall is that some rearrangements break the correctness of the grammar. It would lead to the wrong results in certain occasions. I had to watch out for that. (You&rsquo;ll notice this immediately, because 99% of the crashes with a parser &mldr; are because you entered an infinite loop or exceeded the maximum call stack size :p)</p><p>Otherwise, the idea is just: the cheapest or most likely hits are checked <em>first</em>.</p><h3 id=simpler-grammar>Simpler grammar</h3><p>Until this moment, I basically stumbled around and threw everything against the wall. Now that I have (almost) everything in place, I can see what I actually need. I can see patterns. For example, because this language aims to emulate regular sentences, almost everything has one of the following patterns:</p><ul><li>Keyword Value</li><li>Keyword Value AnotherKeyword AnotherValue</li></ul><p>I decided to <em>fully</em> lean into that and make almost any pattern match that. With the rules above, it allows rewrites like the following.</p><p>Previously, the <code>Statement</code> pattern had ~10 different categories: <code>IfStatement</code>, <code>LoopStatement</code>, etc. These were checked separately, had their own nodes, etcetera. Additionally, things like <em>comments</em> used a symbol all this time (I picked <code>></code> based on &mldr; nothing, really). I can change that to the keyword <code>comment</code>.</p><p>All that brings the new grammar down to &mldr;</p><blockquote><p>Statement ::= (if | repeat | stop | &mldr;) expression [is | and | &mldr;] [ expression ]</p></blockquote><p>The first keyword and expression are required, the others optional. When matched, I check <em>what</em> it actually matched (e.g. &ldquo;if&rdquo; and &ldquo;is&rdquo;) and pick the right node for the tree based on that.</p><h2 id=did-it-do-anything>Did it do anything?</h2><h3 id=statements-before>Statements Before</h3><p>I benchmarked the speed <em>before</em> the change: 450-500 milliseconds on average. That&rsquo;s for <em>three simple statements</em>, namely</p><ul><li><code>(2+3)^2</code> => should be 25</li><li><code>(2+3)/(2+3)</code> => should be 1</li><li><code>(2-1/2)^(2-1)</code> => should be 1.5</li></ul><h3 id=functions-before>Functions Before</h3><p>It gets even worse if you combine it with functions. Five simple function statements took <em>15 seconds</em>. These are statements like ..</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=ln>1</span><span class=cl><span class=nx>machine</span> <span class=nx>A</span>
</span></span><span class=line><span class=ln>2</span><span class=cl> <span class=nx>say</span> <span class=mi>0</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=nx>use</span> <span class=nx>A</span></span></span></code></pre></div><p>Absolutely ridiculous, of course. I knew I had to be doing something exceptionally stupid somewhere.</p><p>But I also added an easy switch between &ldquo;only parse&rdquo; and &ldquo;parse + calculate result&rdquo;. This gave even more information</p><ul><li>If I only <em>parse</em> the function statements, they take &mldr; 0 milliseconds. They are expensive because of the <em>calculations</em> involved.</li><li>If I only <em>parse</em> the grouping statements, they take &mldr; 500 milliseconds still. They are expensive because of the <em>parsing</em>.</li></ul><p>As such, I expect these changes to solve the second issue (as parsing doesn&rsquo;t call a gazillion functions anymore). But I don&rsquo;t really know what&rsquo;s happening with the functions.</p><h3 id=statements-after>Statements After</h3><p>I did an intermediate benchmark to see if I was doing the right thing. Only after rewriting three of the definitions (Factor, Term and Expression), the results became &mldr;</p><ul><li>6 milliseconds for the grouping statements</li><li>8 milliseconds for the functions</li></ul><p>Yes! That looks like progress!</p><h3 id=too-many-functions>Too many functions</h3><p>It was at this point that I realized how stupid I was. Why my code was <em>so</em> slow.</p><p>I had <em>encapsulated</em> all the parsers &mldr; twice. Yeah, I don&rsquo;t want to talk about it. I did that when I still had no clue how this functional parsing actually worked.</p><p>This means that a single function call &mldr; was actually four function calls. Which means I was hitting the &ldquo;maximum call stack exceeded&rdquo; error <em>even when there was no mistake in my code</em>.</p><p>Because, remember, with function chains this number grows exponentially. One function becomes four functions, which calls another function to get 16 calls, which calls another to get 64 calls. Within 10-20 functions, you&rsquo;re already in a bad place (<code>4^20 = 1.1^12 = </code>a &ldquo;gigabyte&rdquo; of function calls).</p><p>I can show this mistake by referring to my simple examples earlier in this article. Maybe you already caught it when you read that.</p><p>This was my parser for a &ldquo;boolean&rdquo;.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=ln>1</span><span class=cl><span class=kr>const</span> <span class=nx>bool</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=nx>str</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>        <span class=k>return</span> <span class=nx>choice</span><span class=p>(</span><span class=nx>chars</span><span class=p>(</span><span class=s2>&#34;true&#34;</span><span class=p>),</span> <span class=nx>chars</span><span class=p>(</span><span class=err>&#34;</span><span class=kc>false</span><span class=p>))(</span><span class=nx>str</span><span class=p>);</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=p>}</span></span></span></code></pre></div><p>You see what I see? It &mldr;</p><ul><li>Returns a function (with no params)</li><li>Which is another function (with param string)</li><li>Which returns another parser (&ldquo;choice) &mldr; executed on string</li></ul><p>All we want is that final parser. Which is already a valid function from <code>(str) -> output</code>. Which means this function is just &mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=ln>1</span><span class=cl><span class=kr>const</span> <span class=nx>bool</span> <span class=o>=</span> <span class=nx>choice</span><span class=p>(</span><span class=nx>chars</span><span class=p>(</span><span class=s2>&#34;true&#34;</span><span class=p>),</span> <span class=nx>chars</span><span class=p>(</span><span class=err>&#34;</span><span class=kc>false</span><span class=p>));</span></span></span></code></pre></div><p>Apply this to a whole codebase (~1000 lines at this point) and performance skyrockets. (And the file get way shorter and easier to read.)</p><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>I also moved the parsing and highlighting to a separate thread (&ldquo;Web Worker&rdquo;). That needed to be done anyway, as it allows you to keep typing while it calculates results in the background. Even if it takes a while to calculate, you won&rsquo;t be interrupted or laggy.</p></aside><h3 id=delayed-evaluation>Delayed evaluation</h3><p><strong>However</strong>, there&rsquo;s one issue here. Some definitions are self-recursive. For example, this is an &ldquo;expression&rdquo;. If you remember, that checks for an optional <code>+</code> or <code>-</code> operation. (I&rsquo;ve left out some details in this example, such as the reducer functions that convert the output into an Expression node for the tree.)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=ln>1</span><span class=cl><span class=kr>const</span> <span class=nx>exprOperator</span> <span class=o>=</span> <span class=p>(</span><span class=nx>op</span><span class=p>,</span> <span class=nx>needsSpace</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>seq</span><span class=p>([</span><span class=nx>operator</span><span class=p>(</span><span class=nx>op</span><span class=p>,</span> <span class=nx>needsSpace</span><span class=p>),</span> <span class=nx>expression</span><span class=p>]);</span> <span class=p>}</span> <span class=c1>// operator expr
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>exprChoice</span> <span class=o>=</span> <span class=nx>choice</span><span class=p>([</span><span class=nx>exprOperator</span><span class=p>(</span><span class=s2>&#34;+&#34;</span><span class=p>,</span> <span class=kc>false</span><span class=p>),</span> <span class=nx>exprOperator</span><span class=p>(</span><span class=s2>&#34;-&#34;</span><span class=p>,</span> <span class=kc>false</span><span class=p>),</span> <span class=nx>nothing</span><span class=p>])</span> <span class=c1>// &#34;operator expr&#34; | nothing
</span></span></span><span class=line><span class=ln>3</span><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>expression</span> <span class=o>=</span> <span class=nx>seq</span><span class=p>([</span><span class=nx>term</span><span class=p>,</span> <span class=nx>exprChoice</span><span class=p>]);</span> <span class=c1>// term [operator expr | nothing]
</span></span></span></code></pre></div><p>Expression &mldr; relies on exprChoice &mldr; which relies on exprOperator &mldr; which relies on expression again!</p><p>Now that these are just <em>variables</em>, their value is determined once (on initialization). And when I define <code>exprOperator</code>, I haven&rsquo;t defined <code>expression</code> yet, so it saves <code>undefined</code>. Which leads to errors, obviously.</p><p>How do we solve this? I looked around some more, did some thinking, until it clicked for me. I introduce something I call &ldquo;delayed evaluation&rdquo;.</p><p>Those &ldquo;recursive&rdquo; variables can be <em>wrapped</em> inside a function. Just a simple, empty function: <code>() => someParser</code></p><p>When it&rsquo;s actually being <em>evaluated</em>, we check if the parser is inside such a wrapper, and <em>then</em> call that (to get the most recent result).</p><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>Apparently, if you call <code>.length</code> on a function, it tells you how many parameters it wants. This is how I can easily distinguish between a <em>wrapper</em> (without arguments) and a <em>parser</em> (which always requires exactly one argument, a string)</p></aside><h3 id=the-final-benchmark>The final benchmark</h3><p>Now let&rsquo;s check the speed once I finished optimizing the whole thing. It&rsquo;s still <em>far</em> from 100% optimized, because I didn&rsquo;t even touch the huge tree structure with many superfluous nodes.</p><p>But let&rsquo;s see the results.</p><ul><li>Expensive bracketed expressions: ~10 ms</li><li>Function statements: ~2 ms</li><li>Whole testing suite (about 50+ calls to all different function types): ~40 ms</li></ul><p>I&rsquo;m sad about bracketed expressions going up slightly (on average), but I&rsquo;ll figure that out. Otherwise, we&rsquo;re looking good. (These are inflated numbers. I have many tabs open, an extremely old laptop, and my tests print a few things to the console. I think we&rsquo;re fine for now.)</p><h2 id=lists--bags-1>Lists & Bags</h2><p>Where are we now? My language has &mldr;</p><ul><li>Data types / literals</li><li>Calculation / expressions using them</li><li>Variables</li><li>If-statements (albeit rudimentary)</li><li>Looping (albeit rudimentary)</li><li>Functions</li></ul><p>Which means I must finally provide an answer to the last remaining questions. Most importantly: <em>how to support arrays and objects</em>?</p><p>I already started writing my &ldquo;Coding for Beginners&rdquo; tutorial (using this language). This gave me the final insights.</p><h3 id=assignments>Assignments</h3><p>First of all, variable assignment now uses the syntax: <code>now NAME means VAL</code></p><p>Why?</p><ul><li>It&rsquo;s consistent with the rest. (Keyword, value, keyword, value.)</li><li>It reads like a sentence.</li><li>A sentence that says exactly what it does.</li><li>It emphasizes that you change/overwrite/calculate this value <em>now</em>&mdash;when the statement executes. And that you can only use it <em>after</em> this line.</li></ul><p>It was the best balance between all things considered. (How accessible, how verbose, how intuitive, how similar to the other syntax, &mldr;)</p><h3 id=the-final-bag>The final bag</h3><p>With that in place, I realized what to do with arrays and objects.</p><ul><li>It should, again, be like an English sentence.</li><li>I&rsquo;ve created this nice structure that turns code into &ldquo;blocks&rdquo; based on indentation. I can use this grouping &mldr; for <em>grouping</em>! (As in, collecting multiple values inside a list/object.)</li><li>It&rsquo;s probably best if I just <em>combine</em> the two. Fewer things to explain. Many languages do this anyway, explicitly or implicitly.</li></ul><p>This led to the following syntax.</p><p>To <strong>define</strong> a bag, write <code>bag NAME holds</code>, then start a new code block. (Indent the lines after it by one more space/tab.) In this new block, you can write as many expressions as you want!</p><p>By default, they&rsquo;ll be numbered (starting from 0). Like an array. But you can label them.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=ln>1</span><span class=cl><span class=nx>bag</span> <span class=nx>myBag</span> <span class=nx>holds</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>    <span class=nx>elem1</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>    <span class=nx>elem2</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>    <span class=nx>elem3</span> <span class=nx>as</span> <span class=nx>username</span>
</span></span><span class=line><span class=ln>5</span><span class=cl>    <span class=nx>elem4</span> <span class=nx>as</span> <span class=nx>password</span></span></span></code></pre></div><p>To <strong>get</strong> properties from them &mldr; use a possessive apostrophe :p It&rsquo;s a weird idea. I thought it would look &mldr; off. But I think it works for this language. The same is true for properties of the bag, like its size ( = length; number of elements).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=ln>1</span><span class=cl><span class=nx>now</span> <span class=p>(</span><span class=nx>myBag</span><span class=s1>&#39;s 0) means
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=s1>
</span></span></span><span class=line><span class=ln>3</span><span class=cl><span class=s1>if myBag&#39;</span><span class=nx>s</span> <span class=nx>size</span> <span class=nx>is</span> <span class=mi>10</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>    <span class=nx>say</span> <span class=nx>myBag</span><span class=err>&#39;</span><span class=nx>s</span> <span class=nx>username</span></span></span></code></pre></div><h3 id=how-to-implement-that>How to implement that?</h3><p>A <em>bag</em> is just a small class in my JavaScript. It&rsquo;s not a (literal) &ldquo;value&rdquo; on its own; it&rsquo;s a <em>collection</em> of values.</p><p>For the definition, my code searches the pattern <code>bag </code>+ <code>&lt;varchars> </code>+ <code>holds</code>.</p><p>It turns this into a &ldquo;BagStatement&rdquo;. As it parses the lines within, it saves their results inside the created bag.</p><ul><li><code>&lt;expression></code> + <code>as</code> + <code>&lt;varchars></code> saves the value (first part) at the given key (second part)</li><li><code>&lt;expression></code> calculates the current size of the bag and adds this at the next index</li></ul><p>Before, checking if something was a variable had only <em>one</em> option. (Any string of varchars: valid characters in a variable.) Now we have two.</p><ul><li><code>&lt;varchars></code> + <code>'s</code> + <code>&lt;spaces></code> + <code>&lt;varchars></code></li><li><code>&lt;varchars></code></li></ul><p>If it finds the first, it knows it&rsquo;s dealing with a Bag. It takes its value out of memory (the first name), then accesses that object&rsquo;s key (the second name).</p><p>Note that everything in memory (in my system) is a &ldquo;Value&rdquo; object. This means we can read <em>and</em> write to bags using this system. Because we retrieve a <em>reference</em> to the Value at that key. If we change its value/type, we&rsquo;ve just updated that specific key for free!</p><h2 id=the-final-stretch>The final stretch</h2><p>As I finished my &ldquo;Learn to Code&rdquo; (or &ldquo;Coding for Beginners&rdquo;) course, I also honed in on the last details of my language. (Because I needed those features for the examples, and I needed them to work.)</p><p>As always, <strong>things changed</strong>.</p><p>I did not like the <code>as</code> syntax for named elements in a bag. <em>All</em> parts of Bamboo, thus far, used this order:</p><ul><li>First the <em>name</em></li><li>Then the <em>value</em> (which you put into it)</li></ul><p>It would be a crime to suddenly switch it around just for this thing. (First the value, then &ldquo;as&rdquo;, then the name.)</p><p>Also, I forgot one crucial part of working with arrays: <em>adding and removing elements</em>.</p><p>This led to the realization: &ldquo;why invent new syntax? I already have nice syntax for assigning values to names: variables. Let&rsquo;s reuse that.&rdquo;</p><p>As such,</p><ul><li>Named values (in a bag) used the syntax: <code>NAME means VALUE</code>.</li><li>To add an element, use <code>add VALUE to BAG</code></li><li>To add a named element, use <code>add (NAME means VALUE) to bag</code></li><li>To remove an element, use <code>take out of BAG</code></li><li>To remove a named element, use <code>take NAME out of BAG</code></li></ul><p>Yes, this means adding/removing uses the last element by default. And no, I did not provide alternative syntax for adding/removing at some other index. That would make the language more complicated. And I&rsquo;ve realized the past few years that I barely use such a feature anyway. Almost 100% of code working with arrays only adds/removes at the end (<code>push</code> and <code>pop</code>).</p><p>Also, notice how I still try to keep my structure of &ldquo;keyword value (keyword value)&rdquo;. I purposely chose phrases that would allow me to stay consistent.</p><ul><li>Anything you want to do in Bamboo, will either use 2 words, 4 words or 6 words (rare)</li><li>Most of the time, the syntax alternates between a <em>keyword</em> and a <em>value</em></li></ul><p>This seems nice and coherent to me.</p><h3 id=implementing-bags>Implementing bags</h3><p>This is a bit messy. But it&rsquo;s fine for what Bamboo tries to be.</p><p>I actually <strong>did</strong> decide to make Bags their own data type. In other words, every expression in Bamboo either &mldr;</p><ul><li>Resolves to a <strong>Value</strong> (boolean, number, string)</li><li>Or to a <strong>Bag</strong> (list of Values)</li></ul><p>I decided to do this after two or three rewrites of the Bag system, none of which worked.</p><p>The disadvantage? Crucial code needs to <em>check</em> if they&rsquo;re working with a Value or a Bag.</p><p>The advantage? Everything else. Once I had defined operations for both (such as &ldquo;what if we multiply a Bag with a single number?&rdquo;), all the other code could stay almost entirely the same. It doesn&rsquo;t care which of the two it&rsquo;s working with, and every operation is defined for <em>both</em></p><p>The <code>Bag</code> object handles a <em>lot</em> behind the scenes. At first, this wasn&rsquo;t the case. I just gave it an empty object (<code>{}</code>) and stored new values inside it. If you didn&rsquo;t give a name/key, it just used array indices (0, 1, 2, &mldr;) as the keys.</p><p>This soon ran into trouble, though. There&rsquo;s a <em>reason</em> languages make a distinction between arrays (&ldquo;numbered lists&rdquo;) and objects (&ldquo;named lists&rdquo;). At their core, they have very different strengths and weaknesses. Trying to combine both into one thing just meant that code was inconsistent and messy.</p><p>Now, the bag can <em>either</em> hold an object or an array. When you ask something of it, it checks its type and calls the correct function. (Are we an array? Use simple array indexing. Are we an object? Grab the given key.)</p><p>This might change in the future. As I said, this is my first time implementing something like this, and it&rsquo;s not as clean as I&rsquo;d like.</p><p>But for now, this is fine.</p><h3 id=resolving-keys>Resolving keys</h3><p>This is another part that I underestimated. At first, the parser just checked for anything that would be a valid variable name (alphanumeric characters, no spaces).</p><p>But &mldr; what if it&rsquo;s <em>actually</em> a variable? It needs to grab the <em>value</em> stored inside it, instead of using its name as a key.</p><p>But &mldr; what if it&rsquo;s a key name wrapped in strings? Like <code>BAG's "keyname"</code>? I&rsquo;d also like to support that. It feels so intuitive that I accidentally used that syntax in some of my own examples!</p><p>The possibilities for what could be a key grew and grew. Until I finally decided to just stop doing that and write a smart function to decipher <em>anything</em> you throw at it.</p><p>Now, when it encounters a possessive statement (<code>BAG's KEY</code>), it &mldr;</p><ul><li>Checks if it&rsquo;s a reserved keyword (like <code>size</code>).</li><li>Checks if the KEY might be a variable.</li><li>It requests its value. If it exists, return that, and we&rsquo;re done.</li><li>If not, use the variable <em>name</em> as a string.</li><li>If all fails, return an error saying we can&rsquo;t access that key</li></ul><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>This is still simplified, of course. But it&rsquo;s the general idea.</p></aside><h3 id=adding-built-in-functions>Adding built-in functions</h3><p>This was (relatively speaking) the easiest part. I wanted to support useful functions out of the box. Things like &mldr;</p><ul><li>Round / floor / ceil a number</li><li>Absolute value</li><li>String replace or slice</li><li>Random numbers</li><li>Get current time/date</li><li>Get current iterator in a loop</li><li>Etcetera</li></ul><p>Any functions that needed another value were simply baked in. For example, you can type <code>round VALUE</code> anywhere, and it will return the rounded value.</p><p>Functions that needed no input were assigned to a global <code>bamboo</code> object. It &mldr;</p><ul><li>Felt appropriate. To <em>collect</em> all those helper functions under one syntax or one name.</li><li>Prevented me from having to disallow even <em>more</em> common English words, because they are reserved.</li></ul><p>For example, you can type <code>bamboo iterator</code> inside a loop, and it will give you the current iteration (number).</p><p>These are just a few more parsers on top of the existing ones. Ones that check the given keyword and any value behind it.</p><h2 id=syntax-highlighting>Syntax Highlighting</h2><p>Oh boy, the struggle continued. I tried, and tried, and tried to make my current approach work.</p><ul><li>A <code>contenteditable</code> div</li><li>When changed ( = given new input), it extracts the contents as plain text</li><li>And saves where the mouse cursor currently is</li><li>Sends that to the parser</li><li>Receives the highlighted HTML; that becomes the new content (<code>innerHTML</code>) of the div</li><li>And resets the mouse cursor to where it was before</li></ul><p>This was both great and problematic to the extent that I had to give up on it.</p><p>Great because it means all the highlighting and editing happened in one place. So 95% of the time, things worked flawlessly without effort on my part.</p><p>But a few crucial things were broken to an extent that simply <em>could not be repaired</em></p><ul><li>Pressing TAB or ENTER would move your mouse cursor to the start/end of the file</li><li>If you did anything slightly weird (pressed Enter from inside a word, for example), it might just decide to remove half your code and move the mouse cursor somewhere else again</li><li>When I wanted to add line numbers (and more complex styling), everything broke</li></ul><p>After pulling my hair out in frustration, I switched to the alternative I&rsquo;d researched at the start.</p><ul><li>A regular textarea.</li><li>Made <em>invisible</em> and placed on top of a regular div.</li><li>The textarea actually receives your input and sends it to the parser</li><li>The div only <em>displays</em> the highlighted result (but isn&rsquo;t editable or interactive in any way)</li></ul><p>Because input happens with a textarea, everything is taken care of. Tab, Enter, newlines, spacing, it&rsquo;s all supported by default. Most importantly, the mouse cursor will stay where it is, because no magical &ldquo;substitution&rdquo; is happening in the textarea.</p><p>Instead, a few milliseconds after typing, the highlighted result simply appears below it inside the div.</p><p>The trick is, of course, to make the two elements <strong>match perfectly</strong>. Placing, font size, cursor, etcetera. To keep the illusion that it&rsquo;s one thing.</p><p>This was very tricky. When coding my website (and the original styles for the Bamboo highlighter), I had <em>never</em> thought I&rsquo;d be doing something like this. So over the span of a few hours, I kept uncovering more hidden rules that we making my textarea <em>slightly different</em> than my div.</p><p>(Like, 10% difference in line height, or 2px extra padding somewhere. Once you have 5+ lines of code, these tiny differences throw the textarea and the div completely out of sync. Breaking the whole system.)</p><p>Additionally, textareas don&rsquo;t match the size of your input by default. They have a fixed height (but can be resized manually by the user). Therefore, when <em>any</em> change happens, it syncs the width and height of the div and textarea.</p><p>Once that was sorted, though, this worked <em>flawlessly</em>.</p><p>Now I could finally type inside my code examples <em>without</em> worrying any change might destroy everything :p</p><p><figure class=inline-image><picture><img src=pq_bamboo-header.webp loading=lazy decoding=async alt="Example of syntax highlighted block" title="Example of syntax highlighted block" width=1560 height=521></picture><figcaption class=side-note><span>Example of syntax highlighted block</span></figcaption></figure></p><h2 id=conclusion>Conclusion</h2><p>Pfew, what a project. I learned a lot, failed a lot, rewrote most code three times.</p><p>And it&rsquo;s still not done. There are features missing. There are edge cases. The error reporting is abysmal and at some point I stopped writing unit tests.</p><p>But I&rsquo;ve written my programming tutorials and all my examples work. I&rsquo;m confident the language is solid enough to show to the world.</p><p>What have I learned?</p><ul><li>Functional parsing is great and leads to clean code.</li><li>But some things must be done non-functionally. Having outside information (such as memory, context, a loop or indentation level) is crucial.</li><li>The feature I missed the most was a <em>lookahead</em> or <em>peek</em>. A way to look into the future <em>without</em> consuming those symbols.</li><li>The general grammar that allows you to build a full programming language.</li><li>How to implement things under the hood.<ul><li>You don&rsquo;t want to store raw values; you want to store them as Objects that also contain other metadata. (Such as the type.)</li><li>Start with code that neatly finds your <em>blocks</em> and individual <em>statements</em>. Don&rsquo;t do what I did and only realize you need that halfway through.</li><li>Whitespace and newlines are <em>stupid</em>. Also start by handling those properly and cleanly.</li><li>Handle Arrays, Objects and raw Literals as different things. Don&rsquo;t try to combine them all into one master object.</li><li>If done right, most operations that code does are extremely obvious. They are just one or two calls to a well-known, basic JavaScript function.</li></ul></li></ul><p>I&rsquo;m also surprised at how many things I did right the first time. For example, creating the syntax highlighting <em>and</em> executing the code barely needed any changing after my first try. Every object has a <code>toString</code> and <code>toResult</code> function that does one simple thing.</p><ul><li>It calls the same function on its children</li><li>It potentially changes some of it. (For example, an <em>operator</em> would combine the two <em>results</em> it gets from its children.)</li><li>Then returns that out of the function (to whomever called it)</li></ul><p>In the future, I&rsquo;d like to</p><ul><li>Use two steps: first tokenize the input, then create a tree from that.</li><li>Prevent creating a ludicrous amount of nodes. (Both for the tree and the syntax highlighting.)</li><li>Perhaps write it in a more performant language, and rethink some of the syntax, so Bamboo could <em>actually</em> do some damage.</li><li>But if I do that, I&rsquo;d need to give it real-world uses too. Like an &ldquo;update&rdquo; loop for games. Or a way to draw simple graphics to the screen.</li></ul><p>Doing all things at once (read string, syntax highlight, build tree) is what leads to a lot of waste or extra code. If we only wanted to parse the input, we&rsquo;d just throw away all the white space and forget about delimiters (once we&rsquo;ve created the tokens). But we also want to highlight, so we need to <em>remember</em> every single symbol somewhere nice.</p><p>This means that the final (executed) tree will often have nodes that are just &mldr; a lot of whitespace, saved inside even more nodes.</p><p>Anyway, that&rsquo;s pretty much the whole journey from &ldquo;hey wouldn&rsquo;t it be cool to create a tiny example language?&rdquo; to &ldquo;hey this is a pretty full-fledged language that you can play with in your browser&rdquo;.</p><p>Below is the final image of the grammar (as it stands now, March 2023) of Bamboo.</p><p><figure class=inline-image><picture><img src=bamboo_grammar.webp loading=lazy decoding=async alt="Overview of (almost) full Bamboo grammar" title="Overview of (almost) full Bamboo grammar" width=1471 height=1635></picture><figcaption class=side-note><span>Overview of (almost) full Bamboo grammar</span></figcaption></figure></p></div></article><div><nav class=pagination><ul><li><a href=/blog/news-and-updates/2024/how-i-invented-interactive-rulebooks/ class="masked-link big-mask mask-8" style=--rotation:0deg>&lt;&lt; Previous Page</a></li><li>Continue reading</li><li><a href=/blog/news-and-updates/2023/bamboo-docs/ class="masked-link big-mask mask-1" style=--rotation:2deg>>> Next Page</a></li></ul></nav></div></main><footer id=site-footer><div class="padding center-block"><h3>More Pandaqi</h3><p>You could <a href=https://pandaqi.com>visit the game studio</a>.
Or my <a href=https://pandaqi.com/tutorials/>free tutorial website</a>.
Or my <a href=https://rodepanda.com/>portfolio</a> with easy access to absolutely everything I ever made.</p><h3>Latest</h3><nav class=latest><ul><li><a href=/blog/boardgames/the-game-of-dilemmas/>The Game of Dilemmas
(ü§®)</a></li><li><a href=/blog/boardgames/the-game-of-happiness/>The Game of Happiness
(üåà)</a></li><li><a href=/blog/boardgames/firecrackers/>Firecrackers
(üéÜ)</a></li><li><a href=/blog/boardgames/sleighwell/>Sleighwell
(üéÑ)</a></li><li><a href=/blog/reviews-and-thoughts/the-two-crucial-components-of-a-game/>The Two Crucial Components of Any Game
(üí¨)</a></li><li><a href=/blog/news-and-updates/2024/lets-talk-about-throneless-games/>Let's Talk About: Throneless Games
(üëë)</a></li><li><a href=/blog/boardgames/mountain-miners/>Mountain Miners
(‚õèÔ∏è)</a></li><li><a href=/blog/boardgames/throneless-games/queenseat/>Queenseat
(üëë)</a></li><li><a href=/blog/boardgames/throneless-games/smallseat/>Smallseat
(üëë)</a></li><li><a href=/blog/news-and-updates/2024/pandaqi-games-2024-update-iv/>Pandaqi Games: 2024 Update IV
(üéÆ)</a></li></ul></nav><h3>Sections</h3><nav><ul><li><a href=/blog/boardgames/>Boardgames
(üé≤)</a></li><li><a href=/blog/news-and-updates/>News & Updates
(üì¢)</a></li><li><a href=/blog/reviews-and-thoughts/>Reviews & Thoughts
(üí≠)</a></li><li><a href=/blog/tutorials/>Tutorials
(üë©‚Äçüéì)</a></li><li><a href=/blog/videogames/>Videogames
(üéÆ)</a></li></ul></nav><h3>Credits</h3><p>Theme by me (<a href=https://pandaqi.com>Pandaqi</a> üêº) &#183;
with ‚ù§Ô∏è &#183;
using <a href=https://gohugo.io>Hugo</a> &#183;
&copy; 2018&ndash;2024 Pandaqi Blog</p></div></footer><link rel=stylesheet type=text/css href=/blog/css/style.css><script src=/blog/js/main.bundle.min.js async defer></script></body></html>