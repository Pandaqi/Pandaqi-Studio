<!doctype html><html lang=en-US><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Pandaqi Games: 2025 Update II | Pandaqi Blog</title><link rel=icon type=image/png href=https://pandaqi.com/blog//favicon.png><link rel=stylesheet type=text/css href=/blog/css/critical.min.css></head><body><header id=site-header><nav class=menu><ul><li><a href=https://pandaqi.com/blog/ class="masked-link big-mask mask-2" style=--rotation:1.5deg>Home</a></li><li><a href=/blog/boardgames/ class="masked-link big-mask mask-7" style=--rotation:0deg>Boardgames</a></li><li><a href=/blog/news-and-updates/ class="masked-link big-mask mask-3" style=--rotation:-1deg>News & Updates</a></li><li><a href=/blog/reviews-and-thoughts/ class="masked-link big-mask mask-2" style=--rotation:2deg>Reviews & Thoughts</a></li><li><a href=/blog/tutorials/ class="masked-link big-mask mask-7" style=--rotation:1deg>Tutorials</a></li><li><a href=/blog/videogames/ class="masked-link big-mask mask-4" style=--rotation:1deg>Videogames</a></li></ul></nav></header><main class="padding center-block"><article class=single-article><h1>Pandaqi Games: 2025 Update II</h1><aside class=metadata><nav class=breadcrumbs><span class=metadata-label><span class=emoji>ü•ê</span> Breadcrumbs ||</span>
<a href=https://pandaqi.com/blog/>Home</a>
/
<a href=/blog/>Blog</a>
/
<a href=/blog/news-and-updates/>News and updates</a>
/
<a href=/blog/news-and-updates/2025/>2025th</a>
/
<a href=/blog/news-and-updates/2025/pandaqi-games-update-ii/>Pandaqi games update ii</a></nav><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/pandaqi.com\/blog\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"\/blog\/","name":"blog"}},{"@type":"ListItem","position":4,"item":{"@id":"\/blog\/news-and-updates\/","name":"news-and-updates"}},{"@type":"ListItem","position":5,"item":{"@id":"\/blog\/news-and-updates\/2025\/","name":"2025"}},{"@type":"ListItem","position":6,"item":{"@id":"\/blog\/news-and-updates\/2025\/pandaqi-games-update-ii\/","name":"pandaqi-games-update-ii"}}]}</script><div><span class=metadata-label><span class=emoji>&#8987;</span> Published ||</span>
<time datetime=2025-03-03T00:00:00>Monday, Mar 3, 2025</time></div><div><span class=metadata-label><span class=emoji>üìñ</span> Table of Contents ||</span>
<a href=# id=toc-toggle>Show</a></div></aside><aside id=table-of-contents class=masked-link-block><header><h2>Table of Contents</h2></header><nav id=TableOfContents><ul><li><a href=#html-drawing>HTML Drawing</a></li><li><a href=#a-special-case-the-pirate-games>A special case: the Pirate Games</a></li><li><a href=#the-generation---visualizer-combo>The Generation -> Visualizer Combo</a></li><li><a href=#stupid-naming-conventions>Stupid naming conventions</a></li><li><a href=#performance>Performance?</a><ul><li><a href=#what-was-not-the-issue>What was NOT the issue</a></li><li><a href=#improvement-1-cache-single-frames-again-for-re-use>Improvement #1: Cache single frames again for re-use</a></li><li><a href=#improvement-2-dont-stroke-and-fill--if-we-have-none>Improvement #2: Don&rsquo;t stroke and fill &mldr; if we have none</a></li><li><a href=#improvement-3-no-temporary-canvases-when-not-needed>Improvement #3: No temporary canvases when not needed</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></aside><div><p>This article explains the second major update I implemented for my Pandaqi Games website. (I usually end up having multiple such articles per year, as I slowly fix bugs, make the website more user friendly, etcetera.)</p><p>What has changed?</p><ul><li>I removed all code for an experimental drawing system that I ended up not liking (and thus not using that much) in the end.</li><li>I moved most of my older games to my new code and design structure.</li><li>@TODO: More??</li></ul><p>Below I&rsquo;ll explain each step in a bit more detail.</p><h2 id=html-drawing>HTML Drawing</h2><p>When I just started generating board games on my website, I considered using <em>website code</em> for it. What does that mean?</p><p>Websites have a very simple but powerful structure to <em>style webpages</em> (HTML + CSS). HTML is used to mark the <em>content</em> (such as &ldquo;this is a paragraph with this text&rdquo;), CSS is used to mark <em>how it should render</em> (such as &ldquo;this text should be black and centered&rdquo;). This is supported everywhere, and I am very experienced creating designs with those systems.</p><p>So I thought: why don&rsquo;t I just design every game of mine as a <em>website</em>, and then simply convert that to an image/PDF at the end?</p><p>For example, a &ldquo;card&rdquo; for a card game would just be its own tiny webpage. A One Paper Game would be one large webpage.</p><p>So I implemented this system. It used the exact same code as my other drawing system (using HTML Canvas), but in the end I simply call a different function on it: <code>toHTML</code> instead of <code>toCanvas</code>.</p><p>Every element of my website (an image, a text block, a rectangle, &mldr;) could easily be drawn in one of those systems. I could leverage the power of CSS to automatically align stuff, resize stuff, recolor stuff, etcetera for &ldquo;free&rdquo;.</p><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>To actually convert that webpage to a single image/canvas, I used one of the many libraries for that (<code>modern-screenshot</code>). They use a common trick supported by all browsers, which is interesting but too long to explain here. Look it up if you want.</p></aside><p>It was rather neat and I was proud of making it.</p><p>So why is it gone? (Of course, I&rsquo;ve backed up all that work, but it&rsquo;s essentially 100% unused and unsupported, and will likely not return.)</p><ul><li>I noticed that, in practice, it was <strong>not faster or easier</strong> to use this system as opposed to just setting the properties of elements directly. After a few games, I stopped using it because it had no clear benefit for <em>most</em> projects.</li><li>I had to make a few <strong>concessions</strong> when I made this &ldquo;HTML renderer&rdquo;. Most were fine, but one of them led to having tons of extra files, classes and helper objects &mldr; which I just didn&rsquo;t want to maintain.</li><li>The largest benefits of this system were <strong>containers</strong> and <strong>rich text rendering</strong>. When I made it, I couldn&rsquo;t do that using my own system.<ul><li>When I made this system, I didn&rsquo;t have my <code>ResourceGroup</code> class yet, which can <em>contain other stuff</em>.</li><li>Similarly, back then I had no <code>TextDrawer</code> yet that could draw text in many advanced ways (<strong>bold</strong>, <em>italic</em>, colored, images inline, etcetera).</li><li>But now I can! In fact, the website supports two renderers (Pandaqi and Pixi.js) that can both do this easily.</li></ul></li></ul><p>In short, it bloated the system and made the games that used it hard to maintain, without any tangible benefit anymore.</p><p>Which games used it?</p><ul><li><em>Creature Quellector</em> => HEAVILY used it, as this was my &ldquo;test project&rdquo; for the system.</li><li><em>Cookie Smasher</em> => used it moderately, mostly for the rich text features.</li><li><em>Nine Lives: Math Meows</em> => only used it for the single text block on cards</li><li><em>Pumpkin Patrol</em> => used it for rendering a centered list of elements of varying width (some were icons, some text); took me a few more minutes to replace, but not too terrible.</li></ul><p>After an hour or two, I was able to replace that code and clean it up. And then the entire HTMLRenderer system could be removed.</p><p>Because this renderer was coded badly and loaded that entire library (<code>modern-screenshot</code>), this change actually made <em>all scripts</em> on the entire website significantly smaller. My final reason to remove this.</p><p><em>Will it ever return?</em> There might come a day when I truly need this, because a webpage=>image process will be so much easier for a project than canvas=>image. If that happens, I will bring back the code using my new renderer system, which allows renderers to be <em>completely standalone</em> or <em>decoupled</em>. That would be a significant rewrite, but nothing too major. Because as I said: the original code is quite good and worked.</p><p>I doubt it, however. In over 100 games, I only used the system 4 times, and only <em>heavily used it</em> once.</p><p>This does mean, however, that those 4 games might have some bugs now. I obviously tested if they still work, but I can&rsquo;t test <em>all</em> random generations and settings permutations, so some stuff might be missing or in the wrong place. Let me know if it is!</p><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>This is also why I&rsquo;m happy I started creating &ldquo;premade&rdquo; PDFs for all games, always. Even if the generation code breaks down, people can always just click Download and get a valid PDF from the Google Drive.</p></aside><h2 id=a-special-case-the-pirate-games>A special case: the Pirate Games</h2><p>I made two games during a period when I really wasn&rsquo;t feeling it, and the website wasn&rsquo;t really maintained in any other way, which I dubbed the Pirate Games (<em>Pirate Riddlebeard</em> and <em>Pirate Drawingbeard</em>).</p><p>Unsurprisingly, these are <em>completely</em> detached from all other systems, and their code is a mess.</p><ul><li>They were the only games still using the Phaser framework.</li><li>They had lots of inefficient code creating images again and again, and simply stupid ways to connect the different systems that it needed.</li><li>They didn&rsquo;t <em>fully</em> use my rendering system&mdash;drawing a few things in a custom/raw way to a canvas&mdash;which is always just a source for future problems.</li></ul><p>Or, they <em>were</em> detached, until I finally fixed them with this update!</p><p>It was a bit painful, but I ripped out Phaser and replaced it with just a plain canvas. Then I rewrote the code to be much cleaner, asynchronous, and use my standardized system for declaring everything to be drawn.</p><p>The result is that the <em>script</em> file for both games was reduced in size by ~75%. The other result is that the game itself loads + draws way faster. And your browser doesn&rsquo;t &ldquo;hang&rdquo; when it can&rsquo;t find a solution for a few seconds.</p><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>These games randomly generate a &ldquo;puzzle&rdquo; to find a hidden treasure. Because of the random generation, it might fail to find a valid puzzle the first 100 tries, which is why it <em>can</em> take a while. In practice, though, the game now boots in only a second or so.</p></aside><p>At the time, I wrote down some more ideas for Pirate Games (or &ldquo;randomly generated puzzle One Paper Games&rdquo;, I guess). Those are still quite strong, so there&rsquo;s actually a chance now that I will continue this series and give it more entries.</p><p>Moving the existing games to the modern setup&mdash;the final ones to do so&mdash;was simply the first step on that journey.</p><h2 id=the-generation---visualizer-combo>The Generation -> Visualizer Combo</h2><p>A while ago, I landed on this system for my material generation.</p><ul><li>Every game simply calls the <code>MaterialGenerator</code> and gives its configuration.</li><li>That generator does all the necessary setup automatically</li><li>Then it creates a <code>MaterialVisualizer</code> object => this is the <em>only thing</em> passed into objects so they can draw themselves as needed.</li><li>And when done, it does all the necessary finishing and wrapping up (such as creating the PDF) automatically</li></ul><p>It&rsquo;s a really clean system that has simplified all the code for the last 50 games. It&rsquo;s fast, it&rsquo;s clean, I barely run into issues where I&rsquo;m confused why it does something (or not).</p><p>So I decided to use it for <em>all</em> the games, including those One Paper Games that only generate a single paper.</p><p>After some fiddling around, I managed to make it work in exactly the same way, but with some crucial differences for the One Paper Games.</p><aside class="example masked-link-block"><span class=label>Example ||</span><p>It has a setting to &ldquo;split the board&rdquo;: it cuts 1 A4 into 2x2 or 3x3, which is very useful for more complex games to get a playing board that&rsquo;s actually the size of a regular playing board.</p></aside><p>I rewrote all the old stuff to accept a <code>MaterialVisualizer</code> as input and need only that to draw themselves. This was quite a lot of work. Thanks to the typechecking system and my experience with this, however, there was never really any change of bugs or conversions failing. Once the typechecker tells me there are no more errors, I am pretty certain the older game will work exactly as it did before.</p><p>In doing so, I did encounter a few bugs in those older games <em>and</em> a few missing features in my visualizer.</p><aside class="example masked-link-block"><span class=label>Example ||</span><p>The visualizer <em>expected</em> you to have a <code>debug</code> property in your config. Simply because that&rsquo;s what all my new games have, so I never even considered that it might receive a configuration without debug options. So it crashed when that happened :p Stuff like that is easy to fix&mdash;simply provide a default <code>{}</code> object if no debug is set&mdash;but you still have to find the error at some point.</p></aside><aside class="example masked-link-block"><span class=label>Example ||</span><p>My Wondering Witches game has the setting to generate a double-sided board: 2 papers, instead of the usual 1 paper (for a One Paper Game :p) After converting the game, I tested it &mldr; and the second paper was mostly blank. Huh? It worked before, right? Or DID it work before?</p><p>As it turns out, I completely forgot to &ldquo;reset&rdquo; the cells of the map before doing the second drawing. As such, when trying to generate the backside, the system was like &ldquo;all these cells already belong to a garden and are done! Don&rsquo;t draw them anymore!&rdquo; An easy fix&mdash;three lines of code to loop through the paper and reset it all&mdash;but only found because of this.</p></aside><p>This combination has a secondary advantage too. It means all the drawing is now <em>stateless</em>. What does that mean?</p><ul><li>Before, many of my older games would set and read all sorts of properties on the card/paper they were drawing. They would draw commands <em>instantly</em> to the canvas too.</li><li>This means that I can never draw these things repeatedly or asynchronously, however, because <em>drawing</em> has <em>side-effects</em>. The second time I draw a card, it might have different properties!</li><li>This is just a breeding ground for all sorts of nasty issues and limitations.</li><li>Instead, now everything visualizes/draws itself without any side effects, because the <code>MaterialVisualizer</code> determines exactly how stuff is drawn, and anything else is a local variable within the function that isn&rsquo;t saved.</li></ul><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>This does mean that some older games get a LOT of parameters put into functions, like <code>drawSidebar(visualizer, group, a, b, c, d, something else)</code>. As opposed to just saving all those values with <code>this.a = val</code> and then reading them later. But that&rsquo;s fine. The maximum parameters is a mere 5, and that&rsquo;s in one of my oldest One Paper Games that does some VERY complicated drawing stuff.</p></aside><p>Taking a step back, I can see that the entire journey towards this system learned me a few really good coding practices. When I made a tiny video game a few weeks ago, I noticed how the quality of my code had <em>massively improved</em>. Simply because I&rsquo;ve been burned by having side-effects, by having things too tightly coupled, by having to do maintenance on old code that was written with a very loosey-goosey mindset.</p><p>Now I know that, in most cases, you want <strong>dependency injection</strong>, where the dependency is a class that <strong>does a specific thing</strong>.</p><ul><li>Every <code>.draw</code> function has the dependency &ldquo;MaterialVisualizer&rdquo; injected into it.</li><li>As the name states, that object <em>does</em> the actual visualization. The material itself just prepares the right properties, resources, commands, etcetera and then <em>hands it to the visualizer</em>.</li><li>Because the visualizer is responsible for all drawing, I need no other inputs or dependencies, just this one.</li><li>And because the material itself knows <em>nothing</em> about rendering or drawing, the most expensive part of the code (such as the entire PIXI Renderer) is only loaded <em>if the MaterialVisualizer needs it</em>. If I use a different renderer, only <em>that</em> code is included in the JavaScript bundle.</li></ul><p>In a video game, for example, this would be something like.</p><ul><li>You have a <code>Map</code> class that generates a random world map (with countries, rivers, terrain, whatever).</li><li>But &ldquo;generating countries&rdquo; is a <em>different action</em> than &ldquo;generating rivers&rdquo;.</li><li>In other words, all these different elements of the map should be their own class that&rsquo;s injected into this main function: <code>MapCountries</code>, <code>MapRivers</code>, etcetera.</li><li>Moreover, these classes are only responsible for <em>generating</em> the data and the numbers. If we actually want to draw the map, we&rsquo;d introduce a different <code>MapDrawer</code> for example.</li><li>This means that everything is clean and decoupled, that everything only has one purpose and does one thing well, but you can combine them (or not) any way you want by simply including the dependency.</li></ul><p>Anyway, this conversion was <em>relatively</em> quick because I&rsquo;d already standardized my own drawing language way back. Every game, with only two exceptions, already uses the same names for everything, the same resources, the same <code>LayoutOperation</code> to draw stuff.</p><p>It&rsquo;s just that, before, they were doing it <em>directly</em>. That&rsquo;s the power of my system. You can group and batch stuff and draw the whole thing at once later &mldr; or you can just draw <em>one thing</em> immediately to a canvas, if you want. It&rsquo;s all the same thing, just a different function called at the end of it.</p><p>Or &mldr; well &mldr; it <em>should</em> be the same thing, but there was one little stupid decision I&rsquo;d made about how to name certain things.</p><h2 id=stupid-naming-conventions>Stupid naming conventions</h2><p>Okay, so, remember that HTML Layout system I talked about at the start? It was completely flexible. You could use that system for a few elements of your game, but my regular (canvas) renderer for others. They were interchangeable, they could weave together however you wanted, and they all used the exact same constructor object to set those parameters</p><p>Which was nice &mldr; but provided a naming collision.</p><ul><li>I had to differentiate between the <em>position of an HTML node</em> and the <em>final translation of its (potential) canvas element</em></li><li>I had to differentiate between the <em>size of an HTML node</em> and the <em>drawing size of its (potential) canvas element</em>.</li></ul><p>Because, in some specific cases, you&rsquo;d be able to set <em>both</em> from the exact same constructor/params object. And, me being hopeful and interested by this new system, thought I was going to use the HTML system for everything from now on. So I gave the most &ldquo;sensible&rdquo; name to that, and a more complicated one to my custom renderer.</p><ul><li>HTML used <code>pos</code> or <code>position</code> / Canvas used <code>translate</code></li><li>HTML used <code>size</code> / Canvas used <code>dims</code> (for <em>dimensions</em>)</li><li>To make matters worse, I somehow used a <strong>verb</strong> for some things (<em>translate</em>) &mldr; and a <strong>noun</strong> for others (<em>rotation</em>). I only caught this a while later, and it was too late to &ldquo;easily change it&rdquo; then. It&rsquo;s obvious in hindsight, but when deep into the code, this is a very subtle error.</li></ul><p>Well, the HTML system is gone, and if it returns it will surely not be stupid enough to do this.</p><p>As such, I had to do a massive rename across the entire website to use <code>pos</code> (for position), and <code>size</code> (for size), and to use <strong>nouns</strong> for all.</p><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>Nouns are generally longer than verbs, but also more correct. The property is the <em>final value</em>, not the <em>change</em>, so it should be a noun and not a verb.</p></aside><p>In general, the process was as follows.</p><ul><li>I backed up the entire thing beforehand. (I use Git version control too, but I also just like copy-pasting the entire JS folder to my desktop, as it&rsquo;s easier to &ldquo;revert&rdquo; one or two bad files by just copy-pasting the old version back and doing that one manually.)</li><li>I searched the entire website for <code>translate:</code> and <code>.translate</code>, which catches 99% of the references to this property. Then I replaced them all with <code>pos:</code> and <code>.pos</code></li><li>I did the same thing for <code>dims:</code> / <code>.dims</code> => <code>size:</code> / <code>.size</code></li><li>And I obviously updated the LayoutOperation itself to use these.</li><li>Then I did a final check on the words &ldquo;translate&rdquo; and &ldquo;dims&rdquo; (without anything else attached) just to manually see if I missed anything. There are always a handful of weird cases where I decided to write/manipulate a layoutOperation in a weird way, and this found them.</li></ul><p>Yes, yes, I am now much more conscious of how I name stuff and how consistent it is. This was just a mistake of old that I had to correct at some point, and this point&mdash;when the Layout system had a massive update anyway&mdash;seemed the best one.</p><p>Honestly, the most annoying part of this was that my oldest games used a <code>size</code> property on the global configuration to read the final card size. But now it had a naming clash with what used to be called <code>dims</code> and contained the <em>grid dimensions</em> (such as: 3x3 cards on this page) for the PDF. For 8 games, I had to go in and rename that property to <code>sizeElement</code> in both the configuration and anywher else it was used.</p><p>Otherwise, if you do a 1-on-1 rename of something, it doesn&rsquo;t tend to give issues outside of unique naming clashes. Because the code doesn&rsquo;t care if all the variables are called <code>rotation</code> or <code>rot</code>. (Or variants on that, like variables called <code>rotationLeft</code> that are now just <code>rotLeft</code>.)</p><p>Still, I hope I never have to do this again :p</p><h2 id=performance>Performance?</h2><p>After all these changes, the code is clean and it works cleanly &mldr; but I didn&rsquo;t really focus on performance. Now, for the most part, this is not an issue. It&rsquo;s fine to wait a few seconds until your material is generated, and even the most complicated One Paper Games (thanks to PIXI) only take a few seconds.</p><p>But &mldr; there are a few &ldquo;hybrid games&rdquo; on my website that use my drawing system to <em>repeatedly draw stuff</em>. (Such as updating every frame while playing a game.)</p><p>One of those games is just unplayable now. As soon as it has to load images/text ( = expansion enabled), it lags so hard you can&rsquo;t do anything. Even when it only has to draw ~5 images and text boxes! I was pretty sure I&rsquo;d accidentally introduced some major stupid regression, like re-calculating loads of stuff every frame, so I went on the hunt for performance issues.</p><h3 id=what-was-not-the-issue>What was NOT the issue</h3><p>I tested the <em>creation</em> of new classes (such as new Resources or LayoutOperations). I tested all the empty classes that are in the system, and all of them are extremely cheap&mdash;as they should be, but I wasn&rsquo;t sure anymore.</p><p>Creating 100 empty resources or operations (without actually <em>drawing</em> them) takes 0 ms (rounded.)</p><p>This confirmed that all the delay was in the actual drawing/application, not the creation of the objects/tree in the first place.</p><h3 id=improvement-1-cache-single-frames-again-for-re-use>Improvement #1: Cache single frames again for re-use</h3><p>First of all, I remembered I&rsquo;d disabled automatic caching of spritesheets. (When the image is loaded, it used to be automatically cut into its individual frames. But in practice, this turned out to be heavier and slower than needed in most games.)</p><p>Now, when it wants a frame, it cuts it out of the bigger spritesheet on the spot. That&rsquo;s obviously <em>also</em> a waste! It should cache the cut-out frame after getting it once. So that, when the system wants a frame multiple times, it can just re-grab that one instead of cutting it out again.</p><p>I profiled placing a ResourceImage on a canvas 100 times. First, it took <strong>300 ms</strong> (milliseconds). Now it took <strong>~200 ms</strong>.</p><h3 id=improvement-2-dont-stroke-and-fill--if-we-have-none>Improvement #2: Don&rsquo;t stroke and fill &mldr; if we have none</h3><p>This is just a stupid one. When drawing anything, it calls an <code>applyStrokeAndFill</code> function to, well, apply the stroke color and fill color to the object at the right time. (When to do so depends on the stroke alignment; if the stroke is on the outside, for example, it should come BEFORE the object.)</p><p>Well, as it happens, it also called that function and did <code>stroke()</code> and <code>fill()</code> on the canvas WHEN THERE WAS NO STROKE OR FILL.</p><p>So, yeah, for probably a year <em>every</em> single element has tried to add a stroke and fill color to itself, even when it wasn&rsquo;t set at all. And I didn&rsquo;t notice this, because, well, if there is no color it defaults to &ldquo;transparent&rdquo; so this effect is just invisible.</p><p>Bailing out early when there is no stroke/fill reduced the profiling from <strong>~200 ms</strong> to <strong>~100 ms</strong>.</p><h3 id=improvement-3-no-temporary-canvases-when-not-needed>Improvement #3: No temporary canvases when not needed</h3><p>I&rsquo;d written this down as an optimization over a year ago. It was, again, silly that I only actually implemented it now.</p><p>At the start of every LayoutOperation, it creates a temporary canvas. Why? Because it&rsquo;s needed for certain common effects.</p><p>For example, take a <code>ResourceGroup</code>. It first needs to collect all its children in one place before I can draw it. Otherwise, if I add a drop shadow to it (for example), it would apply one <em>to all the individual children</em> instead of the group as a whole. As such, it needs a temporary canvas first where it collects the output of all children, and then it draws <em>that</em> onto the real one.</p><p>But &mldr; for, I guess, 80+% of operations this just isn&rsquo;t needed. So I wrote a simple check to see if a temporary canvas was even needed. If not, don&rsquo;t create one duh!</p><p>This brought the timing (for drawing 100 ResourceImages with common settings) down from <strong>~100ms</strong> to just <strong>~10 ms</strong>.</p><p>My first check, however, was a bit &mldr; naive. After some more testing and profiling, I realized I needed to be a bit more conservative about when to add that temporary context. (That is, some things drew <em>completely wrong</em> now because I didn&rsquo;t create a temporary canvas when I <em>should have</em>.)</p><p>I wrote a better, more conservative check that basically does this.</p><ul><li>Loop through all <em>effects</em> and see if any of them need a temporary canvas. (This is just one variable I manually set on all effects, and so far only two actually need one.)</li><li>If it&rsquo;s a <em>group</em>, it <em>always</em> needs a temporary canvas. (For the reason I just mentioned: it has to collect all results into another canvas before drawing <em>everything at once</em>.)</li></ul><p>With that change, the performance (for drawing 100 images) is now <strong>~90 ms</strong>. Still not amazing, but far better than before and definitely usable in simple real-time projects.</p><p>Yeah. Should&rsquo;ve done that sooner. As expected, this makes <em>all</em> Material Generators (not the One Paper Games) more than 5x as fast. Because the gains per resource drawn obviously compound into bigger and bigger gains when you draw lots of things, multiple times, on multiple cards, for an entire game.</p><p>At this point, we&rsquo;re losing most time on the conversion images => PDF (which is simply slow and can&rsquo;t be sped up further), instead of generating + drawing. I am fine with that. Getting an entire high-quality PDF with 60 playing cards, for free, with one press of the button, within 10 seconds, is more than fine.</p><h2 id=conclusion>Conclusion</h2><p>With every update, the website becomes faster, cleaner, easier to use, easier to update/work with for me. This is another major one, and perhaps me brevity in summarizing it doesn&rsquo;t really do it justice.</p><p>In a way, I&rsquo;m glad my website didn&rsquo;t &ldquo;blow up&rdquo; before now. As far as I can tell, there are some visitors here and there trying my games, but nothing more. In the past few years, the website has been in a somewhat broken state <em>many times</em>, sometimes for several weeks or even months.</p><p>Only now, after so many iterations and growing so much as a developer/designer, do I feel like the website is very robust and trustworthy. It will do as you ask without crashing, without delay, without weird issues. It&rsquo;s fast, it will work everywhere.</p><p>Hopefully, this means I don&rsquo;t need to do more massive updates in the future, and I can fully focus on <em>making more games</em> again.</p><p>Until the next time,</p><p>Pandaqi</p></div></article><div><nav class=pagination><ul><li><a href=/blog/news-and-updates/2025/announcement-dutch-webshop-launched/ class="masked-link big-mask mask-7" style=--rotation:-1.5deg>&lt;&lt; Previous Page</a></li><li>Continue reading</li><li><a href=/blog/news-and-updates/2025/principle-of-least-maintenance/ class="masked-link big-mask mask-6" style=--rotation:-0.5deg>>> Next Page</a></li></ul></nav></div></main><footer id=site-footer><div class="padding center-block"><h3>More Pandaqi</h3><p>You could <a href=https://pandaqi.com>visit the game studio</a>.
Or my <a href=https://pandaqi.com/tutorials/>free tutorial website</a>.
Or my <a href=https://rodepanda.com/>portfolio</a> with easy access to absolutely everything I ever made.
Or my <a href=https://nietdathetuitmaakt.nl/>(mostly) Dutch online store</a> that sells unique merchandise.</p><h3>Latest</h3><nav class=latest><ul><li><a href=/blog/news-and-updates/2026/my-online-store-has-launched/>My Online Store Has Launched!
(üõí)</a></li><li><a href=/blog/news-and-updates/2026/pandaqi-games-version-4/>Pandaqi Games: Version 4.0?
(üêº)</a></li><li><a href=/blog/boardgames/death-by-digits/>Death by Digits
(üïµÔ∏è‚Äç‚ôÇÔ∏è)</a></li><li><a href=/blog/boardgames/fiddlefoo/>Fiddlefoo
(üéª)</a></li><li><a href=/blog/news-and-updates/2026/how-i-coded-my-own-webshop/>How I Coded My Own Webshop
(üõí)</a></li><li><a href=/blog/boardgames/the-luck-legends/a-little-white-die/>A Little White Die
(üé≤)</a></li><li><a href=/blog/boardgames/the-luck-legends/champions-of-chance/>Champions of Chance
(üé≤)</a></li><li><a href=/blog/boardgames/the-luck-legends/chaos-contract/>Chaos Contract
(üòà)</a></li><li><a href=/blog/boardgames/the-luck-legends/deceptidice/>Deceptidice
(ü§•)</a></li><li><a href=/blog/boardgames/the-luck-legends/folly-and-fortune/>Folly & Fortune
(ü§•)</a></li></ul></nav><h3>Sections</h3><nav><ul><li><a href=/blog/boardgames/>Boardgames
(üé≤)</a></li><li><a href=/blog/news-and-updates/>News & Updates
(üì¢)</a></li><li><a href=/blog/reviews-and-thoughts/>Reviews & Thoughts
(üí≠)</a></li><li><a href=/blog/tutorials/>Tutorials
(üë©‚Äçüéì)</a></li><li><a href=/blog/videogames/>Videogames
(üéÆ)</a></li></ul></nav><h3>Credits</h3><p>Theme by me (<a href=https://pandaqi.com>Pandaqi</a> üêº) &#183;
with ‚ù§Ô∏è &#183;
using <a href=https://gohugo.io>Hugo</a> &#183;
&copy; 2018&ndash;2026 Pandaqi Blog</p></div></footer><link rel=stylesheet type=text/css href=/blog/css/style.css><script src=/blog/js/main.bundle.min.js async defer></script></body></html>