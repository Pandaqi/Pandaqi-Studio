<!doctype html><html lang=en-US><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Photomone: Antsassins | Pandaqi Blog</title><link rel=icon type=image/png href=https://pandaqi.com/blog//favicon.png><link rel=stylesheet type=text/css href=/blog/css/critical.min.css></head><body><header id=site-header><nav class=menu><ul><li><a href=https://pandaqi.com/blog/ class="masked-link big-mask mask-4" style=--rotation:1.5deg>Home</a></li><li><a href=/blog/boardgames/ class="masked-link big-mask mask-2" style=--rotation:-1deg>Boardgames</a></li><li><a href=/blog/news-and-updates/ class="masked-link big-mask mask-5" style=--rotation:-0.5deg>News & Updates</a></li><li><a href=/blog/reviews-and-thoughts/ class="masked-link big-mask mask-1" style=--rotation:0.5deg>Reviews & Thoughts</a></li><li><a href=/blog/tutorials/ class="masked-link big-mask mask-1" style=--rotation:-1.5deg>Tutorials</a></li><li><a href=/blog/videogames/ class="masked-link big-mask mask-1" style=--rotation:0.5deg>Videogames</a></li></ul></nav></header><main class="padding center-block"><article class=single-article><div class=thumbnail-media><figure class=thumb-image><picture><img src=photomone_antsassins_header.webp loading=lazy decoding=async alt="Thumbnail / Header for article: Photomone: Antsassins" title="Thumbnail / Header for article: Photomone: Antsassins" width=2481 height=935></picture></figure></div><h1>Photomone: Antsassins</h1><aside class=metadata><nav class=breadcrumbs><span class=metadata-label><span class=emoji>ü•ê</span> Breadcrumbs ||</span>
<a href=https://pandaqi.com/blog/>Home</a>
/
<a href=/blog/>Blog</a>
/
<a href=/blog/boardgames/>Boardgames</a>
/
<a href=/blog/boardgames/photomone-antsassins/>Photomone antsassins</a></nav><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/pandaqi.com\/blog\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"\/blog\/","name":"blog"}},{"@type":"ListItem","position":4,"item":{"@id":"\/blog\/boardgames\/","name":"boardgames"}},{"@type":"ListItem","position":5,"item":{"@id":"\/blog\/boardgames\/photomone-antsassins\/","name":"photomone-antsassins"}}]}</script><div><span class=metadata-label><span class=emoji>&#8987;</span> Published ||</span>
<time datetime=2023-09-21T00:00:00>Thursday, Sep 21, 2023</time></div><div><span class=metadata-label><span class=emoji>üìñ</span> Table of Contents ||</span>
<a href=# id=toc-toggle>Show</a></div></aside><aside id=table-of-contents class=masked-link-block><header><h2>Table of Contents</h2></header><nav id=TableOfContents><ul><li><a href=#whats-the-idea>What&rsquo;s the idea?</a></li><li><a href=#issues>Issues</a><ul><li><a href=#issue-1-the-random-shapes>Issue 1: the random shapes</a></li><li><a href=#issue-2-the-code-card>Issue 2: the &ldquo;code card&rdquo;</a></li><li><a href=#issue-3-marking-shapes-as-yours>Issue 3: marking shapes as yours</a></li></ul></li><li><a href=#when-issues-pile-up->When issues pile up &mldr;</a><ul><li><a href=#improving-the-idea-further>Improving the idea further</a></li><li><a href=#using-the-tokens>Using the tokens</a></li><li><a href=#the-antsassin>The Antsassin</a></li></ul></li><li><a href=#lets-make-that>Let&rsquo;s make that</a></li><li><a href=#creating-tiles>Creating tiles</a><ul><li><a href=#massaging-tiles-much-further>&ldquo;Massaging&rdquo; tiles much further</a></li><li><a href=#massaging-tiles-much-much-further>&ldquo;Massaging&rdquo; tiles much, much further</a></li><li><a href=#is-this-enough-to-make-it-work>Is this enough to make it work?</a></li></ul></li><li><a href=#code-cards>Code cards</a></li><li><a href=#tokens>Tokens</a><ul><li><a href=#the-add-and-erase>The &ldquo;add&rdquo; (and &ldquo;erase&rdquo;)</a></li><li><a href=#struggling-to-find-good-ideas>Struggling to find good ideas</a></li><li><a href=#final-look>Final look</a></li></ul></li><li><a href=#towards-a-finished-game>Towards a finished game</a><ul><li><a href=#the-first-tests>The first tests</a></li><li><a href=#the-changes>The changes</a></li></ul></li><li><a href=#version-2>Version 2</a><ul><li><a href=#smoothing--polishing>Smoothing & Polishing</a></li><li><a href=#quicker-testing>Quicker testing</a></li><li><a href=#last-fixes>Last fixes</a></li></ul></li><li><a href=#version-3>Version 3</a><ul><li><a href=#the-result>The result</a></li><li><a href=#voronoi-diagrams>Voronoi Diagrams</a></li></ul></li><li><a href=#version-4>Version 4</a><ul><li><a href=#the-new-rules>The new rules</a></li><li><a href=#new-visualization-photomone>New visualization: Photomone</a></li><li><a href=#new-visualization-clouds>New visualization: Clouds</a></li><li><a href=#new-code-cards>New code cards</a></li><li><a href=#further-rules-improvements>Further rules improvements</a></li><li><a href=#about-interactivity>About interactivity</a></li></ul></li><li><a href=#testing-this-version>Testing this version</a></li><li><a href=#lessons-learned>Lessons learned?</a></li></ul></nav></aside><div><p>Welcome to my devlog for the game <a href=/photomone-games/draw/photomone-antsassins>Photomone: Antsassins</a>. As expected, it&rsquo;s part of the <a href=/photomone-games/>Photomone Games</a> project.</p><p>While developing that game, I invented some &ldquo;expansions&rdquo;, that quickly turned into completely separate ideas that should just be separate games. This was the first of them.</p><h2 id=whats-the-idea>What&rsquo;s the idea?</h2><p>The original Photomone gives you a random map of <em>points</em>. During the game, you have to communicate secret words by drawing. The twist? You can only draw using straight lines between the points. (And more: different words give you a different number of lines, some points do special stuff when you use them, etcetera.)</p><p>When I tested the (very) first version of this game myself, I looked at the final paper and thought: &ldquo;huh, now I have a paper filled with random shapes that look <em>kinda</em> like something&rdquo;</p><p>What if we turn the game around?</p><ul><li>You start with random shapes (drawn with straight lines between points)</li><li>You have to say a <em>word</em> and your team members must guess which shape it refers to</li></ul><p>It becomes very similar to the popular &ldquo;Codenames&rdquo;.</p><ul><li>Create two teams at the start. One player of each team is the &ldquo;coder&rdquo;, the others are &ldquo;guessers&rdquo;</li><li>The coders get a card/image that shows which shapes belong to team 1 and which to team 2</li><li>The coder must say a word, and then the guessers must pick out the shape they mean.</li></ul><p>I, also, knew quite quickly that it should work &mldr; if I could solve a few issues.</p><h2 id=issues>Issues</h2><h3 id=issue-1-the-random-shapes>Issue 1: the random shapes</h3><p>How do we get random shapes? Ones that look like <em>something</em>, but aren&rsquo;t clearly a certain object. (Also, I don&rsquo;t want to draw hundreds of shapes myself, so I really want this to be 100% computer-generated.)</p><p>The only solution would be a <strong>simple algorithm</strong> to draw random shapes between the points. Something that draws random lines, but has a slight preference for &ldquo;going back home&rdquo;.</p><p>Even if we have that, how do we refer to them? Do we give a <em>number</em> to each shape? Can they <em>overlap</em>, making this even harder?</p><p>Labeling them with <em>names</em> is clearer (and less abstract). But those names can be abused to make the guessing easier, so I&rsquo;m afraid they <em>have</em> to be numbered.</p><h3 id=issue-2-the-code-card>Issue 2: the &ldquo;code card&rdquo;</h3><p>The code card should say to which team a shape belongs.</p><p>However, if we just write a bunch of numbers, that is <em>very</em> unfriendly to the players. They have to read their numbers, then look at the map, <em>find the shape with that number</em>, and repeat that process the whole game.</p><p>No, the code card has to be a mirror of the board itself.</p><ul><li>It shows the same shapes in the exact same layout</li><li>Those that belong to team 1 are clearly one color (say blue)</li><li>Those that belong to team 2 are clearly another color (say red)</li></ul><p>But, if that&rsquo;s the case, then both the <strong>board</strong> and its <strong>code card(s)</strong> must be generated at the same time.</p><p>As such, we&rsquo;d need a system to generate one PDF with &mldr;</p><ul><li>Multiple boards (the full page)</li><li>And one page with a lot of code cards (which belong to those boards)</li></ul><h3 id=issue-3-marking-shapes-as-yours>Issue 3: marking shapes as yours</h3><p>When a team guesses a shape, its true color must be revealed. Was it indeed from your team, or from the opponent&rsquo;s team?</p><p>Well &mldr; <em>how</em> do we reveal that? How do we mark them? Writing on the board isn&rsquo;t great, because I want the game to be replayable. Download + print it once, play as much as you want.</p><p>But &mldr; dang it, then we need <strong>tokens</strong>. Another page for the material PDF, with ants in different colors to mark the shapes. (Once guessed, place the right color somewhere on the shape.)</p><h2 id=when-issues-pile-up->When issues pile up &mldr;</h2><p>When an idea develops like this, I know from experience that I&rsquo;m trying to fit a square peg into a round hole. I tried to simulate Codenames, but stuck too much to the original game of Photomone. (A paper with random dots and lines between them that create shapes.)</p><p>Once I let go of that, I could see what we really needed. A completely new approach. More deviation from the original Photomone.</p><p>The game Codenames uses a grid of <em>cards</em>. You place 5x5 cards with one word, randomly, at the start of a game. This is <em>great</em>. It means you only need a relatively small deck of word cards to make the game endlessly replayable. Because every time, you have a new arrangement of words and a new code card.</p><p>That&rsquo;s what we need. So here&rsquo;s the new idea:</p><ul><li>The material consists of <em>tiles</em>.</li><li>A tile has dots and lines between them, like before.</li><li>But those dots follow a regular pattern, which allows the tiles to be connected to each other in any way. A shape might start on tile A, then seamlessly cross over into a new set of lines in tile B.</li><li>You&rsquo;re not guessing shapes, you&rsquo;re guessing <strong>tiles</strong></li></ul><p><figure class=inline-image><picture><img src=clue.webp loading=lazy decoding=async alt="Spoilers! This image is from the final rulebook, in which I inverted it. (You give hints about which tiles are NOT yours.)" title="Spoilers! This image is from the final rulebook, in which I inverted it. (You give hints about which tiles are NOT yours.)" width=2056 height=525></picture><figcaption class=side-note><span>Spoilers! This image is from the final rulebook, in which I inverted it. (You give hints about which tiles are NOT yours.)</span></figcaption></figure></p><p>That last idea is crucial. At first, I thought the &ldquo;tile system&rdquo; was hopeless, because I had no control over whether shapes stayed within their own tile or not. Until I realized that rule: we don&rsquo;t have to guess shapes, we can guess <em>parts of shapes</em>.</p><p>So, the coder often has to say a word that relates to part of a shape, or only the left side of a shape.</p><p>This idea is <em>much</em> better, or at least more &ldquo;workable&rdquo;. You only need to download one PDF with a few pages of material.</p><ul><li>The tiles (two pages)</li><li>Several random code cards (which simply assign the tiles to teams randomly) (one page)</li></ul><p>Every time you play, the random order <em>and</em> rotation of the tiles will create new shapes and a new game.</p><h3 id=improving-the-idea-further>Improving the idea further</h3><p>You might notice that I didn&rsquo;t include those &ldquo;tokens&rdquo; in the material. Because we <em>can</em> do without them now!</p><blockquote><p>When you guessed a tile, flip it face-down</p></blockquote><p>This is fun for another reason: it <em>changes</em> shapes as you play. That&rsquo;s a really unique aspect that clearly differentiates this game from Codenames. Over time, you might be able to use new descriptions to communicate your shapes&mdash;or old descriptions become <em>worse</em>, but the guessers don&rsquo;t know.</p><p>However, this doesn&rsquo;t mark to which <em>team</em> the tile belongs. Is that important? I&rsquo;m not sure. Let&rsquo;s think about a solution anyway.</p><p>I thought about <em>rotating</em> tiles instead.</p><ul><li>Each tile has two colored sides (blue for team 1, red for team 2)</li><li>Once guessed, rotate the tile so the <em>correct</em> team points towards the guessers</li></ul><p>This would work fine. But it does limit us a lot: it means that, during setup, the tiles cannot be rotated like that, constraining the randomness.</p><p>Sigh &mldr; let&rsquo;s bring back the tokens again.</p><h3 id=using-the-tokens>Using the tokens</h3><p>If we&rsquo;re going to include one page with tokens/chips, let&rsquo;s make sure we <em>really use them</em>. I wrote down several new ideas or expansions that would use those tokens.</p><p>The most important idea is that players can <strong>change</strong> the board! Because our grid is <em>regular</em>, I can create tokens that fit <em>exactly</em> between two dots. Now players can place those tokens on the board to change shapes on the fly.</p><p>The other ideas are mostly about <strong>protection</strong>. For example, a token you can use once per game when you are <em>really</em> unsure about a shape.</p><p>Why? What could happen? Well, this game is called <strong>Antsassins</strong> for a reason.</p><h3 id=the-antsassin>The Antsassin</h3><p>Another idea lifted from Codenames. Each code card has one &ldquo;black&rdquo; square: the Assassin. If guessed by accident, that team <em>instantly</em> loses the game.</p><p>A great, great idea. Such a simple and intuitive rule, but it adds tension and strategy to the <em>whole</em> game.</p><p>Obviously, I used it in my game as well. One of the tiles is the Antsassin. As such, some tokens <em>protect</em> you against it, if used well.</p><h2 id=lets-make-that>Let&rsquo;s make that</h2><p>Now we have a solid idea! What do we need?</p><ul><li>A script that randomly generates the tiles.</li><li>A script that randomly generates code cards</li><li>A script that randomly generates tokens</li><li>Finally, a script that combines the output of all that, and puts it in one nice PDF</li></ul><h2 id=creating-tiles>Creating tiles</h2><p>Each tile has the same, consistent grid of points. The edges are always the same (so tiles fit together nicely, whatever their rotation). Inside, however, I want to allow removing some points. This will add variety and uniqueness to the shapes generated.</p><p>This got me thinking, though. The problem with a square grid, is that the <em>diagonal</em> distance between points is different from the <em>straight</em> (horizontal / vertical) distance. And I don&rsquo;t like that.</p><p>For example, it&rsquo;d mean I need to create two sets of tokens to &ldquo;add a line&rdquo; to the board. One for the short distance, one for the long one. It&rsquo;s just &mldr; messy.</p><p>But I know a grid that doesn&rsquo;t have this issue. It&rsquo;s a <strong>triangular</strong> grid! A equilateral triangle has three sides of equal length. Build a grid from those, and the distance between all points is identical.</p><p>However, that would give us way too many tiles, so let&rsquo;s consolidate multiple triangles into an <strong>hexagonal grid</strong>.</p><p>The code, then, is straightforward.</p><ul><li>Place the points at equal distances.</li><li>Perform some number of &ldquo;random walks&rdquo;: you start at one point and keep walking to random neighbor points until you randomly decide you&rsquo;re done.</li></ul><p>This, however, is too random. Let&rsquo;s &ldquo;massage&rdquo; this into something more controlled.</p><ul><li>Don&rsquo;t create a line that already exists.</li><li>Don&rsquo;t create lines along the border of the tile. (Is harder to see and looks ugly.)</li><li>Force the generation to at least create X lines that stay entirely within their tile. (They close themselves and don&rsquo;t visit an edge point.)</li><li>Prefer going in the same direction over taking sudden sharp turns. (For all neighbors, calculate the angle. Compare it to our previous angle. The greater the difference, the less likely we are to pick that neighbor next.)</li></ul><p>That last rule is just a general heuristic that creates nicer shapes. Without it, most shapes would look like the same random zigzags or scribbles from a toddler. With it, it prefers longer lines and curves.</p><h3 id=massaging-tiles-much-further>&ldquo;Massaging&rdquo; tiles much further</h3><p>I underestimated how ugly random tiles would look this way. Or, rather, how unpredictable this system was, which means 50% of the tiles looked fine, and the other 50% looked completely unusable.</p><p>That&rsquo;s why I spent a lot of time adding more heuristics, checks and safeguards to help the generation.</p><p>First, it&rsquo;s about <strong>forcing diversity</strong>.</p><ul><li>I divided the tiles into sections. Each line starts in a different section.</li><li>I alternate between &ldquo;this line cannot use edge points&rdquo; and &ldquo;this line must start at the edge&rdquo;</li><li>If we just placed a very short line, place a long one. (And vice versa.)</li></ul><p>Then I remove <strong>ugly clashes</strong>.</p><ul><li>Don&rsquo;t allow doubled lines or lines entirely across the edge (already mentioned)</li><li>Don&rsquo;t allow more than 2 points of the walk to be on the edge. (Prevents ugly zigzags pushed against the edge.)</li><li>Allow at most 3 connections on a point, and 1 intersection (with itself or another line).</li><li>Even so, allowing intersections/reusing a point has a <em>low</em> probability.</li></ul><p>Yes, this forces the lines to stay nicely separated (mostly). But &mldr; I realized I actually didn&rsquo;t like that.</p><p>You see, the best thing is for these tiles to contain <em>closed shapes</em>. Those are more recognizable than a few separated scribbles.</p><p>If one line encounters another line &mldr; well, that&rsquo;s a great (organic) opportunity to <em>stop</em> this random walk immediately. Because now the two lines are connected and form a bigger, more closed shape.</p><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>Similarly, I actually <em>prefer</em> STARTING a shape on a dot that&rsquo;s already used. Because it means multiple lines are connected, for sure, and can randomly turn into a bigger and more meaningful shape together.</p></aside><p>With that, we finally start getting tiles with shapes you <em>could</em> describe. But it&rsquo;s still only a fraction of all the tiles.</p><div class=image-gallery style="--num-cols:auto auto"><p><figure class=inline-image><picture><img src=photomone_nice_tile_1.webp loading=lazy decoding=async alt="Photomone nice tile 1" title="Photomone nice tile 1" width=488 height=479></picture></figure><figure class=inline-image><picture><img src=photomone_nice_tile_2.webp loading=lazy decoding=async alt="Photomone nice tile 2" title="Photomone nice tile 2" width=494 height=449></picture></figure><figure class=inline-image><picture><img src=photomone_nice_tile_3.webp loading=lazy decoding=async alt="Photomone nice tile 3" title="Photomone nice tile 3" width=500 height=466></picture></figure><figure class=inline-image><picture><img src=photomone_nice_tile_4.webp loading=lazy decoding=async alt="Photomone nice tile 4" title="Photomone nice tile 4" width=504 height=466></picture></figure><figure class=inline-image><picture><img src=photomone_nice_tile_5.webp loading=lazy decoding=async alt="Photomone nice tile 5" title="Photomone nice tile 5" width=494 height=444></picture></figure></p></div><h3 id=massaging-tiles-much-much-further>&ldquo;Massaging&rdquo; tiles much, much further</h3><p>I also wrote code to <em>purposely</em> close a shape. It picks such a random walk ~20% of the time. It calculates the angle back to its start (or earlier points) and <em>heavily favors</em> points going in that direction, which means it ultimately rotates back. (Unless we&rsquo;re unlucky and it never reaches itself again.)</p><p>Finally, I added the step that most &ldquo;procedural generation&rdquo; needs: some <strong>manual input and hand-picked results</strong>.</p><ul><li>I told the system how to create a few basic shapes (triangle, trapezoid, pentagon, open circle, etcetera). Regularly, I just place such a basic shape, instead of doing a random walk.</li><li>Once in a while, I only do one random walk. Then I simply <em>copy</em> it to another part of the tile. (Perhaps rotated/mirrored/whatever.) => This repetition/symmetry is usually pleasing to the eye.</li><li>I forced &ldquo;inside&rdquo; shapes (that can&rsquo;t use the edge anyway) more towards the center, away from the edge.</li><li>I experimented with placing other elements. (Dots, things <em>between</em> the lines, etcetera.)</li></ul><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>I also tried different resolutions. Both 4 and 8 work. (The sides of the hexagon are divided into 4 or 8 points, respectively.) The first one looks a bit cleaner, but obviously has very little space for actual shapes to develop. The second can make every tile look distinct, but also look more messy.</p></aside><h3 id=is-this-enough-to-make-it-work>Is this enough to make it work?</h3><p>Eh, it doesn&rsquo;t really change much. Disappointing. Let&rsquo;s quickly continue. (There&rsquo;s a loooot of devlog to go, with many different versions, scrapping old ideas and trying new ones.)</p><div class=image-gallery style="--num-cols:auto auto"><p><figure class=inline-image><picture>Cannot find image:contentphotomone_nice_tile_6.webp</picture></figure><figure class=inline-image><picture>Cannot find image:contentphotomone_nice_tile_7.webp</picture></figure><figure class=inline-image><picture>Cannot find image:contentphotomone_nice_tile_8.webp</picture></figure><figure class=inline-image><picture>Cannot find image:contentphotomone_nice_tile_9.webp</picture></figure><figure class=inline-image><picture>Cannot find image:contentphotomone_nice_tile_10.webp</picture></figure></p></div><h2 id=code-cards>Code cards</h2><p>The hardest part was making these <em>look good</em> :p</p><p>Because the code just does this:</p><ul><li>Create a list of all tiles</li><li>Turn one into the assassin</li><li>Assign X random tiles to team 1 (taking them out of that list)</li><li>The remaining list belongs to team 2</li></ul><p>And then we visualize that by coloring a set of hexagons on the card.</p><p>To make it look good, I &mldr;</p><ul><li>Picked nice colors and margins, obviously</li><li>Added a shadow/glow effect to the tiles</li><li>Showed the starting team around the edges. (This is more for decoration than functionality. Just showing the starting team <em>once</em> would be enough. But showing it 4 times, and with both triangles and a line, just makes the card look more polished.)</li><li>Used a <em>pattern</em> to fill the tiles. (This also helps read them more easily, especially for colorblind players.)</li></ul><p><figure class=inline-image><picture><img src=photomone_antsassins_code_cards_v1.webp loading=lazy decoding=async alt="Photomone antsassins code cards v1" title="Photomone antsassins code cards v1" width=1049 height=856></picture></figure></p><h2 id=tokens>Tokens</h2><p>These don&rsquo;t have any &ldquo;generation&rdquo; or &ldquo;randomness&rdquo;. I simply use the computer to generate them, because it&rsquo;s far easier and more flexible. (Especially combined with the other systems.)</p><p>I&rsquo;ve drawn the token backgrounds in vector software. The code places the backgrounds in a grid, puts any other elements on top, and ta da&mdash;we have one page of tokens to cut and use.</p><h3 id=the-add-and-erase>The &ldquo;add&rdquo; (and &ldquo;erase&rdquo;)</h3><p>The biggest obstacle was my &ldquo;erase&rdquo; (and &ldquo;add&rdquo;) token. My plan was to make it the exact same size as the distance between points (on tiles). This way, you can literally place it on the board to change the lines.</p><p>But &mldr; that just wasn&rsquo;t great. It would mean that &mldr;</p><ul><li>The token shape was odd (all tokens are round, but these are rectangular??)</li><li>I had to do loads of magic ( = complex calculations) to <em>ensure</em> these tokens were the exact same length as the tiles you printed. Even then, if you wanted to play with a different shape/new material, the tokens might be wrong.</li><li>The tokens would be very tiny and their impact minimal.</li></ul><p>Instead, I realized the big circular shape was actually an <em>asset</em>. Instead of adding/removing one line, the token now simply <em>covers a whole area</em> on the board. The &ldquo;add&rdquo; powerup adds <em>multiple lines in that area</em>.</p><p>This makes the tokens consistent (in look and size), and the impact much more meaningful (and fun). In fact, with that change I can get many different &ldquo;add&rdquo; tokens! Because I can randomize the lines inside them during generation!</p><h3 id=struggling-to-find-good-ideas>Struggling to find good ideas</h3><p>Besides that, I &mldr;</p><ul><li>Struggled to invent really good tokens or special powers.</li><li>Struggled to make these look any special. (I had no inspiration and no time to procrastinate, so the designs are pretty simple and standard. Good enough, but certainly nothing special.)</li></ul><p>For example, a good token <em>seems</em> to be: &ldquo;rotate a tile&rdquo;. It allows you to change the board to look like something you can describe (more easily). This, however, contains an obvious cheat: when you take this action, simply always rotate <em>a tile from your team</em>. Easy! You&rsquo;ve just communicated a tile for certain!</p><p>Actions like that only work if there&rsquo;s no way to pick your own tiles all the time. If I could fine some simple rule to prevent this, I&rsquo;d have another ~5 tokens that should work.</p><p>A rule that accomplishes this, is &mldr;</p><blockquote><p>Those tokens can only be used by <em>guessers</em>. (They don&rsquo;t know which tile is theirs, so they can just rotate a tile they think is unclear, or one that they <em>think</em> their coder struggles with.)</p></blockquote><p>Do I really want to limit half the tokens to guessers only? Then I realized that all my previous tokens were basically only for coders, so yes, this actually seems like a good balance :p (The &ldquo;add&rdquo; token is very useful to coders, as they can make tiles easier to describe. But it&rsquo;s almost useless to guessers, because what&rsquo;s the point of adding a line when you have no clue what tiles are yours?)</p><h3 id=final-look>Final look</h3><p>And that&rsquo;s how the tokens ended up split into two categories: for use by coder or guesser only. I needed some way to show this <em>on the token</em> (instead of only mentioning it in the rules, which nobody reads and everyone forgets). I opted for a simple <strong>lock</strong> (for the coder) and <strong>question mark</strong> (for the guessers), placed on the left and right edge.</p><p>The &ldquo;add&rdquo; token reuses the &ldquo;random walk&rdquo; code for creating the tiles. But because they are circles, they use a circular grid. (Which is actually easier than the others, because circles are simple and consistent :p)</p><p>Bringing it all together, the tokens looked like this.</p><p><figure class=inline-image><picture><img src=photomone_antsassins_tokens_v1.webp loading=lazy decoding=async alt="Photomone antsassins tokens v1" title="Photomone antsassins tokens v1" width=1873 height=916></picture></figure></p><h2 id=towards-a-finished-game>Towards a finished game</h2><p>By now, you might have the impression that I&rsquo;d been working on this game for days or weeks. In reality, I rushed through the programming in a few short bursts here and there. (This wasn&rsquo;t my main project. Also, it&rsquo;s demotivating to get stuck on really hard problems, like the random tile generation.)</p><p>I knew I had to get a prototype as quickly as possible. I just couldn&rsquo;t figure out, purely in my head or by looking at a screen, if this game would even <em>work</em> at all. I had to create the physical tiles, place them on a table, and see if I could connect words to the shapes.</p><p>As such, I think this is the quickest I&rsquo;ve ever gone from &ldquo;start of an idea&rdquo; to &ldquo;completely printed prototype&rdquo;. When I printed the game, I had <em>just</em> finished the tiles, cards and tokens working the night before. (In fact, around 11 PM, I considered printing an unfinished version and just <em>drawing</em> the missing pieces myself the next morning. That&rsquo;s how quickly I wanted a physical version.)</p><p>(The &ldquo;massaging&rdquo; of the tiles I explained in detail above, was far from done at this point, so I just printed the older, rough version of the tiles.)</p><p><figure class=inline-image><picture><img src=antsassins_playtest_v1.webp loading=lazy decoding=async alt="Image of first playtest, square board, just started" title="Image of first playtest, square board, just started" width=1095 height=822></picture><figcaption class=side-note><span>Image of first playtest, square board, just started</span></figcaption></figure><figure class=inline-image><picture><img src=antsassins_playtest_v1-2.webp loading=lazy decoding=async alt="Image of first playtest, square board, game over" title="Image of first playtest, square board, game over" width=1023 height=767></picture><figcaption class=side-note><span>Image of first playtest, square board, game over</span></figcaption></figure></p><h3 id=the-first-tests>The first tests</h3><p><strong>How did this playtest go?</strong> Bad, but very instructive :p</p><p>Yes, it&rsquo;s way too hard to see clear shapes&mdash;let alone combine them for your clue&mdash;with the current tiles and rules.</p><p>While testing, I often throw new rules in there (as I come up with solutions to problems) to immediately see if they work. This led to a long list of &ldquo;let&rsquo;s try this to get more meaningful shapes&rdquo; with issues.</p><ul><li>Each round, the coder picks one row/column and rotates tiles as they please. => Issue: just rotate your tiles only, and you&rsquo;ve just communicated your tiles very easily!</li><li>Okay, let&rsquo;s <em>force</em> players to rotate <em>all</em> of them. => Issue: the board changes way too much (leading to hints becoming useless the next round).</li><li>During setup, try to make the tiles connect as much as possible => Issue: very vague, makes setup unnecessarily long/involved, and doesn&rsquo;t <em>really</em> solve anything. (Yes, tiles are connected more, but if those tiles aren&rsquo;t yours &mldr; who cares?)</li><li>Okay, let&rsquo;s move it to the <em>guessers</em> then. Each turn, <em>they</em> point at two tiles, and the coder rotates those as they see fit. => Issue: high likelihood that guessers pick tiles that coder can&rsquo;t do anything with anyway. If they <em>do</em> pick two good tiles, then it&rsquo;s obvious from the coder&rsquo;s eagerness to rotate them that they are from their team.</li></ul><p>Near the end, we finally had some idea about what the game really needed.</p><ul><li>Tiles shouldn&rsquo;t clearly contain something <em>by themselves</em>. Because then tiles just become known as &ldquo;the one that looks like a dog&rdquo; or &ldquo;the one that&rsquo;s a house&rdquo;, which is reused every game for easy (and boring) hints.</li><li>The game is simply more aggressive/dynamic than Codenames. Yes, the board will change a lot, let&rsquo;s make that a clear <em>feature</em> of the game.</li><li>As such, changes should be drastic. Not &ldquo;rotate these two tiles if you want&rdquo;, but &ldquo;you must swap all tiles in a row or column of choice with new ones from the deck&rdquo;.</li></ul><p>Often, one team would just have a few very hard tiles (with meaningless shapes on them), and soon they were behind so many points that they were never going to win. It felt like the power to make the board look &ldquo;prettier&rdquo; (or &ldquo;more meaningful&rdquo;) should be in the hands of those <em>losing</em>.</p><p>Additionally, a bad turn feels &mldr; bad in Codenames (and this game). The coder went through all this effort to create a great clue, and you guess <em>nothing correctly</em>? I wanted to turn this bad feeling into a more fun and interesting part of the game.</p><h3 id=the-changes>The changes</h3><p>This led to the biggest rule change.</p><blockquote><p>If a team scores nothing ( = no correct guess), they must change the board. The guessers pick a row or column. The coder either rotates all tiles in it, or swaps all tiles for new ones from the deck. (Tiles already revealed are ignored.)</p></blockquote><p>It also made me look differently at the tiles.</p><ul><li>Maybe I stop focusing on making them look like <em>something</em> by themselves.</li><li>Instead, they have very simple straight lines. (Or lines with just 1 or 2 turns).</li><li>One set of lines uses only the middle edge points. (To ensure they almost always connect with each other. It&rsquo;s annoying how often the current tiles don&rsquo;t precisely line up, even though there aren&rsquo;t that many options :p)</li><li>Another set of lines (displayed differently, maybe gray or a dashed line) uses the other edge points.</li><li>The board has many of these small tiles, which <em>together</em> will form different shapes, depending on what line you&rsquo;re following.</li></ul><p>I think adding multiple sets of lines will allow tiles to mean <em>multiple things</em>, helping the game a lot. But by restricting each line to a fixed set of (edge) points, you&rsquo;re certain that they will (often) line up.</p><p>To finish it off, the code cards will be programmed to (heavily) favor connecting your squares into groups. Because the playtesting revealed that as (by far) the most fun and effective part of this game: communicating a group of 2-3 tiles because <em>together</em> they looked like a dog, or a house, or whatever. And they were all yours!</p><h2 id=version-2>Version 2</h2><h3 id=smoothing--polishing>Smoothing & Polishing</h3><p>Okay, I have good news and bad news.</p><p>I implemented the ideas above and realized I could get <em>four</em> sets of lines out of it. (One uses only the middle edge points, one only the corners, and the other two use the points in between.)</p><p>That all worked nicely.</p><p>Then I realized that there was a much <em>easier</em> way to make lines go from one edge to another, without the nasty zigzagging or uncertainty from random walks: <strong>pathfinding</strong>. I grabbed an old implementation of the A* algorithm (which I used for an older game), rewrote it into modern JavaScript so I could put it into my general Pandaqi Toolset, and used that. Now the paths are simply generated by &mldr;</p><ul><li>Picking a start point on the edge</li><li>Pick another end point on the edge</li><li>Asking the pathfinder tool to generate the shortest path between them.</li><li>But we lie about the shortest path: the &ldquo;distance&rdquo; between points is set to some random value (between 0 and 1), which means the path will curve and take detours going to its destination!</li></ul><p>Then I thought: &ldquo;this game looks very blocky and abstract, can&rsquo;t I <em>smooth</em> the lines? Make them a bit more curvy?&rdquo; I spend an hour researching and then implemented something called <strong>Catmull-Rom Interpolation</strong>. Which, surprisingly, worked first try and did make the game look much more inviting.</p><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>I also wanted this because the straight lines created the same shapes over and over: triangles, beaks of birds, lightning bolts, fishes. By smoothing the lines, you get way more variety, and not everything looks like a bird anymore.</p></aside><p>Then I made the different lines different colors and widths, and gave them a shadow, to make them really stand out from each other.</p><p>All of these things were <em>improvements</em>. But were they enough? No, I don&rsquo;t think so.</p><h3 id=quicker-testing>Quicker testing</h3><p>I didn&rsquo;t want to <em>print</em> each new version to test it physically. (It&rsquo;s more work and feels like a waste of paper/ink.) But I needed a way to quickly see if you <em>could</em> identify shapes or meaning behind the tiles.</p><p>So I spend a day developing a simple interactive interface.</p><p>It loads the randomly generated tiles into a grid. I can drag-and-drop tiles to swap places. I can rotate individual tiles, or the whole board. I can remove a tile (and replace it with a completely new tile from &ldquo;the deck&rdquo;).</p><p>In other words, it allows me to modify the game at will, as if I were moving around physical tiles.</p><p><figure class=inline-image><picture><img src=photomone_antsassins_v2_dragndrop.webp loading=lazy decoding=async alt="Photomone antsassins v2 dragndrop" title="Photomone antsassins v2 dragndrop" width=916 height=920></picture></figure></p><p>And in doing so &mldr; I realized it was still too hard. Even when I had <em>total control</em> over the board (modifying it as I pleased, as often as I wanted), it was near impossible to identify shapes and find words to &ldquo;connect&rdquo; multiple tiles. You <em>can</em> do it. It sometimes <em>does</em> produce fun and creative results. But not consistently enough&mdash;far from it&mdash;to make this a solid game.</p><h3 id=last-fixes>Last fixes</h3><p>I did want to try some small ideas to improve it. Maybe I was <em>just</em> short of greatness :p</p><ul><li>Shapes (like dots/circles) <em>between</em> the lines.</li><li>Something I called &ldquo;hairs&rdquo;: one-off lines splitting off another line, to add more texture and variation.</li><li>Lines running along the edge. (To immediately close off a shape on the same tile.)</li><li>Lines stopping within the tile (instead of running edge to edge).</li><li>Filled-in shapes (rectangles, semicircles, etcetera) attached to the side of lines.</li></ul><p>Here&rsquo;s a summary of how I implemented each.</p><p><strong>Between the lines</strong>: we know the distance between the points in the grid. (From, well, making that grid in the first place.) So place a dot at <em>half</em> that distance, at fixed angles. (6 angles if hexagon/triangle, 4 if rectangle.)</p><p><strong>Hairs</strong>: pick random points on the path and a random neighbor of theirs. If no line exists yet, save one going from point1 to point2.</p><p><strong>Edge Lines</strong>: run the Pathfinder again, on the same start/end point, but now we pretend only the <em>edge</em> points exist in this world.</p><p><strong>Half Lines</strong>: I literally added a function <code>cutInHalf()</code> to the <code>RandomWalk</code> class, which just throws away the first or last half of the path.</p><p><strong>Filled-in Shapes</strong>: by far the hardest to implement. Starting from any point, we need to find exactly the two (or three) other points needed to close the shape (triangle or rectangle). If I just say &ldquo;move to a random neighbour&rdquo;, anything could happen.</p><p>To pick the right points, we check the grid position of the neighbors.</p><ul><li>For a triangle, each point needs distance 1 to the original point. (So |x-x1|+|y-y1| = 1)</li><li>For a rectangle, the furthest point (the third one) has distance 2 to the original point.</li></ul><p><figure class=inline-image><picture><img src=photomone_antsassins_v2_final_tiles.webp loading=lazy decoding=async alt="Photomone antsassins v2 final tiles" title="Photomone antsassins v2 final tiles" width=917 height=924></picture></figure></p><p>Yeah &mldr; that&rsquo;s not much better. Sure, there are more unique shapes and you can see more varied objects into it. But it&rsquo;s <em>really</em> messy, overwhelming, and just not good enough.</p><p>Let&rsquo;s try one last thing.</p><h2 id=version-3>Version 3</h2><p>Making this game brought some philosophical discussions into my life about how people actually <em>see</em> and <em>identify</em> shapes.</p><p>I reached the following conclusions.</p><ul><li>We&rsquo;re <em>really</em> hardwired to see faces or living beings. No matter the tile design I used, all I (and others) would see were animals, faces, eyes, etcetera. (Especially once I added those <em>dots</em>.)</li><li>How shapes are <em>filled in</em> is more important (and easy to identify) than their outline. An outline&mdash;especially one that&rsquo;s mixed with other outlines&mdash;is just not enough. A circle-like shape will always just be a circle, but add something inside (a few extra lines, a filled in dot), and it suddenly becomes a sheep, a balloon, a face.</li><li>As such, overlapping shapes doesn&rsquo;t work as well as I hoped. Because the inside of one shape, is part of another shape, and it all becomes a mess in front of our eyes. In the real world, barely anything is seethrough. (And we all know examples of people who missed that glass door and walked nose-first into it thinking it was open space :p)</li></ul><p>After more research, more thinking, more testing, I was at the end of my wits and saw only one avenue left to try: turning the tiles into something more akin a <strong>mosaic</strong> or <strong>stained glass</strong>.</p><p>In other words,</p><ul><li>The whole tile is subdivided into simple shapes.</li><li>These shapes could be triangles, rectangles or circles. (Or all of these mixed.)</li><li>Nothing &ldquo;overlaps&rdquo;. It all follows the grid. (Although I can obviously make shapes occupy 2 or 3 spaces in the grid, instead of just 1.)</li><li>In code, I divide these shapes into &ldquo;groups&rdquo;. (Just like the code cards.)</li><li>Then each &ldquo;group&rdquo; all receives the same color. (I&rsquo;ll probably reduce the number of colors from the previous version.)</li></ul><p>I think this will at least be easier on the eye and prettier on the table. If it leads to identifiable shapes remains to be seen. I&rsquo;ll probably need finetuning and perhaps adding details <em>inside</em> mosaic parts (at random), like dots for eyes or lines for hair.</p><p>Let&rsquo;s try it.</p><h3 id=the-result>The result</h3><p>It is &mldr; better? It looks less chaotic, and I can actually assemble some meaningful shapes. The hexagons look a little more organic and less &ldquo;blocky&rdquo; than rectangles.</p><p><figure class=inline-image><picture><img src=photomone_antsassins_v3_mosaic_start.webp loading=lazy decoding=async alt="Photomone antsassins v3 mosaic start" title="Photomone antsassins v3 mosaic start" width=927 height=915></picture></figure></p><p><figure class=inline-image><picture><img src=photomone_antsassins_v3_mosaic_start_hexagon.webp loading=lazy decoding=async alt="Photomone antsassins v3 mosaic start hexagon" title="Photomone antsassins v3 mosaic start hexagon" width=1877 height=927></picture></figure></p><p>The colors are awful though: a mosaic like this would be better with a unified color scheme with only 2 or 3 soft colors. Slight variations, as if the mosaic is &ldquo;weathered&rdquo;, would help too. (I left in the same colors as before, and now I&rsquo;ve (re)learned that good colors for <em>lines</em> isn&rsquo;t the same as good colors for <em>filled shapes</em>.)</p><p>Or two highly contrasting colors, so you get one clear foreground, and the rest is background. (And it&rsquo;s up to you whether you look for shapes in the &ldquo;negative space&rdquo; or not.)</p><p>Additionally, let&rsquo;s merge some triangles into bigger rectangles, or replace them with a circle.</p><p><figure class=inline-image><picture><img src=photomone_antsassins_v3_mosaic_progress.webp loading=lazy decoding=async alt="Photomone antsassins v3 mosaic progress" title="Photomone antsassins v3 mosaic progress" width=921 height=919></picture></figure></p><p><figure class=inline-image><picture><img src=photomone_antsassins_v3_mosaic_progress_hexagon.webp loading=lazy decoding=async alt="Photomone antsassins v3 mosaic progress hexagon" title="Photomone antsassins v3 mosaic progress hexagon" width=1117 height=928></picture></figure></p><p>It&rsquo;s still not ideal. I&rsquo;m not sure if this game idea is even feasible anymore :(</p><p>I have a few things left to try, otherwise I might have to settle for radically changing the idea. Probably removing the computer generation, hand crafting the tiles, and rewriting the rules to something else entirely. Let&rsquo;s hope it doesn&rsquo;t come to that.</p><h3 id=voronoi-diagrams>Voronoi Diagrams</h3><p>I knew these existed and wanted to try them from the start of this project. The idea is as follows.</p><ul><li>So far, we&rsquo;ve adhered to a grid. This added structure to the chaos, and made many coding steps easier.</li><li>But there is a way to <em>randomly place points</em> ( = create a random grid), and still be able to turn them into polygons you can work with. That algorithm is called Voronoi (which uses a Delauney triangulation)</li></ul><p>I didn&rsquo;t write this myself: I used a library for it. I hoped this would remove the patterns and &ldquo;blockiness&rdquo; of earlier tiles, allowing more varied interpretations of what you see.</p><p>To make the change, I had to &mldr;</p><ul><li>Mess up the grid after creating it :p After creating that perfect subgrid, all (non-edge) points are jerked around in random directions.</li><li>I convert this into a simple array I can feed into that library</li><li>What I get back uses the same algorithms to grow itself into groups</li><li>And then we color the polygons that remain.</li></ul><p>By controlling how much we &ldquo;mess up&rdquo; the grid, we control how chaotic or different the mosaic shapes become. (I noticed that a tiny value makes the tiles almost &mldr; cute. The cells are a bit wonky, but mostly identical. Higher values create huge differences, which you&rsquo;ll see in the image below.)</p><p><figure class=inline-image><picture><img src=photomone_antsassins_v4_delaunay.webp loading=lazy decoding=async alt="Photomone antsassins v4 delaunay" title="Photomone antsassins v4 delaunay" width=1122 height=901></picture></figure></p><p>This might just work! The varying shapes make this <em>much</em> prettier, more organic, and most of all: varied. In the screenshot above (the first one after I had this working), I can easily give names to certain shapes.</p><p>I can see something like a foot (or kicking leg). I can see a hand, and a hand as a fist. I can see a chicken and a flower.</p><p>With finetuning and extra details, I think this could become the game. (Obviously, the circles aren&rsquo;t placed correctly yet, that code hadn&rsquo;t changed from the previous version.)</p><h2 id=version-4>Version 4</h2><p>NOPE. I was wrong, again. This is much better than the previous versions, and it&rsquo;s <em>kinda</em> playable, but that&rsquo;s not good enough.</p><p>Whatever I try, I <em>cannot</em> make a computer draw random shapes that look like something by just the right amount. I searched for the golden balance: you <em>can</em> see a &ldquo;bear&rdquo; in this collection of shapes, but it&rsquo;s not obvious. I don&rsquo;t think it exists.</p><p>Which means we must pivot :p</p><p>I&rsquo;ve basically programmed a generator that can create random semi-pretty shapes (in many different ways). It is <em>hard</em> to describe the shapes&mdash;let&rsquo;s make that a necessary part for the game.</p><p>So far, the idea tried to mimic Codenames. You have to guess 8-10 tiles across the board to win. There are two teams (with one coder per team) and the fastest one wins.</p><p>If we <em>lower</em> the number of tiles to guess, we can <em>allow</em> it to be much harder. If you only have to guess 1 or 2 tiles, it&rsquo;s okay if it&rsquo;s really hard to describe that tile. The game transforms into a treasure hunt of sorts. You spend 30 minutes trying to find that <em>one</em> tile that belongs to you.</p><p>Let&rsquo;s turn that into a new set of rules.</p><h3 id=the-new-rules>The new rules</h3><p><strong>Setup</strong>: grab as many code cards as players. Pick exactly two code cards for each team color. Now give <em>everyone</em> a code card.</p><p>Your codecard shows the &ldquo;secret tiles&rdquo; of your teammate ( = the other player with your color). It also adds grey tiles around it that mean &ldquo;almost correct&rdquo;, and of course a few assassin squares (which are further away).</p><p><strong>Gameplay</strong>: On your turn,</p><ul><li>Give your teammate a one-word clue about those secret squares.</li><li>(Optional) <em>Guess</em> your own secret tile.</li></ul><p><strong>Clues</strong>: you can&rsquo;t say letters, numbers, shapes or colors. Besides that, you have complete freedom.</p><p><strong>Guessing</strong>: you tap the tile you want to guess.</p><ul><li>Correct? Great! Place your token on it. If your team has now guessed all its tiles, you win.</li><li>Almost? Your teammate says &ldquo;almost&rdquo;, and sometimes these tiles have a special action that helps you in the future.</li><li>Assassin? Your team is out of the game. (Might be too harsh, we&rsquo;ll see.)</li><li>Otherwise? Do nothing.</li></ul><p>Those are the full (new) rules. As always, I <em>think</em> this works. The shapes created by the random tiles are just abstract enough that you won&rsquo;t get it right with 1 hint, but you probably will with 3+ hints. It combats the biggest issues, but also some minor gripes I have with codenames. (Such as the fact that the guessers are just &mldr; a big group of players doing nothing while waiting on the coder to finally give their next clue.)</p><p>One last thing that bothered me, is the fact that walking around the table ( = looking at the board from different angles) helps a lot with finding meaning. But &mldr; with a code card, that becomes confusing. Because you have to <em>rotate</em> that card whenever you see the board differently, otherwise the secret tile suddenly ends up somewhere else!</p><p>With only <em>one</em> secret tile though&mdash;or at most two&mdash;this isn&rsquo;t that big a deal. After one round, you <em>know</em> where the tile is, and won&rsquo;t make mistakes when changing position.</p><h3 id=new-visualization-photomone>New visualization: Photomone</h3><p>An additional benefit is that all my (previous) experiments with the tile visuals might still be valuable. The mosaic will probably be the &ldquo;base game&rdquo;, but on the website you can pick the other styles.</p><p>Which allows tiles to look more like the Photomone game that this project is actually based on :p Those games work by connecting random dots on the paper with straight lines. As such, I wanted to program that visualization as well.</p><p>It&rsquo;s a small change on the technical level</p><ul><li>Randomly mess up that perfect grid again. (But not the edge points)</li><li>Draw lines like before (with random walks / pathfinding).</li><li>Only use the middle or corner edge points as connections (so that most tiles will connect)</li><li>Ramp up the resolution: with the messed-up grid and Photomone style, we can handle way more points and lines</li></ul><p><figure class=inline-image><picture><img src=photomone_antsassins_photomone_visualization.webp loading=lazy decoding=async alt="Photomone antsassins photomone visualization" title="Photomone antsassins photomone visualization" width=1035 height=701></picture></figure></p><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>With the growing number of ways to draw the tiles, I knew I needed some better code. So, I broke the huge <code>Tile</code> class into a smaller one that accepts a <code>TileVisualizer</code>. That one actually calculates and draws the unique bits, which means I merely have to write a new Visualizer for each style and plug that in when selected by the user.</p></aside><h3 id=new-visualization-clouds>New visualization: Clouds</h3><p>Finally, I wanted to add a &ldquo;cloud animals&rdquo; style. It&rsquo;s exactly what you&rsquo;d expect: the tiles are filled with random clouds that might connect to look like an animal.</p><p>Technically, this means</p><ul><li>I create a big table for each cell holding all its pixels. (Formally: a 2D array of around 200x200 size.)</li><li>I go around adding random circles.<ul><li>Half the time, I <em>add</em> to all pixels within the circle</li><li>Otherwise, I <em>erase</em> all pixels within the circle</li></ul></li><li>When done, I have a big table with values between 0 and 1, indicating how much of a cloud each pixel is. (Some parts will be fully empty, others fully white, and most some transparent area in-between.)</li><li>I visualize this by simply drawing rectangles for each pixel at that intensity.</li></ul><p><figure class=inline-image><picture>Cannot find image:contentphotomone_antsassins_clouds_visualization.webp</picture></figure></p><h3 id=new-code-cards>New code cards</h3><p>To create the new code cards, I &mldr;</p><ul><li>Had to invent a few more player colors. (In case you play with more than 4 players.)</li><li>On each card, I place 1 or 2 tiles for the team color. (This will probably be a difficulty setting.)</li><li>All <em>neighbor</em> tiles get the &ldquo;almost&rdquo; color and some special action. (Reminder: this triggers when that tile is guessed and probably helps your team.)</li><li>Of all remaining tiles, a few are randomly selected as assassins.</li></ul><p>The basic grid and lay-out all stay the same. It&rsquo;s just how things are colored. The worst part, to be honest, was having to invent new <em>patterns</em> for the new team colors. (Because it looks better and to support colorblind players.) It&rsquo;s a struggle to find something that looks distinct, without being too busy.</p><h3 id=further-rules-improvements>Further rules improvements</h3><p>While figuring out the &ldquo;special actions&rdquo; that trigger when you guess an &ldquo;almost&rdquo; tile, I realized it&rsquo;s probably most interesting and balanced if these actions sometimes help the <em>other</em> team(s).</p><ul><li>You get a great hint about the secret tile that might put you in the lead by a lot. Giving a special action to another team helps close that gap a little.</li><li>It adds more strategy to picking clues. Because you don&rsquo;t want to pick clues that might trigger <em>great</em> actions for another team.</li></ul><p>Thinking some more about this, I realized an even simpler rule that works better.</p><blockquote><p>The team <em>to which the Almost tile belongs</em> executes the action.</p></blockquote><p>This means you are rewarded for getting your teammate to guess an Almost tile that belongs to <em>you</em>. But if they guess a different Almost tile, it helps another team. (Similar to how Codenames punishes you for guessing a card that belongs to another team.)</p><p>It also means that Almost tiles can be colored (and different per team). Which is nice, because it&rsquo;s highly unlikely (on a randomly generated code card) that I can find multiple spots that could be an Almost tile for <em>all</em> teams at once. That was the original plan, and it was a bad plan.</p><p>Lastly, I wanted to bring back the idea of providing clues for multiple tiles. My current random generation algorithms support that the best: single tiles look like nothing, but groups of tiles might look like something.</p><p>But how do you support that? When you have only <strong>one</strong> secret tile to guess? Well, you <strong>invert it</strong>.</p><p>Instead of providing a clue about the secret tile, you must provide a clue about the tiles it is <strong>not</strong>.</p><p>This way, we take more advantage of our random tiles, become more like Codenames again, and allow more creativity. (It also reduces the chance of somebody insta-guessing the right tile on turn 1, because they happen to have a tile that really clearly looks like a <em>dog</em>.)</p><p>So, on your turn, you say a clue and a number. Over time, you communicate all the places on the map that are NOT the secret tile.</p><p>With these changes, the rules seem short and watertight. It also feels like a really unique game with its own strengths, instead of a modified version of Codenames.</p><h3 id=about-interactivity>About interactivity</h3><p>At this point, I realized the game had lost a lot of its interactivity. Everyone has a different code card, so you&rsquo;re just giving clues for <em>your</em> square, and what other players do on their turn doesn&rsquo;t matter.</p><p>Or does it?</p><p>The rule I added in the section above, adds back some interactivity. If you guess wrong, it might give a powerful action to <em>another team</em>.</p><p>Additionally, the game is over once somebody has guessed all their tiles. This means that, if other players are doing well, you will feel the need to give more dangerous hints (or ones that encompass more tiles).</p><p>So there&rsquo;s still interactivity there. Is it enough, though?</p><p>Right now, if you guess the secret tile from another team, nothing happens. In Codenames, this obviously reveals this team for the opponent, which is interactive (and bad for you). But in this game, that doesn&rsquo;t work. Everybody has a unique code card, so this information means absolutely nothing.</p><p>Instead, the Almost tiles should probably carry this game. I should add actions that are <em>really helpful</em> when you accidentally trigger them for the other team.</p><h2 id=testing-this-version>Testing this version</h2><p>As you might understand, I grew increasingly tired and frustrated with this project. As such, I stopped working full-time on it long ago, and only did the next step each weekend. This means it&rsquo;s now been a few months since the last version. (Because the steps were: rewrite rules, new visualization 1, new visualization 2, new code cards.)</p><aside class="remark masked-link-block"><span class=label>Remark ||</span><p>It&rsquo;s astonishing how short and simple the rules become with this rewrite. It&rsquo;s barely half a page. Let&rsquo;s hope it stays that way and playtesting doesn&rsquo;t reveal the need for extra rules or mechanics.</p></aside><p>When I came back to the project a final time, a few weeks before it was scheduled to release, all I could think was: &ldquo;meh&rdquo;.</p><p>Yes, the rules are clean and well-done. All the code works. The game <em>works</em>.</p><p>It&rsquo;s just that the tiles aren&rsquo;t great. Sometimes ugly, sometimes nearly impossible to recognize shapes in them. And no matter what I do, I can&rsquo;t fix that. There are only certain combinations (usually <em>rectangular</em> tiles and the <em>mosaic</em> setting) that somewhat consistently lead to playable games.</p><p>So. Yeah. A big &ldquo;meh&rdquo;. This game is maybe the worst one (in terms of consistently fun gameplay) I&rsquo;ve ever made. I still want to publish and finish it&mdash;these games are free and I clearly state that people can leave feedback and I can improve things over time. (In fact, because material is generated with a computer, I can literally change the game&rsquo;s material at any point.)</p><p>Looking at it with fresh eyes (and a looming self-imposed deadline), I was able to improve <em>some</em> minor things and squash some bugs.</p><p>I also came up with even more ways to create the tiles. But they all suffered from the same problems at the others, so it&rsquo;d just be different ways for tiles to look &ldquo;meh&rdquo;.</p><p>Instead, I considered one final possibility. A tile so small (2x2 or 3x3) I can just go through <em>all possibilities</em> (or almost all of them) of filling the squares inside it. Then, I&rsquo;d increase the size of the grid (from 6x6 to 8x8) to allow bigger connections to form shapes.</p><p>Did this work? You guessed it: it kinda did, it kinda didn&rsquo;t. I added it as another option, but at the end of the list.</p><p>I am DONE with this game.</p><p>It also doesn&rsquo;t help that I&rsquo;m working with an old, broken laptop. (Unable to buy a proper functional computer due to lack of funds and health issues depleting the funds I do have.) Even starting a code editor takes a century. Waiting for changes to compile or show just drains the life from me.</p><p>I am calling this project DONE and I DON&rsquo;T CARE if it&rsquo;s terrible.</p><h2 id=lessons-learned>Lessons learned?</h2><p>Know when to give up.</p><p>Know when an idea just isn&rsquo;t going to work out, no matter how hard you push it, no matter how much time you give it.</p><p>I could&rsquo;ve probably made another game&mdash;heck, two or three games&mdash;in the time I spent on this idea. Games that work first time, games with a much stronger foundation.</p><p>Instead, I have this one monstrosity to show for my efforts. Yes, you can play the game. It doesn&rsquo;t look pretty though (except for the mosaics) and it only works if all players are very imaginative and willing to take creative leaps.</p><p>I tried, I tried, I failed.</p><p>I had an idea, it worked <em>kinda</em> in version 1, 2, 3, and 4, until I had to realize that &ldquo;working kinda&rdquo; from the start is just not enough. Your idea needs to &ldquo;work great&rdquo; from the start, and just &ldquo;get better / more polished&rdquo; as you add images and work it out.</p><p>Let&rsquo;s hope I learn from it and prevent this mistake in upcoming games.</p><p>Should you play this game? Probably not. You can try. You can give me feedback.</p><p>Did I learn a lot from the process? Yes. And I will keep it online to show everyone that some ideas don&rsquo;t work out and that artists don&rsquo;t do everything perfectly the first time. (Also because I have the <em>tiniest</em> sliver of hope that time, feedback or a better computer might get the game to a more playable state in the future.)</p><p>Until the next (hopefully much shorter and more positive) devlog,</p><p>Pandaqi</p></div></article><div><nav class=pagination><ul><li><a href=/blog/boardgames/photomone-digital-antists/ class="masked-link big-mask mask-2" style=--rotation:2deg>&lt;&lt; Previous Page</a></li><li>Continue reading</li><li><a href=/blog/boardgames/kangaruse/ class="masked-link big-mask mask-4" style=--rotation:-1deg>>> Next Page</a></li></ul></nav></div></main><footer id=site-footer><div class="padding center-block"><h3>More Pandaqi</h3><p>You could <a href=https://pandaqi.com>visit the game studio</a>.
Or my <a href=https://pandaqi.com/tutorials/>free tutorial website</a>.
Or my <a href=https://rodepanda.com/>portfolio</a> with easy access to absolutely everything I ever made.
Or my <a href=https://nietdathetuitmaakt.nl/>(mostly) Dutch online store</a> that sells unique merchandise.</p><h3>Latest</h3><nav class=latest><ul><li><a href=/blog/news-and-updates/2026/my-online-store-has-launched/>My Online Store Has Launched!
(üõí)</a></li><li><a href=/blog/news-and-updates/2026/pandaqi-games-version-4/>Pandaqi Games: Version 4.0?
(üêº)</a></li><li><a href=/blog/boardgames/death-by-digits/>Death by Digits
(üïµÔ∏è‚Äç‚ôÇÔ∏è)</a></li><li><a href=/blog/boardgames/fiddlefoo/>Fiddlefoo
(üéª)</a></li><li><a href=/blog/news-and-updates/2026/how-i-coded-my-own-webshop/>How I Coded My Own Webshop
(üõí)</a></li><li><a href=/blog/boardgames/the-luck-legends/a-little-white-die/>A Little White Die
(üé≤)</a></li><li><a href=/blog/boardgames/the-luck-legends/champions-of-chance/>Champions of Chance
(üé≤)</a></li><li><a href=/blog/boardgames/the-luck-legends/chaos-contract/>Chaos Contract
(üòà)</a></li><li><a href=/blog/boardgames/the-luck-legends/deceptidice/>Deceptidice
(ü§•)</a></li><li><a href=/blog/boardgames/the-luck-legends/folly-and-fortune/>Folly & Fortune
(ü§•)</a></li></ul></nav><h3>Sections</h3><nav><ul><li><a href=/blog/boardgames/>Boardgames
(üé≤)</a></li><li><a href=/blog/news-and-updates/>News & Updates
(üì¢)</a></li><li><a href=/blog/reviews-and-thoughts/>Reviews & Thoughts
(üí≠)</a></li><li><a href=/blog/tutorials/>Tutorials
(üë©‚Äçüéì)</a></li><li><a href=/blog/videogames/>Videogames
(üéÆ)</a></li></ul></nav><h3>Credits</h3><p>Theme by me (<a href=https://pandaqi.com>Pandaqi</a> üêº) &#183;
with ‚ù§Ô∏è &#183;
using <a href=https://gohugo.io>Hugo</a> &#183;
&copy; 2018&ndash;2026 Pandaqi Blog</p></div></footer><link rel=stylesheet type=text/css href=/blog/css/style.css><script src=/blog/js/main.bundle.min.js async defer></script></body></html>