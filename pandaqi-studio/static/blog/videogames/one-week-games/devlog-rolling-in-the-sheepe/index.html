<!doctype html><html lang=en-US><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Rolling in the Sheepe | Pandaqi Blog</title><link rel=icon type=image/png href=https://pandaqi.com/blog//favicon.png><link rel=stylesheet type=text/css href=/blog/css/critical.min.css></head><body><header id=site-header><nav class=menu><ul><li><a href=https://pandaqi.com/blog/ class="masked-link big-mask mask-7" style=--rotation:0deg>Home</a></li><li><a href=/blog/boardgames/ class="masked-link big-mask mask-6" style=--rotation:-1.5deg>Boardgames</a></li><li><a href=/blog/news-and-updates/ class="masked-link big-mask mask-8" style=--rotation:-1deg>News & Updates</a></li><li><a href=/blog/reviews-and-thoughts/ class="masked-link big-mask mask-2" style=--rotation:-1.5deg>Reviews & Thoughts</a></li><li><a href=/blog/tutorials/ class="masked-link big-mask mask-3" style=--rotation:-0.5deg>Tutorials</a></li><li><a href=/blog/videogames/ class="masked-link big-mask mask-3" style=--rotation:0.5deg>Videogames</a></li></ul></nav></header><main class="padding center-block"><article class=single-article><div class=thumbnail-media><figure class=thumb-image><picture><img src=sheepe-header.webp loading=lazy decoding=async alt="Thumbnail / Header for article: Rolling in the Sheepe" title="Thumbnail / Header for article: Rolling in the Sheepe" width=1920 height=762></picture></figure></div><h1>Rolling in the Sheepe</h1><aside class=metadata><nav class=breadcrumbs><span class=metadata-label><span class=emoji>ü•ê</span> Breadcrumbs ||</span>
<a href=https://pandaqi.com/blog/>Home</a>
/
<a href=/blog/>Blog</a>
/
<a href=/blog/videogames/>Videogames</a>
/
<a href=/blog/videogames/one-week-games/>One week games</a>
/
<a href=/blog/videogames/one-week-games/devlog-rolling-in-the-sheepe/>Devlog rolling in the sheepe</a></nav><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/pandaqi.com\/blog\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"\/blog\/","name":"blog"}},{"@type":"ListItem","position":4,"item":{"@id":"\/blog\/videogames\/","name":"videogames"}},{"@type":"ListItem","position":5,"item":{"@id":"\/blog\/videogames\/one-week-games\/","name":"one-week-games"}},{"@type":"ListItem","position":6,"item":{"@id":"\/blog\/videogames\/one-week-games\/devlog-rolling-in-the-sheepe\/","name":"devlog-rolling-in-the-sheepe"}}]}</script><div><span class=metadata-label><span class=emoji>&#8987;</span> Published ||</span>
<time datetime=2022-01-28T00:00:00>Friday, Jan 28, 2022</time></div><nav class=tags><span class=metadata-label><span class=emoji>üéó</span> Tags ||</span><ul><li><a href=https://pandaqi.com/blog/tags/devlog>devlog</a></li><li><a href=https://pandaqi.com/blog/tags/technical-devlog>technical devlog</a></li></ul></nav><div><span class=metadata-label><span class=emoji>üìñ</span> Table of Contents ||</span>
<a href=# id=toc-toggle>Show</a></div></aside><aside id=table-of-contents class=masked-link-block><header><h2>Table of Contents</h2></header><nav id=TableOfContents><ul><li><a href=#task-1-random-shapes>Task 1: Random shapes</a></li><li><a href=#task-2-turn-shape-into-body>Task 2: Turn shape into body</a></li><li><a href=#task-3-rolling-shapes>Task 3: Rolling Shapes</a></li><li><a href=#task-4-splitting-shapes>Task 4: Splitting shapes</a><ul><li><a href=#first-try-easy-and-convex>First try: easy and convex</a></li><li><a href=#second-try-breaking-it-down>Second try: breaking it down</a></li><li><a href=#merging-triangles>Merging triangles</a></li><li><a href=#ignoring-the-right-ones>Ignoring the right ones</a></li><li><a href=#the-issue-here>The issue here</a></li><li><a href=#third-try-complex-and-concave>Third try: complex and concave</a></li><li><a href=#about-floating-point-precision>About floating point precision</a></li></ul></li><li><a href=#step-45-nicer-slicing>Step 4.5: Nicer slicing</a></li><li><a href=#step-5-following-the-players>Step 5: Following the players</a></li><li><a href=#step-6-creating-the-map>Step 6: Creating the map</a><ul><li><a href=#does-this-work>Does this work?</a></li><li><a href=#what-are-rooms-actually>What are &ldquo;rooms&rdquo;, actually?</a></li></ul></li><li><a href=#step-7-trying-something-completely-different>Step 7: Trying something completely different</a><ul><li><a href=#did-that-work>Did that work??</a></li><li><a href=#in-conclusion>In conclusion</a></li></ul></li><li><a href=#step-8-better-movement>Step 8: Better movement</a></li><li><a href=#step-9-making-the-first-finishable-level>Step 9: Making the first finishable level</a></li><li><a href=#step-10-better-routes>Step 10: Better Routes</a></li><li><a href=#step-11-throwing-sand-against-the-wall>Step 11: Throwing sand against the wall</a></li><li><a href=#step-12-better-routes-for-real-now>Step 12: Better routes, For real now</a></li><li><a href=#step-13-better-slopes--inner-tiles>Step 13: Better slopes + &ldquo;inner tiles&rdquo;</a></li><li><a href=#some-tricks>Some tricks</a></li><li><a href=#step-14-running-with-the-wolves>Step 14: Running with the wolves</a></li><li><a href=#step-15-the-rolling-factor>Step 15: The Rolling Factor</a></li><li><a href=#step-16-rolling-with-the-punches>Step 16: Rolling with the punches</a><ul><li><a href=#realistic-slicing-is-too-realistic>Realistic slicing is too realistic</a></li><li><a href=#realistic-physics-are-too-realistic>Realistic physics are too realistic</a></li></ul></li><li><a href=#step-17-throwing-more-sand-against-the-wall>Step 17: Throwing more sand against the wall</a></li><li><a href=#step-18-welcome-back-after-a-long-break>Step 18: Welcome back after a long break!</a></li><li><a href=#step-19-a-few-days-later>Step 19: A few days later</a><ul><li><a href=#last-rooms>Last rooms</a></li><li><a href=#last-items>Last items</a></li><li><a href=#last-rule-polishing>Last rule polishing</a></li><li><a href=#general-polishing>General polishing</a></li></ul></li><li><a href=#step-20-finishing-the-items>Step 20: Finishing the items</a><ul><li><a href=#better-items>Better items?</a></li><li><a href=#feedback--stuff>Feedback & Stuff</a></li><li><a href=#performance>Performance</a></li></ul></li><li><a href=#step-21-gameplay-polishing>Step 21: Gameplay Polishing</a><ul><li><a href=#solo-mode>Solo Mode</a></li><li><a href=#quality-of-life>Quality of Life</a></li><li><a href=#things-that-shouldve-been-fixed-long-ago>Things that should&rsquo;ve been fixed long ago</a></li><li><a href=#teleporters>Teleporters</a></li><li><a href=#lock-problems>Lock problems</a></li></ul></li><li><a href=#step-22-walking-back-bad-decisions>Step 22: Walking back bad decisions</a></li><li><a href=#i-think-ill-stop-here>I think I&rsquo;ll stop here</a></li><li><a href=#step-23-final-playtest>Step 23: Final Playtest</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></aside><div><p>Welcome to my <strong>devlog</strong> for the game &ldquo;Sheepe&rdquo;, otherwise known as
<a href=https://pandaqi.com/rolling-in-the-sheepe/>Rolling in the Sheepe</a></p><p>The idea was simple: everyone is a sheep in a <strong>random shape</strong>, you can
only <strong>roll yourself</strong>, and the first to reach the finish wins.</p><p>It&rsquo;s another one in my series of <strong>One Week Games</strong>, hence the extremely
simple idea and limited scope.</p><p>(Spoiler Alert: I screwed up again and made the game way too big and
complicated. It&rsquo;s at minimum a <strong>Four Week Game</strong>. But at least I
<em>finish</em> everything I start now and I learned a lot along the way.)</p><p>Because this project got quite out of hand and wildly changed course
multiple times, I&rsquo;m afraid the devlog doesn&rsquo;t have nice images or code
examples to go along with it. Sorry.</p><p>The algorithm to &ldquo;slice any shape realistically&rdquo; really needs more
clarity, so I&rsquo;ll probably write an article soon that explains <em>just that
algorithm</em> in more detail (and pictures). This devlog is literally just
a <em>diary</em> of the development, text only.</p><p>So let&rsquo;s get started!</p><h2 id=task-1-random-shapes>Task 1: Random shapes</h2><p>I use <strong>Godot Engine</strong>, which makes this <em>very</em> easy.</p><ul><li><p>I place points in a circle</p></li><li><p>Then I randomly move them inward/outward a bit</p></li><li><p>Then I tell it to draw this list of points as a polygon.</p></li></ul><p>That&rsquo;s it. Done.</p><p>(I&rsquo;ll talk about some issues with this and modifications later, but for
now this is fine.)</p><h2 id=task-2-turn-shape-into-body>Task 2: Turn shape into body</h2><p>Again, Godot to the rescue:</p><ul><li><p>Create a &ldquo;CollisionPolygon2D&rdquo; node</p></li><li><p>Hand the list of points we just created as its polygon.</p></li><li><p>Make it a child of a &ldquo;RigidBody2D&rdquo; node.</p></li></ul><p>Done.</p><h2 id=task-3-rolling-shapes>Task 3: Rolling Shapes</h2><p>As we&rsquo;ll be using physics, we don&rsquo;t care about &ldquo;rotating&rdquo; the shape
perse, we care about <em>adding angular forces</em> that cause it to rotate.</p><p>Hopefully, the default friction with walls/floors will allow it to move
forward and actually make this game possible.</p><ul><li><p>When the right key is down, add a POSITIVE angular force to the body</p></li><li><p>When the left key is down, add a NEGATIVE angular force to the body</p></li></ul><p>Going strong!</p><h2 id=task-4-splitting-shapes>Task 4: Splitting shapes</h2><p>Now, this is where it gets interesting.</p><p>One of the &ldquo;main features&rdquo; of this game should be <strong>shape splitting.</strong>
When you roll into a spike, it should actually <strong>slice your</strong> <strong>body in
two.</strong></p><h3 id=first-try-easy-and-convex>First try: easy and convex</h3><p>I drew some quick diagrams in my notebook until I saw a pattern. This
pattern was really easy to implement and created perfect slices &mldr; <em>for
convex shapes</em>.</p><p>What&rsquo;s a convex shape? It&rsquo;s a shape without holes in it. A circle is
convex. A rectangle as well.</p><p>(Mathematically precise: you can take <em>any two points inside the shape</em>,
and the <em>line between those points will be fully inside the shape as
well</em>.)</p><p>Even though players might only <em>start</em> as a simple convex shape, over
the course of the game this <em>might not be the case anymore</em>. So I needed
something that worked for <em>concave shapes</em> as well. (Which are simply
all shapes that are not convex.)</p><p>But first, let&rsquo;s take a look at my initial algorithm:</p><ul><li><p>Loop through the edges of the shape</p></li><li><p>Intersect each edge with the &ldquo;slicing line&rdquo;</p><ul><li><p>No intersection? Continue</p></li><li><p>Intersection? Save the current <em>index</em> (in the shape array) and
the exact <em>point</em> at which they intersected (just coordinates).</p></li><li><p>We&rsquo;ve found two intersections? Great, we&rsquo;re done.</p></li></ul></li><li><p>Now <em>extract</em> everything between the first and second <em>index</em> and
save it as a new shape: shape2.</p></li><li><p>Whatever is left of the original array is shape1.</p></li><li><p>Destroy the old body, create new bodies for the new shapes.</p></li></ul><p>As I said, this works flawlessly. As long as you don&rsquo;t forget to:</p><ul><li><p>Transform the shape to <em>global</em> coordinates before you start.
(Taking into account the rotation and position of its body.)</p></li><li><p>Transforming the shape back to <em>local</em> coordinates when done.
(Calculate the average position of the points, also called the
<em>centroid</em>, and reposition around that.)</p></li></ul><p>It executes extremely quickly, doesn&rsquo;t take that much code, and works
for all <em>convex shapes</em>. (And if you slice a convex shape &mldr; it will
stay convex, so no issues there.)</p><h3 id=second-try-breaking-it-down>Second try: breaking it down</h3><p>But when I tried it with a concave shape, my shapes somehow <em>tripled?</em> I
was astounded at first, as I was certain the algorithm only ran once, so
it could only create two bodies (at most).</p><p>But then I turned on the &ldquo;debug physics shapes&rdquo; option. And I saw what
Godot was doing: it automatically <strong>triangulates</strong> concave shapes.</p><p>In other words, if I give it a concave shape, it breaks it down into
separate <strong>triangles</strong>. Then it saves each triangle as a unique shape of
the body, so I can access them separately in the code.</p><p>(Why? Because triangles are <em>convex</em> and easy to work with. I&rsquo;m not
surprised this happens, I&rsquo;m surprised Godot does it without telling you
and then <em>lets me access it</em>.)</p><p>So this is great! It&rsquo;s just what we need actually!</p><p>We can make this work if we:</p><ul><li><p>Create a list of shapes that contains <em>each triangle individually</em>.</p></li><li><p>Create a new empty list.</p></li><li><p>Run the slicing algorithm for each shape in that list</p><ul><li><p>Any new shapes created, are added to the new list</p></li><li><p>If untouched, the original shape is simply copied to the new
list.</p></li></ul></li><li><p>Then we loop through the new list and <em>stitch together</em> any
triangles that should be together.</p></li></ul><p>The first three parts are easy. (Just modify the algorithm we already
have.)</p><p>The last part is not. How on earth do I <em>merge triangles</em>? And how do I
only <em>merge the correct ones, not those that were just sliced?</em></p><h3 id=merging-triangles>Merging triangles</h3><p>Let&rsquo;s think about this.</p><ul><li>Insight #1: They are <em>triangles</em>. Two triangles will share at most
two points. If they share only a single point, I consider them
&ldquo;separate&rdquo; and they shouldn&rsquo;t be merged.</li><li>Insight #2: The points are <em>ordered</em> (clockwise in my case). If we
find one point that matches, we only need to check the next point to
see if we have a matching edge.</li></ul><p>So, for each triangle we loop through its points, and check if any other
triangle has a point in it <em>at the same coordinates</em>. That is a
&ldquo;matching point&rdquo;. Then we check if the point after that <em>also</em> matches
with that triangle. If so, we have a &ldquo;matching edge&rdquo;.</p><p>If we&rsquo;ve found a matching edge, we add the <em>non-matching</em> point from
triangle2 to triangle1 in between the matching ones. Then we delete
triangle2; it&rsquo;s been successfully merged with triangle1.</p><p>Reconsider triangle1 until it doesn&rsquo;t match anything. Repeat until all
shapes have been considered</p><h3 id=ignoring-the-right-ones>Ignoring the right ones</h3><p>Well, what do we know about the triangles that should <em>not</em> merge?</p><p>They have matching points which <em>lie along the slicing vector</em>. Those
points were just created, in the slicing algorithm.</p><p>In other words, if we find a matching point, we first check if it lies
on the slicing vector. If so, ignore it and continue.</p><p>Fortunately, there&rsquo;s a <a href=https://stackoverflow.com/questions/328107/how-can-you-determine-a-point-is-between-two-other-points-on-a-line-segment>fairly standard algorithm</a> for checking if a point is on a line
segment.</p><h3 id=the-issue-here>The issue here</h3><p>So I wrote this algorithm. And &mldr; I ran into issues.</p><p>Do you spot the issue here? It&rsquo;s rather obvious, in hindsight,
especially now that we have the code and some drawings.</p><p><em>After merging two triangles &mldr; we obviously don&rsquo;t have a triangle
anymore</em>. So the first merge might be fine, but then it all goes
haywire. I tried some hacks around this, but in the end I just had to
admit I learned my lesson and &ldquo;merging convex polygons&rdquo; is a <em>terrible
idea</em> which you shouldn&rsquo;t even try to do.</p><p>No, merging isn&rsquo;t the solution here.</p><p>Instead, I think I should <em>keep</em> the separate shapes that I have. Once
I&rsquo;ve sliced some of them, it becomes a matter of <strong>reassigning them
properly</strong>.</p><p>(All shapes that have matching points, should stay together in one
object.)</p><h3 id=third-try-complex-and-concave>Third try: complex and concave</h3><p>And that works!</p><p>To summarize, this is the algorithm:</p><ul><li><p>Detect which objects are underneath our slicing line</p></li><li><p>For each object &mldr;</p><ul><li><p>Get all its unique shapes</p></li><li><p>Slice each of them. (If it doesn&rsquo;t hit the line, it just returns
the original shape. Otherwise it returns the two new shapes.)</p></li><li><p>Once we have the list of <em>new</em> shapes, put those that share
matching points in the same &ldquo;layer&rdquo;</p></li><li><p>For each unique layer, create a new object, and assign all the
new shapes.</p></li></ul></li></ul><p>The slicing algorithm is identical to before. (Because, remember, the
unique shapes that make the object <em>are</em> guaranteed to be convex.)</p><p>The only new (and perhaps difficult) part is &ldquo;assigning shapes that
should be together to the same layer&rdquo;</p><p>For this, I used the following algorithm:</p><ul><li><p>Initialize the list of layers (for each shape) to -1 (or null, or
whatever)</p></li><li><p>For each shape</p><ul><li><p>No layer yet? Create a new one and put the shape in there</p></li><li><p>Check all other shapes.</p></li><li><p>Do we have a matching point?</p><ul><li><p>Copy our layer to the other shape.</p></li><li><p>Or, if the other shape already had a <em>layer</em> and its lower
than ours, take over <em>their</em> layer.</p></li><li><p>Now start the loop from the beginning, because our layer has
changed.</p></li></ul></li><li><p>When checking matching points, <em>ignore any points that lie along
the slicing vector</em>.</p></li></ul></li></ul><h3 id=about-floating-point-precision>About floating point precision</h3><p>That last part is actually where I got stuck for a bit. The algorithm
would work &mldr; erratically. Sometimes it was perfect, sometimes it
didn&rsquo;t do anything. I couldn&rsquo;t spot any errors or logical reasons why.</p><p>In those cases, you simply try a lot of different simple situations, and
check the outcome. Hopefully, this highlights a pattern, or you can
isolate the part where it goes wrong.</p><p>In this case, that never happened. Even the <em>simplest</em> of situations
would fail &mldr; sometimes.</p><p>But I have experience with those kinds of situations! And a voice in the
back of my mind said: <em>floating point precision error</em>.</p><p>Computers cannot save <em>all</em> numbers with infinite precision. There are a
limited number of &ldquo;bytes&rdquo; reserved for each number, and any precision
that needs more bytes is lost.</p><p>This means that the exact same <em>point</em> (of shape) could actually have a
<em>slightly different coordinate</em>. Checking &ldquo;point1 == point2&rdquo; would
<em>fail</em>, because they&rsquo;re not <em>identical</em>.</p><p>Checking whether <strong>a point lies on a line segment</strong> is impossible this
way! Because a line is (mathematically) defined as having &ldquo;zero width&rdquo;,
so the point only needs to be <em>slightly off</em>, and the check fails.</p><p>That&rsquo;s where that variable <strong>epsilon</strong> comes in. It designates a &ldquo;margin
of error&rdquo; we will allow and which will still be counted as &ldquo;these
coordinates are the same&rdquo;.</p><p>The issue? My epsilon was too low. I set it to something like &ldquo;0.005&rdquo;
(which is quite standard). But upon further inspection, the algorithm
works with quite big numbers, so I bumped epsilon up to a way higher
value.</p><p>That fixed the whole issue. Simply setting <strong>epsilon = 0.1</strong> (or even
higher maybe) fixed everything and was the only reason I got stuck for
an hour or two.</p><p>There you have it. If something behaves erratically, and you&rsquo;re working
with <em>floating point numbers</em>, it&rsquo;s probably something like this. And
never, ever, do a &ldquo;==&rdquo; check between two floats :p</p><h2 id=step-45-nicer-slicing>Step 4.5: Nicer slicing</h2><p>So we have a slicing algorithm, which will <em>very precisely</em> cut any
shape we give it.</p><p>If we&rsquo;re unfortunate, this might cause <em>very tiny shapes</em> (which are
barely visible). That&rsquo;s ugly and unplayable.</p><p>Therefore, we need to check if a shape is <em>too small</em> (by calculating
its area), and do something about that.</p><p>I see two different approaches:</p><ul><li><p>If too small, <em>don&rsquo;t allow the slice</em>. (Just pretend it didn&rsquo;t go
through the object.)</p></li><li><p>If too small, <em>destroy the second body</em> (that was sliced off).</p></li></ul><p>I eventually chose the second option, because it simplified the system
<em>and</em> allowed future gameplay possibilities:</p><ul><li><p>Getting sliced is always bad and works in predictable ways, which
means clarity and consistency.</p></li><li><p>The <em>smaller</em> your shape, the <em>slower</em> you move</p></li><li><p>You need a <em>minimum size</em> to finish. (Any time you get bitten by the
wolf chasing the sheep, you lose something. But during the game, you
can also find new pieces and grow yourself again.)</p></li></ul><p>Our last problem becomes: <strong>how do we approximate the area of a
polygon?</strong></p><p>There&rsquo;s no need to be precise. Most of these polygons will be
<em>triangles</em> or something close to it. What to do? We&rsquo;ll just pretend
they are a triangle and use the formula for calculating such an area:
0.5 * width * height</p><p>Then I just played with it, printed the areas of things I sliced off,
until I had an idea of what a good &ldquo;threshold&rdquo; was.</p><p>(In my case, it was higher than I expected. Because we&rsquo;re calculating an
<em>area</em>, even a tiny 10px by 10px square &mldr; has area 100. I settled on a
number around 400-500.)</p><h2 id=step-5-following-the-players>Step 5: Following the players</h2><p>We need a camera that always keeps <em>all parts</em> of <em>all players</em> in view.
Preferably it should:</p><ul><li><p>Stay zoomed in, so things don&rsquo;t get too small/far away</p></li><li><p>Also show what&rsquo;s &ldquo;up ahead&rdquo;</p></li><li><p>Not be janky or stuttery</p></li></ul><p>From earlier (local multiplayer) games, I&rsquo;ve learnt some hard lessons
about camera management. Namely, that you <strong>shouldn&rsquo;t try to create a
<em>camera</em> that keeps all players in view</strong>, but instead should <strong>create a
<em>game</em> that ensures all players stay together</strong>.</p><p>You have to think the other way around. Because no matter how hard you
try, if you allow players to get <em>far away from each other</em>, you&rsquo;ll
never find a camera setting that stays close and zoomed in.</p><p>And so I settled on the solution of <strong>locked-in sections.</strong></p><ul><li><p>The map consists of multiple &ldquo;sections&rdquo; placed after each other.</p></li><li><p>Each section <em>ends</em> with some sort of lock. This can be a physical
obstacle, a minigame you need to complete, anything that stops you
(for a while).</p></li><li><p>This lock ensures that, 99% of the time, the first players are
slowed down and the last players can catch up. If that doesn&rsquo;t
happen, <em>any player that&rsquo;s more than 1 section behind is simply
teleported forward</em>.</p></li></ul><p>In my opinion, this is the best solution.</p><ul><li><p>Players are never &ldquo;out of the game&rdquo;. (Either by being eliminated
<em>or</em> by being so far behind they can&rsquo;t practically win anymore.)</p></li><li><p>Players doing well (which are in front) are not <em>punished</em> for it.
Instead, they simply need to overcome <em>extra</em> challenges to maintain
their lead, while allowing other players to catch up a little.</p></li><li><p>Breaking the map into sections creates a nice, visible sense of
progress. You&rsquo;re never lost. You&rsquo;re never unsure about why you were
teleported forward. The sections give clear indication.</p></li></ul><p>In conclusion:</p><ul><li><p>The camera is simply placed on the <em>average</em> position of all
players, but <em>slightly</em> forward (to show what&rsquo;s coming.)</p></li><li><p>By calculating the <em>maximum</em> distance between players, I know how
far we need to zoom out to keep everyone in view.</p></li><li><p>That&rsquo;s it. The camera itself has no other logic, it&rsquo;s up to the
<em>game</em> to keep all players nicely together.</p></li></ul><h2 id=step-6-creating-the-map>Step 6: Creating the map</h2><p>At first, I wanted to make a game that only goes to the right. (Which is
typical with these kinds of &ldquo;runner&rdquo; or &ldquo;platformer&rdquo; games.)</p><p>This, however, presents several issues:</p><ul><li><p>If you have good speed, you&rsquo;ll just <em>fly</em> forward and nothing can
really stop you. (Because you only need to go right, is there any
reason to slow down or roll to the left?)</p></li><li><p>It makes it <em>much harder</em> to keep all players in view. (We&rsquo;d have
loads of unused space <em>vertically</em>, whilst players are far apart
<em>horizontally</em>.)</p></li><li><p>After a while, if we go to the right long enough, we run into those
same &ldquo;floating point precision&rdquo; errors, because our coordinates are
just too large.</p></li></ul><p>That&rsquo;s why I decided to make a map that is more like a <em>maze</em> and can go
in any direction.</p><p>This is the idea:</p><ul><li><p>Predefine a &ldquo;world size&rdquo;. (For example: max 100 tiles wide and 100
tiles high.)</p></li><li><p>Start at the top left corner.</p></li><li><p>Create a random route through this world, ensuring that &mldr;</p><ul><li><p>All of it is reachable</p></li><li><p>It is long enough to warrant a full level</p></li><li><p>It&rsquo;s broken into these <em>sections</em></p></li></ul></li><li><p>Place a finish at the end</p></li></ul><p>My first instinct is always to reach for some <em>perfect</em> algorithm to
generate a <em>maze</em> or something. That&rsquo;s just how programmers work :p But
I&rsquo;ve learnt over the years that trying a na√Øve/dumb/simple solution
first is usually <em>all you need</em>.</p><p>(Additionally, we don&rsquo;t need or want a <em>maze</em> for this game. It is <em>side
view</em>. Gravity is always pulling us down. We can only roll (with random
shapes). Preferably, the route will mostly flow downwards and switch
between left&lt;=>right once in a while.)</p><p>All we need is:</p><ul><li><p>A route that regularly changes direction</p></li><li><p>And that keeps players together, so we don&rsquo;t need to zoom out a lot</p></li></ul><p>Well then, <em>let&rsquo;s only fulfill those wishes</em> and <em>nothing more.</em></p><p>There&rsquo;s <em>no need</em> to generate a full map beforehand. There&rsquo;s <em>no need</em>
for the route to make sense. (We can just re-use a location we&rsquo;ve
already been later on, with a completely new room.)</p><p>This is the idea:</p><ul><li><p>Check where the first (&ldquo;leading&rdquo;) player is</p><ul><li>When they move into a new room, we immediately instantiate a
<em>new room</em> at the very end. (This way, we build the map as we
go, ensuring players can always move forward.)</li></ul></li><li><p>Also check where the last (&ldquo;trailing&rdquo;) player is</p><ul><li>When they move out of a room, there&rsquo;s no use for it anymore, so
remove it.</li></ul></li><li><p>When picking a new direction for the next room &mldr;</p><ul><li><p>The longer we&rsquo;ve been going straight, the higher the probability
of changing direction</p></li><li><p>Prefer a direction that keeps all players in view.</p></li><li><p>After placing new rooms X times, we <em>end</em> the current section
(with such a &ldquo;locking mechanism&rdquo;).</p></li></ul></li></ul><p><strong>Remark:</strong> and when we simply cannot place a new room? We stop there.
We place a <em>teleport</em> or something. It waits until everyone has arrived,
and then we simply <em>zoom</em> to a new level/part completely.</p><h3 id=does-this-work>Does this work?</h3><p>Yes. It works great!</p><p>It&rsquo;s not that hard to program, whilst allowing the game to basically be
as varied (and <em>endless</em>) as possible.</p><p>(Additionally, it&rsquo;s great for performance, as there will only be ~10
chunks in the game at a given time. But that really won&rsquo;t matter much,
unless I decide to port this game to mobile.)</p><p>There&rsquo;s only <strong>one issue left: how do we select/place rooms?</strong> How do we
ensure a room fits onto the previous one, and there&rsquo;s always a path
forward?</p><p>I&rsquo;ve done this in the past with this approach:</p><ul><li><p>Each room has several openings</p></li><li><p>I save these locations in the room. (For example: openings left =
index 2 and 4.)</p></li><li><p>When selecting a new room, we simply pick one that <em>has the right
opening</em>.</p></li></ul><p>This works well. But those previous projects were different from this
one, given that:</p><ul><li><p>There was no need to create a single route. As such, rooms often had
<em>multiple openings</em> going in multiple directions.</p></li><li><p>Rooms had to keep their orientation. (I couldn&rsquo;t <em>rotate</em> them, for
example, to match them.)</p></li></ul><p>So, we need to modify the approach for this game:</p><ul><li><p>When matching edges, we <strong>are</strong> allowed to rotate the room. (There&rsquo;s
no reason not to.)</p></li><li><p>Any edge we <strong>do not</strong> connect, is closed.</p><ul><li><p>When a new room is placed &mldr;</p></li><li><p>We check all openings in the <em>previous</em> room, ignoring the ones
we actually used.</p></li><li><p>For each one left, we place a solid block on that location to
&ldquo;fill&rdquo; the gap.</p></li></ul></li></ul><h3 id=what-are-rooms-actually>What are &ldquo;rooms&rdquo;, actually?</h3><p>I notice I&rsquo;ve been saying &ldquo;room&rdquo; all the time, without giving a clear
example what that entails. That&rsquo;s partly because <em>I</em> wasn&rsquo;t sure yet.</p><p>Now I can explain this a bit better.</p><p>Each &ldquo;room&rdquo; is a block of grid tiles (probably 4x4) that has <strong>one
unique challenge or mechanic</strong>.</p><ul><li><p>The most basic room is just empty.</p></li><li><p>But an &ldquo;obstacle room&rdquo; might be filled with all sorts of bodies
you&rsquo;d need to navigate through.</p></li><li><p>And when you&rsquo;re in the &ldquo;glue room&rdquo;, you&rsquo;re able to glue yourself
back together (if two of your pieces touch each other).</p></li></ul><p>By chaining these rooms together, you are constantly presented with new
challenges to overcome, as you progress towards the finish.</p><p>Additionally, it gives me great <em>control</em> over what appears and how
often. (You wouldn&rsquo;t want a game that, by pure chance, consisted of 100%
glue rooms and nothing else.)</p><h2 id=step-7-trying-something-completely-different>Step 7: Trying something completely different</h2><p>So I implemented everything I talked about in the previous section. And
I tested it. And I played it.</p><p>And it &mldr; just didn&rsquo;t work. These are the reasons (I think):</p><ul><li><p>Gravity is always down. As such, most of the game you&rsquo;re just
<em>falling down through a bunch of rooms</em>.</p></li><li><p>It created quite a static layout that wasn&rsquo;t very pleasing.</p></li><li><p>There&rsquo;s no way to go upward, or jump, or anything. You can only
<em>roll left and right</em>.</p></li></ul><p>It&rsquo;s much better if</p><ul><li><p>Players have some <em>solid (horizontal) ground</em></p></li><li><p>Moving down/up only happens sporadically. (And if it happens, you
get support for it. Like a trampoline on parts going up.)</p></li><li><p>Players can <em>roll onto walls</em>. (So when you roll into a wall, you
<em>cling</em> to it, so you can follow it.)</p></li></ul><p>So let&rsquo;s turn it around.</p><ul><li><p>The map is one big <em>chunk of blocks</em> at the start.</p></li><li><p>Instead of placing new rooms, we just <em>erase</em> part of the blocks.
(Essentially creating something like a cave or tunnel through the
map.)</p><ul><li>(Conversely, instead of deleting rooms on the tail end, we just
<em>fill it back up</em>.)</li></ul></li><li><p>Regularly, we change the width of that eraser. (Sometimes it removes
blocks 2 wide, sometimes 1 wide, sometimes 3, etc.) We also randomly
add an &ldquo;offset&rdquo; so new rooms don&rsquo;t all start at the exact same
level.</p></li><li><p>When changing width, we add <em>slopes</em> to make it gradual.</p></li><li><p>(The probability of moving vertically is much lower than moving
horizontally.)</p></li></ul><h3 id=did-that-work>Did that work??</h3><p>Yes! It did! (In hindsight, it&rsquo;s obvious this was the better choice. But
hey, lessons learned.)</p><p>Now players can actually roll onto stuff. They stay contained within the
grid, while having more than enough space to maneuver. The routes are
varied and can already be quite challenging. (This is <em>before</em> I
implemented nice slopes and clinging to walls.)</p><p>It&rsquo;s surprisingly <em>rare</em> that the generation fails. (It has painted
itself into a corner and can&rsquo;t get out.) If it happens at all, it&rsquo;s
usually after 30-60 seconds of playing, which is already a good length.</p><p>So, how exactly <em>do</em> we add slopes between height differences?</p><ul><li><p>When erasing a new part, check all cells within that section <em>+
their border</em>. (So, increase the room size by 1, then check all
cells within that rectangle.)</p></li><li><p>For each cell that has:</p><ul><li><p>Exactly two neighbors, which are <em>not</em> opposite each other, add
a slope.</p></li><li><p>(If the neighbors are opposite each other, this is the perfect
location to place a door or a laser or something. But that&rsquo;s for
a later moment.)</p></li></ul></li></ul><p><strong>Remark:</strong> Rotating the slope correctly is a minor implementation
detail (which depends on how Godot handles tilemaps and how I happened
to draw the slope), so I won&rsquo;t bore you with that. Also because &ndash; and
this is me from the future &ndash; I ended up using a different system anyway
(&ldquo;autotiling&rdquo;).</p><p><strong>Remark:</strong> technically, we only need to check the <em>border</em> right now,
not the inside of the room. However, as I plan to <em>use</em> the empty space
inside for things, I already set up the loop to check those as well.</p><p><strong>Remark:</strong> we <em>also</em> check for existing slopes that have become
useless. Because we placed a new room, the environment changed, so older
slopes might not be needed anymore.</p><h3 id=in-conclusion>In conclusion</h3><p>Right now, we have randomly generated maps which are fun, playable, and
even finishable (with our limited toolset).</p><p>It still crashes whenever it can&rsquo;t find a solution, but we&rsquo;ll solve that
soon.</p><p>For now, I want to add several more (interesting) ways for movement &mldr;</p><h2 id=step-8-better-movement>Step 8: Better movement</h2><p>Right now, you can <em>roll left</em> and <em>roll right</em>. Because we&rsquo;ve added
slopes, this already gets you quite far.</p><p>But you still can&rsquo;t go up. And you still get stuck on high vertical
jumps/obstacles.</p><p>I see <em>two</em> interesting things to add:</p><ul><li><p><strong>Clinging to walls =></strong> whenever you roll against a wall (with
enough force/close enough), you stick to it</p></li><li><p><strong>Jumping</strong> => whenever you <strong>release both buttons simultaneously</strong>,
you jump.</p></li></ul><p>Jumping is simple to implement: apply a force <em>away</em> from the ground.</p><p>Clinging is, interestingly, kind of the opposite. Use a <em>raycast</em> to
detect whether we hit something next to us and the <em>normal</em> of that
collision. Then apply a (strong) force <em>in the direction of that
normal</em>, pushing us into the object.</p><p>Because of the default &ldquo;friction&rdquo;, this causes us to stick against the
surface and roll along it.</p><p>At first, I created a bit of a &ldquo;rough&rdquo; implementation of both features.
Jumping was endless (you didn&rsquo;t need to be touching the ground).
Clinging only happened horizontally (if a wall was to the left/right of
you).</p><p>But &mldr; experimenting with this led to some amazing insights! With this
system, you could:</p><ul><li><p>Cling to a wall and then <em>stand still</em></p></li><li><p>Press <em>jump</em> to release yourself again.</p></li></ul><p>Not only was I able to finish <em>any</em> route this way (with some trial and
error), it just felt <em>cool</em>. It felt cool to roll up to something, then
stand still in mid-air, waiting for the perfect moment, then launch
myself again.</p><p>If I can perfect <em>those</em> behaviors, this game will certainly be fun to
play.</p><p>Additionally, there&rsquo;s not much more to do here. We only have two
buttons. They each do something separately, they do something combined,
<em>all my inputs are taken.</em> So, any more variety/mechanics shall have to
come from the levels themselves and the elements within them.</p><h2 id=step-9-making-the-first-finishable-level>Step 9: Making the first finishable level</h2><p>What do we need to make a first finished, playable prototype?</p><ul><li><p>A finish => reaching it first, with <em>all</em> your pieces, wins you the
game.</p></li><li><p>A &ldquo;section lock&rdquo; system &ndash; breaking the route into pieces, keeping
it all manageable and on-screen.</p></li></ul><p>That&rsquo;s it! So let&rsquo;s make that and then <em>test the game</em>.</p><p>Creating the <em>section lock</em> and a <em>teleporter</em> (in case you were stuck)
were relatively easy. I simply:</p><ul><li><p>Place a large room</p></li><li><p>Wall it off with edges, except for the direction you came from.</p></li><li><p>Add a &ldquo;module&rdquo; (just a script and some objects) with a certain
minigame</p></li><li><p>Once completed, the edges are removed and you can continue</p></li></ul><p>For teleporters, the same is true, but once all players have arrived
<em>the route restarts completely somewhere else</em> and <em>players are
teleported there.</em></p><p>However &mldr; the question of &ldquo;how exactly do you win?&rdquo; haunted me during
that period.</p><p>At first, saying something like &ldquo;reach the finish with <em>all</em> your
pieces&rdquo; seems great.</p><p>But there are problems. This encourages players to <em>lose everything</em>
(and destroy themselves), because it&rsquo;s much easier to get through
obstacles if you have only <em>one tiny piece</em>.</p><p>At the same time, if you are split between a few pieces, it might be
really hard to bring them all to the finish. One of them might be stuck
somewhere, and there might be no way to get it out. And because it&rsquo;s
stuck somewhere in the back, the camera needs to zoom <em>way out</em>, and the
route generation gets stuck (because there&rsquo;s no space).</p><p>It&rsquo;s just not great.</p><p>I want to change it to the simple objective: &ldquo;finish to win&rdquo; Just one
piece. Get one piece over the finish (first) and you win.</p><p>Of course, this still has the first issue: the best strategy is to
always destroy yourself.</p><p>How do you solve that?</p><ul><li><p>Option 1: <em>penalize</em> this behavior</p></li><li><p>Option 2: add <em>other</em> strategies that are just as viable (or even
better)</p></li></ul><p>Penalizing is annoying. It can easily lead to frustration and a &ldquo;stale
game&rdquo;. So the second option will have to be used 90% of the time.</p><p>But it&rsquo;s a party game. I don&rsquo;t want to teach new players &ldquo;these are the
4 ways to win&rdquo;. No, the objective needs to be that simple one-liner:
reach the finish first.</p><p>Instead, I will try to (invisibly) <strong>nudge players in the right
direction</strong> by being smart about what elements I place.</p><p>For example, let&rsquo;s say I want to encourage players to stay big. How do
we do that?</p><ul><li><p>Idea: Being big makes you faster</p></li><li><p>Idea: Add a &ldquo;lock&rdquo; or &ldquo;gate&rdquo; you can only pass if you&rsquo;re large.
(Otherwise it takes a while, or it&rsquo;s harder.)</p></li><li><p>Idea: you can <em>slice</em> other players by bumping into them. The bigger
you are, the higher the probability of successfully slicing someone
else.</p></li></ul><p>I don&rsquo;t need to <em>teach</em> these things or <em>explain</em> them specifically.
Just place them in the game/in a level. Yet they give players a reason
to vary their strategy and try new things.</p><p>That&rsquo;s what I&rsquo;ll implement now: you win if you reach the finish first.
Any part of you.</p><p><strong>Remark:</strong> of course, I could add powerups later that modify this. A
&ldquo;time penalty&rdquo;, for example. Or a &ldquo;curse&rdquo; that requires you to finish
all your pieces anyway.</p><h2 id=step-10-better-routes>Step 10: Better Routes</h2><p>Right now, there&rsquo;s quite a large probability of getting stuck (and
having to place a teleporter). Even if I can clearly see some free
routes that could be taken.</p><p>I want to lower this probability of placing teleporters <em>as much as
possible</em>. (It&rsquo;s more fun if the route keeps flowing and players aren&rsquo;t
stopped artificially.)</p><p>To do so, I tried these techniques. If we can&rsquo;t place anything &mldr;</p><ul><li><p><em>Reduce the room size</em>. (Because a room of size 1x1 most likely
<em>can</em> be placed, even when a 3x3 one cannot.)</p></li><li><p><em>Backtrack</em>. Try to attach a new room <em>earlier</em> in the route.
Continue backtracking until you find something, <em>or</em> you&rsquo;ve reached
the room that holds the current leading player.</p></li><li><p><em>Loosen the restrictions</em>. Normally, I disallow overlapping <em>and</em>
adjacent rooms. But if we seem stuck, I can start allowing adjacent
rooms. And if we&rsquo;re still stuck, I can allow some overlap.</p></li></ul><p>This improves it somewhat. It&rsquo;s not <em>amazing</em>, but it&rsquo;s a good start and
yields good routes for now.</p><p>By loosening the restrictions, and allowing rooms to overlap, I did
create an extra problem: it&rsquo;s not <em>clear</em> what the route is anymore.
What way is forward? Sometimes you don&rsquo;t know.</p><p>After some experimentation, I found the best solution was simply to
allow this, but <em>add edges (&ldquo;outlines&rdquo;) around the rooms</em> (like I did
with the locks) This way, it&rsquo;s still clear what the rooms are and what
path you should take.</p><p>In a general sense, I learned: using <strong>edges</strong> to separate stuff
requires less space than using <strong>full blocks</strong> to do so. So maybe I&rsquo;ll
use this tactic way more.</p><p>Another thing I learned, just from playing/testing the mechanics so far,
is that:</p><ul><li><p>Clinging to walls should <em>not</em> be automatic. It&rsquo;s too strong for
that, which makes some parts ridiculously easy, and others (near)
impossible. It should only be activated on certain areas.</p></li><li><p>The less &ldquo;round&rdquo; your shape, the less you&rsquo;re able to roll. (Which is
obvious, I know, but &mldr;) The difference is <em>so big</em> that it&rsquo;s
basically impossible to move well if you&rsquo;re not <em>somewhat like a
circle</em>. I should invent something to &ldquo;help&rdquo; the flatter shapes, I
think.</p></li></ul><h2 id=step-11-throwing-sand-against-the-wall>Step 11: Throwing sand against the wall</h2><p>And now we&rsquo;re at the point where I simply <strong>implement a bunch of stuff I
thought of</strong>. Then I check what works best, and what doesn&rsquo;t, and keep
the best things.</p><p>(For example, I invented ~10 terrain types, a few ideas for powerups,
and a few general game rules. I can&rsquo;t <em>predict</em> what will be the most
fun. Nor do I know the best <em>order</em> in which to teach them to players.
So I just implement all of it (as quickly as possible) and then <em>test</em>.)</p><p>The results?</p><ul><li><p>Most of my ideas work great! They are a fun challenge, without just
being impossible or impossible to understand.</p></li><li><p>Nevertheless, I <em>do</em> need to finetune physics parameters. And I <em>do</em>
need to restrict terrain placement to avoid some bad situations.</p><ul><li>(For example, if the room goes <em>down</em> it&rsquo;s extremely annoying if
it has a <em>reverse gravity</em> terrain. Because it constantly pushes
you up, it&rsquo;s near impossible to get through this room.)</li></ul></li><li><p>By implementing these things, I&rsquo;ve generated tons of new ideas. I
also learnt that I should probably simplify the game. (Now there
are: terrains, powerups, locking rooms, and obstacles/items. Perhaps
the last three should all just be shoved under &ldquo;special room&rdquo;.)</p></li><li><p><strong>And the route generation &mldr; needs a serious rewrite.</strong></p></li></ul><p>In this period, I also implemented many other features I would need
anyway:</p><ul><li><p>The camera cannot show anything out of bounds. (So no ugly spaces
outside of the grid if we&rsquo;re zoomed out.)</p></li><li><p>There are &ldquo;light circles&rdquo; around players, the rest is dark.</p></li><li><p>I implemented &ldquo;autotiling&rdquo; with prettier tiles. It means that my
game engine automatically chooses the correct sprite based on
surrounding sprites, so it all connects well and looks good (and
organic).</p></li><li><p>I implement &ldquo;catch up mechanics&rdquo;. If you&rsquo;re too far behind, you are
teleported forward. If you&rsquo;re not moving for 10+ seconds, same
thing. All of this, obviously, has a cost in the form of a <em>time
penalty</em>.</p></li></ul><h2 id=step-12-better-routes-for-real-now>Step 12: Better routes, For real now</h2><p>The current route generation algorithm is &ldquo;fine&rdquo;. But now that the game
has evolved, this isn&rsquo;t enough anymore, and I have requirements it
cannot meet.</p><p>(Additionally, the <em>actual route</em> is <em>the backbone of this game</em>. It&rsquo;s
the most important thing. It&rsquo;s what makes or breaks the game. I think
it&rsquo;s more valuable to spend extra time here, than try to cover it up
later with all sorts of powerups or other mechanics.)</p><p>To remind ourselves, here&rsquo;s how the current algorithm works (in
simplified form):</p><ul><li><p>Get the last room we placed.</p></li><li><p>Try to place rooms of random size in random directions <em>next to this
room</em></p></li><li><p>Once we find something, place it.</p></li><li><p>If we haven&rsquo;t found something after loads of tries, it&rsquo;s clearly
impossible, so place a teleporter and stop there.</p></li></ul><p>This has the following problems:</p><ul><li><p>Trying this algorithm <em>thousands of times</em> is very resource
intensive and introduces lag/stutter.</p></li><li><p>Additionally, there&rsquo;s no <em>guarantee</em> that it finds something
sensible. If we&rsquo;re out of luck, it only tries stupid configurations
that would never work, and misses the obvious one.</p></li><li><p>It&rsquo;s terrible at using the space it has. (Often it has <em>loads</em> of
space on the right &mldr; and only places a 1x1 room before going
left.)</p></li><li><p>It&rsquo;s hard to control this with extra requirements, such as &ldquo;no more
than 2 rooms vertically after each other&rdquo;.</p></li></ul><p>This got me thinking. I&rsquo;ve implemented a &ldquo;grow rectangle&rdquo; function,
which is <em>fast</em> and already <em>used a lot</em>.</p><p><strong>Insight #1:</strong> why don&rsquo;t we start each room at size 1x1, and then
simply <em>grow</em> it until it hits something? (Or reaches a maximum size of
6x6; we don&rsquo;t want humongous rooms spanning the entire world.)</p><p>This would guarantee we use <em>as much space as possible</em>. Additionally,
we don&rsquo;t need to retry the same location at different sizes, as this
<em>will already have happened</em>.</p><p>Which got me thinking again. When you look at a rectangle &mldr; there are
only a limited number of spots to place an adjacent rectangle, aren&rsquo;t
there? Currently, we&rsquo;re running this loop <em>hundreds</em> of times &mldr; but
there aren&rsquo;t even that many options. Not even close.</p><p>Let&rsquo;s calculate an example. Our current room is a 2x2 rectangle. We are
trying to place a 3x2 rectangle next to it. (Which are &ldquo;medium size&rdquo;.)
Then we only have &mldr; 14 possibilities.</p><p><figure class=inline-image><picture><img src=devlog-allpossibleplacements.webp loading=lazy decoding=async alt="All possible room placements for random generation" title="All possible room placements for random generation" width=574 height=191></picture><figcaption class=side-note><span>All possible room placements for random generation</span></figcaption></figure></p><p><strong>Insight #2:</strong> just generate a list of <em>all</em> possibilities at the
start, filter those we do not want, and pick the best option.</p><p>It should be much faster, we shouldn&rsquo;t miss (good) options, and it&rsquo;s
easier to manipulate with extra requirements. (Even on two huge
rectangles, the number of possibilities is below 50.)</p><p>And that&rsquo;s what I did.</p><p><strong>Remark:</strong> I also took the time to clean up the <em>map</em> and <em>room</em>
scripts. Both were just one giant script with 1000 lines of code at this
point, doing <em>everything</em>. Now each of them has about 8 &ldquo;modules&rdquo; that
do just <em>one</em> thing in ~50 lines of code.</p><p><strong>Remark:</strong> interestingly, when I started this project, I didn&rsquo;t know I
would be using this concept of &ldquo;placing rectangles&rdquo;, and thought the
route would just be a series of 2D points. Hence, the <em>main variable in
the game</em> (&ldquo;path&rdquo;) was saving <em>coordinates</em>, not the <em>rooms themselves</em>.
Over time, this led to hundreds of lines of code like:</p><p>&ldquo;var my_room = get_room_at(get_location_at(get_my_index()))&rdquo;</p><p>Which is just horrible. Saving the <em>rooms</em> in that list instead, saved
me tons of code. Yet I would never have made that &ldquo;obvious&rdquo; optimization
if I didn&rsquo;t completely rewrite and restructure this script.</p><p><strong>The results?</strong> Again, works wonderfully, and it&rsquo;s stupid (in
hindsight) that I didn&rsquo;t try this first. Using these tweaks, I was able
to increase the <em>quality</em> and <em>performance</em> of the maps in the game:</p><ul><li><p><strong>Controlled variation</strong> => Take an average over the last 5 rooms.
The bigger those were, the smaller we must be. (This means the route
alternates between tighter sections and huge open spaces.)</p></li><li><p><strong>Preferred movement</strong> => check directions in this order: continue
horizontally, go in opposite horizontal direction, go down, go up.
Usually, the first direction yields a result fast.</p></li><li><p><strong>Stay away from edges</strong> => if close to the edge, simply <em>do not
consider that direction at all</em>. (Saves a lot of performance.)</p></li><li><p><strong>Sneak peek</strong> => The game would lag/stutter when there was <em>loads
of open space in front of us</em>. Because it would try every rectangle
and then grow all of them until maximum size, before making a
decision. As such, before starting the algorithm, I try <em>one</em> room
at maximum size (with some random size/displacement). If that fits,
great, just use that.</p><ul><li><p>This is a way bigger improvement than you&rsquo;d think. In about 75%
of the cases, it saves us all the computations of the algorithm
(hundreds of rectangles to create and check), while placing the
ideal room.</p></li><li><p>And because I control the &ldquo;maximum size&rdquo;, it works for big rooms
and small rooms alike.</p></li></ul></li></ul><p><figure class=inline-image><picture><img src=debug_sheepe_5.webp loading=lazy decoding=async alt="One of the rare screenshots I made during development" title="One of the rare screenshots I made during development" width=1900 height=975></picture><figcaption class=side-note><span>One of the rare screenshots I made during development</span></figcaption></figure></p><p>I disabled some things for the image here, such as the lighting effect.
I feel like it shouldn&rsquo;t be so dramatic. Or only used during &ldquo;night
time&rdquo; sections, or something like that.</p><p>Another thing I disabled was my algorithm for adding slopes in 90 degree
corners, because it stopped working after this update. Speaking of that
&mldr;</p><h2 id=step-13-better-slopes--inner-tiles>Step 13: Better slopes + &ldquo;inner tiles&rdquo;</h2><p>Now that we have <strong>big rooms</strong> (consistently, in a controlled way) I can
<strong>fill the rooms</strong> with things!</p><p>The easiest first step is to fill them with <em>more tiles</em>. (Which might
split the room into two, or add a few islands, or something like that.)
However, we don&rsquo;t want these to block entry to the room.</p><p>As such, we need a function that:</p><ul><li><p>Given a position in a room</p></li><li><p>Checks whether any of the <em>neighbor</em> tiles are part of a <em>different
room</em>.</p></li><li><p>If so, disallow that position.</p></li></ul><p>Once we have this, we can <strong>also</strong> use it for adding back slopes!
(Because, again, in a &ldquo;rolling game&rdquo; we want as many smooth transitions
as possible.)</p><p>This works great, as you can see here:</p><p><figure class=inline-image><picture><img src=debug_sheepe_6.webp loading=lazy decoding=async alt="Adding slopes" title="Adding slopes" width=1898 height=966></picture><figcaption class=side-note><span>Adding slopes</span></figcaption></figure><figure class=inline-image><picture><img src=debug_sheepe_7.webp loading=lazy decoding=async alt="Adding slopes again" title="Adding slopes again" width=1829 height=979></picture><figcaption class=side-note><span>Adding slopes again</span></figcaption></figure></p><p>Because anything <em>outside</em> the room is <em>also</em> &ldquo;a different room than
us&rdquo;, none of the tiles are placed against the edge, ensuring we have a
path through the room.</p><p>Of course, for variety&rsquo;s sake, I <em>could</em> allow this as well. But this
has to remain a &ldquo;One Week Game&rdquo; and I&rsquo;m stopping here.</p><h2 id=some-tricks>Some tricks</h2><p>I <em>did</em> end up having to implement an extra trick.</p><p>Because of the &ldquo;autotiling&rdquo; system (and adding slopes), it happened
quite often that you could enter a cell (with a slope) &mldr; that didn&rsquo;t
belong to any room.</p><p>It was ugly, it was messy, yet I really wanted to keep the smooth
slopes.</p><p>So, from now on, each room <em>is actually one size bigger than it
appears</em>. This allows me to paint the terrain correctly <em>and</em> always
know which room a player is in. But when it comes to (visually) placing
the room, I use the <em>shrunk version</em>, which is just one size smaller. So
everything looks the same as before, just much cleaner (and bugfree)
under the hood.</p><p>Another trick had to do with <em>performance</em>. Right now, I checked whether
I needed to add a new room <em>every frame</em>, and checked whether I had to
delete a room in the same function.</p><p>Of course &mldr; if players were speedy, this meant <em>every frame, loads of
rooms were being added and deleted</em>. Which caused huge stuttering.</p><p>To solve it, I simply put it on a timer. It only checks if it should
update once every second. And it checks it <em>separately</em> for removing and
adding rooms ( = two separate timers that never fire in the same frame).</p><p>(Because removing a room is just as heavy (performance-wise) as adding
one. It needs to remove all the terrain tiles, fill the space with solid
tiles, update all entries in the map, remove itself from the path, and
overwrite <em>many</em> pixels in the terrain mask.)</p><h2 id=step-14-running-with-the-wolves>Step 14: Running with the wolves</h2><p>When I started this game idea, I thought of it as an &ldquo;endless runner&rdquo;.</p><p>You were sheep. A <em>wolf</em> would be chasing you, always from the left. And
if it caught up with you, you died.</p><p>Now that the maps are <em>more varied</em>, it&rsquo;s impossible for me to write a
&ldquo;computer player&rdquo; (aka the wolf) that follows the players around.
Additionally, such a wolf would only <em>punish</em> players who are already
behind.</p><p>Instead, I invented the following idea: <strong>the last player <em>becomes</em> the
wolf.</strong></p><p>When you&rsquo;re in last place, you turn into the wolf. You become faster,
can skip certain challenges, but most importantly: <strong>hitting another
player takes a bite out of them.</strong> (Which, most likely, causes them to
fall behind and become the wolf.)</p><p>It will be a constant driving force, pushing you forward and making you
take risks. But it&rsquo;s not controlled by the computer or manually
programmed by me. It&rsquo;s a player, which is way better.</p><p><strong>Remark:</strong> in <em>single player</em> mode, you obviously can&rsquo;t have this. I
think single player mode will either be <em>survive as long as possible</em> or
<em>finish in the shortest time possible</em>. But I need to think about that
some more.</p><p>Of course, it had to be toned down a little. After biting, it takes a
second before it can bite again. (In general, if a &ldquo;bite&rdquo; would result
in a player losing all their bodies <em>or</em> becoming too small, it doesn&rsquo;t
go through.)</p><p>And the wolf has to be <em>way</em> more visible than it currently is. I just
drew a very quick sprite to test it.</p><p><strong>Remark:</strong> when testing this behaviour, I was constantly disappointed
about how &mldr; ugly it looked? Just boring and &mldr; weird. Then I
realized: slicing a body is quite an operation. It shouldn&rsquo;t be this
surgical precision slice, it should be more like an <em>explosion</em>. So I
added a <em>force</em> that pushes the new blocks away from each other (after
slicing). This solved <em>so many issues</em> and made it look much better in
general.</p><h2 id=step-15-the-rolling-factor>Step 15: The Rolling Factor</h2><p>All this time, I&rsquo;ve been thinking: &ldquo;the game is called <em>rolling in the
sheepe</em>, it&rsquo;s about rolling &mldr; yet I spend an awful lot of time in the
air&rdquo;</p><p>Why? Because non-circular shapes are just really hard to roll. (And most
powerups/rooms, for now, require jumping to solve.)</p><p>And then it hit me. A new rule for the game that would be amazing, if it
worked.</p><p><strong>Rule: the <em>more you roll</em>, the <em>more round your shape becomes</em>.</strong>
(Conversely, the more time you spend in the air, the more it deforms.)</p><p>It took quite a while to implement this properly, as I&rsquo;d never done
anything like it before. But this is how it works:</p><p>General module:</p><ul><li><p>Each frame, I track if you&rsquo;re in the air or not. (Which simply
means: are you touching terrain or not.)</p></li><li><p>After a few seconds, I take an average from that.</p></li><li><p>If you&rsquo;ve been in the air 50% of the time (or more), you deform</p></li><li><p>Otherwise, you become more round</p></li></ul><p>To become more round:</p><ul><li><p>Check the total number of points in the shape. If it&rsquo;s below 5,
you&rsquo;re a rectangle and can&rsquo;t be round. So, I &ldquo;enrich&rdquo; the shape by
adding a new point halfway each existing edge.</p></li><li><p>Loop through the points and make them global. (By default, these are
local to their own center.)</p></li><li><p>Approximate the radius of the body. (Simply get the approximate
area. For a circle, A = pi r^2, so r ~= sqrt(A/pi).)</p></li><li><p>Calculate their <em>angle</em> and <em>distance</em> to the center of the body.</p></li><li><p>Move the point to stay at the same angle, but with its distance
closer to the <em>radius</em> of the body. (In other words, each point
moves closer to the position <em>it would be</em> if the body were a
perfect circle.)</p></li></ul><p>Do this a few times (for about 30 seconds), and your body has become a
(near) circle.</p><p>After a while, I noticed this has issues if points are really close to
each other (on the original shape). This would prevent the shape from
rounding well, as they all moved to the same new location.</p><p>Solution? I <em>snap</em> the angle to the 8 predefined directions (horizontal, vertical
and diagonals), ensuring that most of the points will space out around
the circle.</p><p>For deforming shapes, I did the opposite: move points to a rectangle.
(In this case, I already have the <em>bounding box</em> of each shape, so I can
just move points towards that.)</p><p>This is <em>fine</em>, but a rectangle is also quite a smooth shape. Which
means it doesn&rsquo;t really &ldquo;deform&rdquo; you, it merely &ldquo;gives you sharper
corners&rdquo;. I&rsquo;ll have to see what I do with that.</p><p><strong>Remark:</strong> I switched my area approximation code to the <strong>Shoelace
algorithm (by Gauss)</strong>. It&rsquo;s just as fast, but <em>way</em> more accurate.
Didn&rsquo;t know it existed before now :p</p><p>I want to do even more with rolling, like buttons you can only activate
by rolling over them. (And I have to become worried about performance at
this point &mldr; manipulating dozens of physics shapes constantly.)</p><h2 id=step-16-rolling-with-the-punches>Step 16: Rolling with the punches</h2><p>By now, I&rsquo;ve made these comments several times:</p><ul><li><p>I should do more with the fact that you&rsquo;re rolling.</p></li><li><p>The game should be simplified so much that anyone can play. If I
have to, the first level should just be <em>pressing one button</em> (to
roll right).</p></li><li><p>I have way too many different mechanics outlined (terrains,
obstacles, special rooms, powerups floating in said rooms, things
that can protrude from the terrain &mldr;) These should be streamlined
and simplified.</p></li></ul><p>Just now, finishing all the previous tasks, I had an insight.</p><p>I&rsquo;ve done all this work to ensure a route that flows smoothly, where you
can always reach everything, with enough space between rooms to fill it
with solid tiles.</p><p>This means that there is <strong>one place where I can always put something
special: inside tiles.</strong></p><p>Coincidentally, rolling is also something you do <strong>on a tile.</strong></p><p>Which led me to the following &ldquo;rule&rdquo; for this game: <strong>all special
elements are simply an extension of an existing tile.</strong></p><ul><li><p>Want to place spikes? Find an existing tile and place the &ldquo;spikes&rdquo;
object on top of it.</p></li><li><p>Want a button? Find an existing tile and place a &ldquo;button&rdquo; object on
top of it.</p></li></ul><p>This means <em>no</em> powerups (or other obstacles) just floating in mid-air.
Which is great, as it gives us back some clarity and space. (Especially
when players are sliced up, in smaller rooms, it becomes <em>quite full</em>.)</p><p>This means <em>no</em> special cases for certain elements, like a laser that
spans the full width of the column. (Instead, I can repurpose that to
the new system: I can stick a laser gun into the wall, protruding just
slightly. Once in a while, it <em>shoots</em> that laser across the room. Same
functionality, but the underlying code and mechanics stay consistent
everywhere.)</p><p>So, how do we create a system like that?</p><ul><li><p>Pick some &ldquo;special thing&rdquo; we want to place</p></li><li><p>Get a list of all tiles within our room.</p></li><li><p>Pick a random one. Look at its neighbors to find an open side.</p></li><li><p>Check if it&rsquo;s a slope. (If so, our sprite just needs to rotate to
match the angle.)</p></li><li><p>Place the thing at the desired location and rotation</p></li><li><p>(Remember it was placed there, so we remove it properly when the
room is removed.)</p></li></ul><p>Here&rsquo;s what that looks like. (Ignore my extremely crappy art for the
spikes, I needed something to test.)</p><p><figure class=inline-image><picture><img src=debug_sheepe_10.webp loading=lazy decoding=async alt="Special elements (in this case, spikes) are just an extension of existing filled tiles" title="Special elements (in this case, spikes) are just an extension of existing filled tiles" width=1878 height=962></picture><figcaption class=side-note><span>Special elements (in this case, spikes) are just an extension of existing filled tiles</span></figcaption></figure></p><p>That was quite easy. Should work well.</p><h3 id=realistic-slicing-is-too-realistic>Realistic slicing is too realistic</h3><p>The title of this section, therefore, refers to something else. No
matter what I tried, I noticed a few core elements of the game just
<em>weren&rsquo;t fun</em>. I&rsquo;m happy I figured out how to do it, and maybe I&rsquo;ll use
the technique in some other game.</p><p>But the whole <strong>slicing</strong> thing isn&rsquo;t great. You see, I did a quick
test. I wrote a few lines so that &ldquo;slicing&rdquo; a shape simply yielded two
smaller circles. (Like a snowball exploding into two snowballs.) And
guess what? It was <em>so much more fun</em> and <em>intuitive</em>.</p><p>It looked better because there weren&rsquo;t all these weird shapes floating
around. It played better because you weren&rsquo;t just stuck after being
sliced.</p><p>So &mldr; well, I guess my whole algorithm for accurately slicing stuff
will just be an optional feature. For the people who want the extra
challenge.</p><p>(Feels like something I could use in a puzzle game, at a later date. Or
a party fighting game where you <em>literally</em> slice your opponents.)</p><h3 id=realistic-physics-are-too-realistic>Realistic physics are too realistic</h3><p>Similarly, I noticed an issue with &ldquo;realistic rolling physics&rdquo;:</p><ul><li><p>Some heights are too great to roll over. You need to jump.</p></li><li><p>But when you jump, you&rsquo;re likely to hit the ceiling with your head
&mldr; which causes you to reverse direction.</p></li><li><p>(Rotating &ldquo;left&rdquo; means rolling &ldquo;right&rdquo; if your hitting the ceiling.
You can think of it as the ground being reversed in this situation,
and the friction on the ground is the only thing making rolling
movement possible.)</p></li></ul><p>This was just annoying. It happened too quick to &ldquo;adapt&rdquo; to it or use it
for anything. I almost considered throwing out this whole rolling thing
as well &mldr; but decided that was my panic talking.</p><p>Instead, I added these features:</p><ul><li><p>If you <strong>hold both buttons</strong>, you &ldquo;<strong>air break</strong>&rdquo;. This means your
vertical velocity is 0 (you won&rsquo;t move up/down), while your
horizontal velocity continues. (It&rsquo;s even made more powerful.) This
allows you to stop your jump/fall whenever you want, allowing much
more precise movement in difficult parts.</p></li><li><p>(Quick-tapping both buttons still makes you <strong>jump</strong>.)</p></li><li><p><strong>Clinging</strong> is enabled by default <em><strong>on ceilings</strong></em>. (Again,
jumping will disable clinging for a few milliseconds and you will
shoot away from the grip of the ceiling.)</p></li></ul><h2 id=step-17-throwing-more-sand-against-the-wall>Step 17: Throwing more sand against the wall</h2><p>Now was, yet again, the time to implement all different &ldquo;special
elements&rdquo; I came up with. See what works, see what doesn&rsquo;t. Let&rsquo;s hope
we have a fun game by the end.</p><p>As a reminder, these are the elements to do:</p><ul><li><p>Different &ldquo;locks&rdquo; => these are the minigames you have to play once
in a while to open a gate. To slow down the leading player and bring
the group closer together.</p></li><li><p>Special elements => all sorts of things (that might be good or bad)
which you will activate/collect by touching their tile.</p></li></ul><p>Once these are implemented (they work, they are fun, etc.), we&rsquo;re close
to finishing the game. Then it would just be:</p><ul><li><p>Create tutorials for everything (that needs one) + create &ldquo;campaign&rdquo;
structure with levels</p></li><li><p>Loads of polishing, balancing and playtesting. (Includes adding the
soundtrack + sound effects, some particles, etc.)</p></li><li><p>Done!</p></li></ul><p>I&rsquo;ll probably go over my &ldquo;One Week&rdquo; limit again. But this time there&rsquo;s a
good reason: my first ideas were hard to implement, yielded some
annoying bugs, and then &mldr; had to be thrown out because it just wasn&rsquo;t
that fun.</p><h2 id=step-18-welcome-back-after-a-long-break>Step 18: Welcome back after a long break!</h2><p>Guess what? When I said I could use the slicing mechanic &ldquo;for a party
game where you realistically slice your friends&rdquo; &mldr; that&rsquo;s exactly what
I did!</p><p>I worked on that game for a few weeks, released it for free, then worked
a few extra weeks, and released the final paid version. Then there were
two interesting game jams, so I participated (which took another month).</p><p>And then I looked at my list of &ldquo;unfinished projects&rdquo; and realized I
<em>really</em> needed to cut down the length of that list. So I powered
through and finished a bunch of older projects, until we arrived at this
project again.</p><p>Looking at it with fresh eyes, with some months of distance and extra
experience, I realized a few things:</p><p><strong>Realization #1:</strong> I made it too big and too complex &ndash; again. I
discarded many of the original plans and decided to stick with what I
already had, keeping the game smaller in scope.</p><p><strong>Realization #2:</strong> Nobody is going to go through a whole <em>campaign</em> for
a game like this. It&rsquo;s supposed to be a lighthearted, quick, fun game.
So I&rsquo;m not even adding it. Instead, in the menu, you have two options:
<em>tutorial</em> and <em>play</em>.</p><p>The tutorial is a special map that teaches you the actual inputs,
objective and core rules of the game.</p><p>The play map is just the standard game where <em>anything</em> can show up. (At
the start, it selects a random subsection of the full list of
rooms/terrains/etc.) And here&rsquo;s the kicker: <strong>the first time it&rsquo;s added
into the level, a tutorial is always placed before it</strong>.</p><p>For example, let&rsquo;s say I want to add the &ldquo;spiderman&rdquo; terrain for the
first time. Then I place a big empty room with the tutorial image for it
as the background. After that, I place another room with that terrain
actually inside.</p><p>This way, nothing has to be taught upfront, or from a list in the main
menu. The tutorial appears <em>right</em> before the first time you use it. I
don&rsquo;t even have to make those menus!</p><p>(The downsides are, of course, that you can&rsquo;t <em>pick</em> which things you
want or don&rsquo;t want. And the tutorials will keep showing up, even if you
already know how something works from earlier plays. I could make an
option to turn off <em>the whole system</em>, but that&rsquo;s it. But hey, I just
want to try this, as it seems like a good idea to experiment with.)</p><p><strong>Realization #3:</strong> Interactive menus are awesome. So I&rsquo;ll just build a
simple map with two huge rooms (<em>tutorial</em> and <em>play</em>). When you login,
you get a sheep to control and roll around. Once everyone is inside one
of the rooms, you&rsquo;ve chosen that option and the game starts.</p><p><strong>Realization #4:</strong> Nobody is waiting on a <em>huge</em> game about rolling
sheep with <em>loads of content</em>. I need to stop trying to make every
simple idea &ldquo;my next big thing that is going to shock the world&rdquo;. Just
add a few rooms, a few terrains, polish the core gameplay, and call it
<strong>done.</strong> Then I can cross it off the list, continue with a new project,
with my improved sense of scope :p</p><p>So that&rsquo;s the plan now:</p><ul><li><p>Clean up some code and assets. (Had to do that anyway, now it&rsquo;s also
a way to get familiar with the code again.)</p></li><li><p>Finish the core mechanics and create that tutorial map/system to
explain them. (If too difficult, find ways to simplify.)</p></li><li><p>Write a system to always show a tutorial before the first time you
use something.</p></li><li><p>Create the interactive main menu</p></li><li><p>Then see if I want to add more rooms, or perhaps even remove some,
or what I want with the content in general.</p></li></ul><p>To be honest, this is going to be a pain. I&rsquo;ll need to work really hard
for a few days, on boring and confusing things, with almost no
motivation to speak of. But I know how important it is to <em>finish stuff</em>
and the rewards you get from it. And, of course, the reason I started
this project is because there were certain things that I found
interesting and fun, so I&rsquo;ll focus on those.</p><h2 id=step-19-a-few-days-later>Step 19: A few days later</h2><p>Yes, it was a pain. These few days weren&rsquo;t very productive and I watched
more YouTube videos to procrastinate than I care to admit :p</p><p>But, as long as you keep doing <em>something</em> every day, you get through
it.</p><p>Right now, those &ldquo;dynamic tutorials&rdquo; are working nicely. I also fixed a
handful of other bugs and <em>greatly</em> cleaned up the code. (It&rsquo;s baffling
how I thought my previous system for doing things was fine.)</p><p>Also, I realized that &ldquo;teleporters&rdquo; will never have a tutorial. Why? A
teleporter is only placed when the algorithm runs out of space to place
new stuff, so it panics and converts the last room into a teleporter.
It&rsquo;s not easy to &ldquo;predict&rdquo; that in advance.</p><p>So they, as the exception, get a tutorial <em>on themselves</em> (instead of
before they are placed) the first time a teleporter room appears.</p><h3 id=last-rooms>Last rooms</h3><p>I already had some neat ideas leftover for rooms/locks, so I implemented
those.</p><p>Some were easy. Take the &ldquo;fast gate&rdquo;: it just opens/closes quickly, so
you need to wait a bit and then time your jump through.</p><p>Some were a whole minigame on their own :p Take the &ldquo;painter&rdquo;: to unlock
that room, you need to paint the background 100%. How? Well, by flying
through the room, as it automatically paints wherever you go.</p><p>This meant I had to do some magic with <em>textures</em> and <em>masks</em> to make a
rectangle of the world paintable. And then more magic to get a method
for checking &ldquo;is it roughly 100% filled?&rdquo; without killing performance.</p><p>(I created a 2D array in the background, with a <em>very</em> low resolution.
Like a downscaled version of the real texture. When a player paints, it
just checks which cell it corresponds to, and then sets that cell to
&ldquo;painted&rdquo;. Once all cells in the 2D array are true, it deems the room
painted and unlocks.)</p><h3 id=last-items>Last items</h3><p>The items/obstacles were a mess. Before taking a break, I <em>did</em> have the
luminous idea of not actually including loose items. Instead, obstacles
are simple &ldquo;special blocks&rdquo; of the terrain, instead of regular blocks.</p><p>But this also meant that all my old notes/ideas for items were now
worthless and I had to come up with new ideas.</p><p>After some brainstorming, I realized there were a few obvious options.
(<em>Spikes</em> that slice you, <em>trampoline</em> that shoots you upward.) And that
most other options were just identical to the terrains I already
implemented. (A block that slows you down when rolling over it, one that
is slippery like ice, etcetera.)</p><p>There <em>are</em> options that are really cool and unique, but I wasn&rsquo;t sure
if I had the time and motivation to add them, so I left them for now.</p><h3 id=last-rule-polishing>Last rule polishing</h3><p>There were two big unanswered questions left:</p><ul><li><p>There are quite some rooms and terrains that do stuff with <em>coins</em>.
But what if they never show up? Is there a way to make coins
actually integral to the game, part of its core ruleset?</p></li><li><p>What to do with the body splitting? What&rsquo;s the point of all those
extra bodies flailing about at the back?</p></li></ul><p>After some thinking, I decided on the following.</p><p>Question 1:</p><ul><li><p>If you have coins, the wolf does not <em>split</em> you, but rather takes a
coin from you. (Both makes the wolf more interesting to play
actively, and gives anyone a use for coins.)</p></li><li><p>Ensure at least one <em>terrain</em> or <em>lock</em> is included that does
something with coins.</p></li></ul><p>Question 2:</p><ul><li><p>Any body of yours <em>that does not finish</em> results in a time penalty.
(The game ends once every player has <em>one</em> body over the finish
line.)</p></li><li><p>Older bodies of yours can still activate stuff, so they can still be
useful (or very annoying) if you keep track of this. (For this to
work, we need one other rule: <em>when one of your bodies does
something or gets something, this is copied to ALL your bodies</em>.)</p></li><li><p>Add many ways to get back together again</p></li><li><p>Ensure at least one <em>terrain/lock/item</em> helps you retrieve or use
your old bodies.</p></li></ul><p>As always, it&rsquo;s about compromises. I want the randomly generated routes
to be <em>as varied as possible</em>, but I need some restrictions and
certainties to make the game work in general.</p><p>Not all of this will be explained in the tutorial mode. It would be way
too much <em>and</em> players really don&rsquo;t need to know it at that moment.</p><h3 id=general-polishing>General polishing</h3><p>For a light-hearted game like this, visual and audio polishing is really
a must. (It&rsquo;s a chaotic game about rolling through an environment. You
want the rolling to <em>feel amazing</em> and the environment to be <em>really
fun</em>.)</p><p>However, I&rsquo;ve been working on the game too long and really don&rsquo;t have
the motivation or time left, so I&rsquo;m afraid it&rsquo;s going to be way more
basic than that.</p><p>This is what I deem &ldquo;basic&rdquo; for this game:</p><ul><li><p>Bouncy animations + dust particles when you hit stuff</p></li><li><p>Particle trails all around (showing your movement)</p></li><li><p>Unique sheep characters (one per player), perhaps with blinking eyes
or something.</p></li><li><p>Some indicators for what you&rsquo;re doing. (Holding both buttons to
float? What&rsquo;s your jump direction? What&rsquo;s the terrain doing to you?)</p></li><li><p>Sound effects for the most important actions</p></li></ul><p>(Fortunately, I&rsquo;d already created a soundtrack one inspired evening,
which might actually turn out to be the best part of the game xD)</p><h2 id=step-20-finishing-the-items>Step 20: Finishing the items</h2><p>When I returned to my item code, I didn&rsquo;t really understand what I was
thinking at the time.</p><p>This is what it did:</p><ul><li><p>Check our collision data each frame (a list of all things we
collided with)</p></li><li><p>If it hits our world ( = TileMap node), register the position of
that collision</p></li><li><p>Convert it to a position</p></li><li><p>Check the grid to see if there&rsquo;s an obstacle there</p></li><li><p>Check if we&rsquo;re coming from the right side (so we don&rsquo;t trigger
things when it doesn&rsquo;t make sense)</p></li><li><p>Now activate it. (But add a timeout, so we don&rsquo;t re-activate each
frame, but only once every X seconds.)</p></li></ul><p>Yeah, this wasn&rsquo;t going to cut it anymore.</p><p>Instead, I found I already had an <em>Area</em> attached to each item (which is
used for checking if a physics body is inside of it or not). Right now,
this is only used by the &ldquo;Timed Button&rdquo; => you must stay connected to it
for a few seconds before it activates.</p><p>Why did I use a separate system for that, instead of the default one
above? Well, probably because I realized (during testing), that it was
near impossible to actually <em>keep colliding with the floor for X
seconds</em>. No, due to imprecision, due to randomness, you&rsquo;ll bounce up
and down, roll left and right. So we need some margin: hence, an <em>area</em>
around the block that detects the hit.</p><p>But &mldr; we can just use this for most things! So I made the Area a
general thing, and each unique item a &ldquo;module&rdquo; that can access it.</p><p>Why &ldquo;most&rdquo; things? Well, spikes (for example) <em>don&rsquo;t</em> benefit from this.
They are a one-time thing: you hit them hard, get damage, and it&rsquo;s done.
So those <em>should</em> check for an actual collision, instead of checking if
you&rsquo;re &ldquo;in their general area&rdquo;.</p><p>This means there were now 3 classes of items:</p><ul><li><p>Immediate (like the spikes)</p></li><li><p>Ongoing (when hit, you get some powerup/status effect that stays for
some time, then fades)</p></li><li><p>On/Off (while in the area, this effect is active, but when you leave
it, it goes away)</p></li></ul><p>This is a bit much. There&rsquo;s already enough happening in the game.
Simplifying &mldr;</p><ul><li><p>I decided to <strong>completely scrap</strong> the &ldquo;ongoing&rdquo; idea. (There&rsquo;s
nothing else in the game that &ldquo;stays with you for a while (like a
powerup)&rdquo;, so it doesn&rsquo;t fit anywhere.)</p></li><li><p>Immediate items are often <em>destroyed</em> once used. (Otherwise, you
could run into the same spikes over and over if you&rsquo;re unlucky,
which is just annoying and frustrating.)</p></li></ul><p>It&rsquo;s amazing how you can come back to a project some months later, and
just <em>don&rsquo;t understand at all what you were thinking</em>, and see easy ways
to simplify and improve all the code.</p><p>Anyway, after some rewriting, this works great and is a way better (and
more flexible) plan.</p><h3 id=better-items>Better items?</h3><p>First of all, I renamed &ldquo;items&rdquo; to &ldquo;special tiles&rdquo; wherever I could.
It&rsquo;s a way better description for what they are and what they do.</p><p>Secondly, once I implemented the <em>cannon</em> (shoots bullets across the
room) and <em>laser</em> (has a constant death ray that ends at the next tile
it hits), I immediately saw that those were <em>great</em> additions.</p><p>It just added so much to the gameplay. Suddenly, you couldn&rsquo;t just fly
anywhere you want. You needed to time a jump to dodge a bullet. Or take
the other way around to avoid the laser.</p><p>This was in stark contrast to how &ldquo;useless&rdquo; (or &ldquo;disjointed&rdquo;) many of
the other tiles felt. For example, I implemented a &ldquo;shield&rdquo; that makes
you invincible while standing on it. But how often will that actually be
useful?!</p><p>So I tried to think more along the lines of the cannon. Something that
actually has a big influence on the main mechanic of the game, forcing
you to roll differently. Slowly, I realized there were two main ways to
get this effect:</p><ul><li><p>Create stuff that blocks players. (But in a varied, temporary way.
Otherwise it&rsquo;s the same as a <em>lock</em>, just, erm, worse.)</p></li><li><p>Create stuff that directly modifies physics, spaces, speed, the
route, etc.</p></li></ul><p>It dawned on me that the reason I found it a tad boring to play, is
because the rooms looked samey after a while, and it was easy to <em>power
through them</em> (if you aimed well).</p><p>What if I could create small &ldquo;platforming sections&rdquo; along the route?
What if I could add <em>ramps</em>, <em>moving platforms, doors opening/closing?</em>
It would change up the gameplay and prevent just floating through the
whole thing.</p><p>What&rsquo;s holding me back? Well, the fact that we need <em>space</em> for this and
the route has to be <em>finishable</em>. If I just add these elements anywhere,
there&rsquo;s a good chance a situation is created that you just can&rsquo;t get
through. It&rsquo;s useless adding a ramp, if there&rsquo;s no space above it to
jump.</p><p>The only way I see this working, is if I can tell the algorithm to
<strong>create a big room and keep it empty</strong> (no special tiles or things
inside), and then have some <strong>fast checks to ensure the route stays
finishable.</strong></p><p><strong>This is something I can&rsquo;t (easily) figure out right now</strong>. So I&rsquo;m
going to leave it, write it down as a future addition, and continue
finishing the game.</p><p>Additionally, I decided to leave out the <strong>shop</strong> lock. I just couldn&rsquo;t
make it work, without making it overly complicated and adding <em>another</em>
system to the game. Again, ideas for it are written down for the future,
but it won&rsquo;t be in the game.</p><p>Remember: this was supposed to be a &ldquo;one week game&rdquo; :p It&rsquo;s already way,
way bigger than that and took longer.</p><h3 id=feedback--stuff>Feedback & Stuff</h3><p>By now even <em>I</em> was sometimes confused what an item did exactly. (There
are <em>so many things in the game</em>, and most of them don&rsquo;t have their
tutorial image yet, or were made in 10 minutes and then forgotten by me
:p)</p><p>Which made <em>feedback</em> the next priority + finishing all those tutorials.
A looooot of feedback, because there are just so many things that can
happen in this game.</p><p>I&rsquo;ve learned (over the years) that it&rsquo;s best to do the &ldquo;quartet of
polishing&rdquo; at the same time: feedback, particles, sound effects, and
animations/tweens. So that&rsquo;s what I did.</p><p>(Why? Because they are (very) often <em>the same</em>. If something needs a
sound effect, it probably also needs particles, an animation, and
feedback. It&rsquo;s quite rare that something only needs <em>one</em> of those. By
doing them simultaneously, I can be more productive.)</p><h3 id=performance>Performance</h3><p>Because the game blew up in size (unexpectedly), some of the code and
the systems aren&rsquo;t performant enough anymore. After encountering
numerous occasions where <em>lag</em> was noticeable, I decided I just had to
rewrite some large parts of the code.</p><p>The main culprits?</p><ul><li><p>Every script in the game finds and saves <em>its own reference</em> to
other nodes it needs. (For example, the &ldquo;Input&rdquo; module has to relay
its info to the &ldquo;Movement&rdquo; module to move the player. So, when the
module is instantiated, it finds that module and saves the reference
to it.) This means <em>thousands</em> of expensive node lookup calls.</p></li><li><p>When you hit the tilemap, it paints a splat on it. This is great for
adding color, life, variation to the game. It also means I need a
<em>humongous texture overlaying the whole tilemap, which is constantly
updated</em>.</p></li></ul><p>The first one is solved by simple restructuring. Instead of every module
having its own references, each one has a reference to its parent. <em>Only
the parent needs to lookup stuff.</em> (Although it&rsquo;s simple, it still took
a lot of time, as I had to change this <em>absolutely everywhere</em>.)</p><p>The second one is harder. I&rsquo;d need to: figure out which part of the
playing area is actually being interacted with, resize the image
constantly based on that information, and only update when necessary. <em>I
don&rsquo;t know how to do this</em> <em>(well)</em>.</p><p>In the end, I decided to &mldr;</p><ul><li><p>Implement a &ldquo;dirty&rdquo; flag => only if something <em>actually changed</em> do
we update this texture and send it to the shader again. (An easy
improvement.)</p></li><li><p>Implement a &ldquo;resolution&rdquo; => fixes almost all lag, but obviously
makes the paint a bit more pixelated/blurry (because we&rsquo;re scaling
up a low-res image to fit the whole world)</p><ul><li>For example, a resolution of &ldquo;2&rdquo; would already mean the image
size is cut in <em>half</em>. This means we go from 3200x1920 pixels to
1600x960 pixels, which is far easier for the average PC to
handle.</li></ul></li><li><p>Add a &ldquo;performance mode&rdquo; in the settings that turns off this whole
system.</p></li></ul><p>With these changes, even with all systems fully operational, I don&rsquo;t get
any lag anymore!</p><h2 id=step-21-gameplay-polishing>Step 21: Gameplay Polishing</h2><p>So, I just spent a few days adding the feedback, the sound effects, the
particles, etcetera. The &ldquo;superficial polishing&rdquo;, so to speak. (Not any
less important, but it doesn&rsquo;t impact gameplay or core mechanics, hence
&ldquo;superficial&rdquo;.)</p><p>There are many, <em>many</em> variables to tweak in this game. This step is
always a bit overwhelming for me, unsure about every change I make (or
don&rsquo;t make), but in general I just test the game a lot with different
configurations and see what feels best.</p><p>For example: from the start of development, the rule &ldquo;bigger shapes move
faster&rdquo; has been in the game.</p><p>But now, in the final game, I&rsquo;m not so sure anymore. It&rsquo;s already enough
of a <em>penalty</em> to have some unrollable triangle shape &ndash; do I really
need to penalize you even more with severely reduced speed?</p><p>At the same time, the rule was introduced because smaller shapes have an
easier time fitting through gaps. And I don&rsquo;t want to reward players
from being bad and decimating themselves, I want to reward them for
staying big and alive! That&rsquo;s why they became slower.</p><p>In the end, it usually leads to a compromise. The rule is still in the
game, but its effect is weakened. So much in fact, that I don&rsquo;t explain
it in the tutorial anymore.</p><p>Within a few days, I try to make hundreds of these tiny decisions,
hopefully for the better :)</p><p><strong>When in doubt, I choose the option that simplifies the game (less to
explain to players, less to remember, etcetera) or that saves me work.</strong>
Again, that&rsquo;s the mindset I&rsquo;ve acquired after years of making games, a
practical one that <em>gets stuff done</em>.</p><h3 id=solo-mode>Solo Mode</h3><p>For the longest time, I completely forgot I planned to have a solo mode
in this game. When I remembered, I wrote down a quick idea for it, then
forgot again.</p><p>Well, with the game as good as done, now this mode should <em>really</em> be
implemented :p</p><p>The idea is the same as most games that feature racing (in side-view):</p><ul><li><p>The level is slowly fading away behind you. (Some &mldr; thing is
chasing you at a constant speed, anything it passes is destroyed.)</p></li><li><p>If it catches up to you, you are destroyed as well, thus losing the
game.</p></li></ul><p>However, my game doesn&rsquo;t have a fixed and easy direction. (Always left
to right, for example.) The route can literally go anywhere.</p><p>How do we handle this?</p><ul><li><p>Create a rectangle and start it at the last room. (As soon as the
player leaves it, of course, otherwise they die instantly.)</p></li><li><p>Resize it to match the size of this room (so it fits nicely on top
of it).</p></li><li><p>Move in the forward direction &ndash; I&rsquo;ve saved this on every room, as I
also need it for other components of the generation &ndash; with a fixed
speed.</p></li><li><p>Whenever we enter a new room, completely destroy the previous one.</p></li><li><p>If the rectangle overlaps the player? You lose.</p></li><li><p>(The player finishes before dying? You win!)</p></li></ul><p>It won&rsquo;t look that pretty and polished, but it should be a strong solo
mode.</p><p>(Which is a must-have in local multiplayer games! If your game <em>only</em>
supports 2+ players, it&rsquo;s way less likely to be bought/tried. Because
people can&rsquo;t test if they like the game on their own, they can&rsquo;t play
the game at all when nobody else is around or they&rsquo;re still waiting on
their guests, it&rsquo;s just too restrictive.)</p><p>I can even speed up the pace if you&rsquo;re far ahead, or slow down if it&rsquo;s
about to hit you, to balance the game for the skill of the player.</p><h3 id=quality-of-life>Quality of Life</h3><p>When I went away from this project, I made a game where <strong>outlines</strong>
made all the difference. So I decided to port that code to this game as
well, and it (again) made all the difference! Simply drawing a (thick,
dark) outline around all shapes made the game <em>much</em> easier to parse and
play.</p><p>Similarly, there was a limit of <strong>5 bodies</strong> per player. But this was
just too much. <strong>3 or 4 bodies (at most)</strong> is better and, again, easier
to deal with.</p><p>I also observed some <em>patterns</em> that were hard to overcome.</p><p>For example, if the entrance to the next room was <em>one higher</em> than a
slope, it was really annoying to reach. (As you can&rsquo;t roll there, but a
jump would likely take you too high.)</p><p>I think it&rsquo;d make a huge difference if I could <em>identify these
&ldquo;annoying&rdquo; patterns</em> and build something to help players overcome them.
(In this case: just remove the block that&rsquo;s preventing a nice rolling
entry, or add some <em>magnet</em> to the opening that draws you into it.)</p><h3 id=things-that-shouldve-been-fixed-long-ago>Things that should&rsquo;ve been fixed long ago</h3><p>Over time, problems start to add up (in a project) that you just don&rsquo;t
know how to solve, and which are just annoying.</p><p>Well, with the game being as good as done, it was time to fix those
issues. Luckily, after some time away, the solutions were easier to
find.</p><h3 id=teleporters>Teleporters</h3><p><strong>Teleporters:</strong> if the random generation is stuck (happens sometimes,
especially on large player counts), it places a teleporter in its last
room. Once all players reached it, the map is erased, and you start
again somewhere else.</p><p>The problem? The teleporter needs to be <em>big</em>. Otherwise it doesn&rsquo;t fit,
it&rsquo;s hard to see it (and enter it), and it&rsquo;s a mess.</p><p>But &mldr; if you&rsquo;re stuck, there&rsquo;s a 90% chance the last room is 1x1 room
somewhere in a corner.</p><p>My first solution was to blow up that last room. Just make it bigger,
turn it into a teleporter.</p><p>The problem? This might cause it to overlap older parts of the path,
ruining everything! (Or it might go out of bounds, also leading to a
crash.)</p><p>I <em>could</em> write complicated code to check this, but I thought of
something better instead.</p><p>When a teleporter must be placed, just <strong>look back at the last 10 rooms.
Pick the biggest one; place it there.</strong> (There&rsquo;s a 100% chance a
decently sized one is among the last 10 rooms.)</p><p>To make life even easier, I also decided to be careful and already place
a teleporter when I <em>think</em> we&rsquo;re about to run out. (So when the number
of valid rooms is very low, below 10 or so.) Would speed up generation
and lead to prettier routes.</p><h3 id=lock-problems>Lock problems</h3><p>There were three major issues:</p><ul><li><p>Only <em>completely open connections</em> are opened when you unlock a
lock. Any opening that leads to a <em>slope</em>, for example, remains
closed now. Which is &mldr; confusing and unnecessarily constricting.</p></li><li><p>Many minigames require complete access to the room. At the moment,
there is <em>some</em> chance there are holes you cannot reach, which is a
big no-no.</p></li><li><p>The text labels (that give information about your progress) were all
over the place. (Some were placed <em>outside</em> the lock, or <em>behind</em>
something, or initialized to a random number.)</p></li></ul><p><strong>Solution #1?</strong> Look up the indices in the tilemap of slopes (or other
half-open tiles). Also count those as &ldquo;free&rdquo; or &ldquo;open&rdquo; in the algorithm.</p><p><strong>Solution #2?</strong> After randomly placing tiles, check for any tile that
is <em>empty</em> &mldr; yet surrounded by only filled tiles. That is a <em>hole</em>.
Fill it.</p><p><strong>Solution #3?</strong> Create a general scene for the label, use that
everywhere, and initialize it properly. (I decided to initialize to a
question mark, <em>until</em> you interact with the lock. Adds some more
mystery.)</p><h2 id=step-22-walking-back-bad-decisions>Step 22: Walking back bad decisions</h2><p>Earlier I mentioned the following rule: &ldquo;whenever something happens to
<em>one body</em>, it should happen to <em>all of your bodies</em>&rdquo;</p><p>Although a good idea in theory, it didn&rsquo;t work in practice. It just
becomes confusing, way too hard to keep track of. If I&rsquo;d wanted to do
this, I should&rsquo;ve kept it in mind (and supported it) right from the
beginning.</p><p>The rule was designed to make the fact that you can be split into
multiple bodies <em>more useful/impactful</em>.</p><p>So, we need something else to achieve the same thing. At the same time,
I observed these flaws:</p><ul><li><p>Coins aren&rsquo;t used enough. There should be <em>way more items</em> where you
can pay coins in exchange for &mldr; something good.</p></li><li><p>There should be some more control over growing/shrinking in actual
<em>size</em>. (Now it&rsquo;s often a <em>bad</em> thing if you become big and
powerful, because you don&rsquo;t fit through all gaps anymore.)</p></li><li><p>We still need more platforming elements in the game</p></li></ul><p>As such, I decided to add more special tiles to the game (with a high
probability of appearing) aimed specifically to solve these 4 problems.</p><p><strong>Multiple bodies?</strong></p><ul><li><p>A tile that gives you as many coins as you have bodies.</p></li><li><p>A tile that freezes bodies nearby <em>if they aren&rsquo;t your worst body</em>.</p><ul><li><p>This might seem an obstacle, but it&rsquo;s actually a helpful thing.</p></li><li><p>It locks a body, so you can safely move your others without
worrying about it.</p></li></ul></li><li><p>A tile that changes <em>all your bodies</em> to a triangle.</p><ul><li>The one tile that <strong>does</strong> have its effect on <strong>all</strong> your
bodies</li></ul></li></ul><p><strong>Coins?</strong> (So these act as a sort of &ldquo;shop&rdquo;.)</p><ul><li><p>Pay X coins to destroy all your other bodies.</p></li><li><p>Pay X coins to <em>blast away</em> or <em>slice</em> all nearby bodies (excluding
your own, of course).</p></li><li><p>Pay X coins for a huge time bonus (solo_unpickable)</p></li><li><p>Pay X coins to <em>shrink</em> (+ <em>make triangle)</em> everyone around you</p></li></ul><p><strong>Growing/Shrinking</strong></p><ul><li><p>A tile that grows you to max size</p></li><li><p>A tile that shrinks you to min size</p></li></ul><p><strong>Platforming?</strong></p><ul><li><p>A magnet that attracts/repels all bodies in a radius (ignoring
walls)</p></li><li><p>A platform placed somewhere in the room that simply turns on/off on
a timer. (Acting like a door, or gate, or moving floor, depends on
situation.)</p></li><li><p>A similar platform that <em>moves</em> or has a <em>hole</em> in it.</p></li><li><p>An item that just has a <em>slight</em> slope on it, causing you to
roll/fly off, without blocking too much.</p></li></ul><p>Yes, this adds <em>even more content</em>, and doesn&rsquo;t entirely solve the core
issues. But I feel done with the game and don&rsquo;t want to do a core
rewrite.</p><p>(Another bad decision was: &ldquo;when you hit another body of yours, all
coins are transferred to the biggest shape&rdquo; It&rsquo;s often impossible to
tell which one is actually bigger. There&rsquo;s no real use for this. When it
happened for the first time, <em>I</em> was confused for a moment &ndash; and I made
the game! So this was simply turned off.)</p><p>(Additionally, the max number of coins was scaled back from 10 to 5.
Again, too hard to keep track of more than that, and it polluted the
visuals.)</p><h2 id=i-think-ill-stop-here>I think I&rsquo;ll stop here</h2><p>There were many, many, many minor (or sometimes surprisingly major)
things I had to fix. Bugs that crashed the generation, annoyances that
would make it (near) impossible to progress in certain situations, stuff
that needed to be balanced (otherwise it was just too hard and you
needed to much skill to do something).</p><p>It took a few days (of continuous work) more than I wanted, but in the
end we got there. And so I&rsquo;ll stop this devlog here. Because I am <em>done</em>
with this game and need a rest :p</p><h2 id=step-23-final-playtest>Step 23: Final Playtest</h2><p>But I&rsquo;m a professional! I&rsquo;m not launching a (paid) game without doing
the playtesting and ensuring it&rsquo;s good enough. (Or well, I <em>try</em> to be a
professional.)</p><p>So I did. The good news? Players had tons of fun, after some practice
they got the hang of the movement and were able to actually make it a
competition, in general the game works.</p><p>There were quite some bugs (which only revealed itself during chaotic
testing with many players) I had to address. There was a single crash.
(Which is more than you like, obviously, but usually just means some
stupid error I can easily spot in an old piece of code.)</p><p>The main issues?</p><ul><li><p>With many players, of &mldr; varying skill levels, the camera zooms out
<em>a lot</em>. Making stuff small and hard to see. Solution? Find ways to
keep the camera more zoomed in and stuff bigger. (Less distance
allowed between you and leading player. Scale tutorial images with
screen size, now they are constant. Place locks more frequently or
take longer to solve them.)</p></li><li><p>Players had issues with jumping. To make jumping more varied and
useful (especially to myself, an experienced player) I modify the
jump direction based on the angle of what you&rsquo;re standing on. But to
new players &mldr; they just expect to jump straight up. Solution? Make
it so :p Make the other an &ldquo;export option&rdquo; you can turn on.</p></li></ul><p>Otherwise, there were many tiny bugs, most of them easy to fix or just a
hilarious mistake. (I&rsquo;d rewritten the code for sorting players based on
their finish time, to make it faster <em>and</em> account for some special
powerups I added last minute. But in doing so, I&rsquo;d reversed the order
&mldr; so the worst player came first xD)</p><p>In general, if my to-do list after a playtest (of an hour long) is
short/simple enough to finish in a day, that&rsquo;s a good sign. It means 99%
of the game just works well and players had enough fun that I&rsquo;m not
doubting myself or the core of the game.</p><p>So let&rsquo;s do that, create a trailer/marketing material for it, then we
can call it done.</p><h2 id=conclusion>Conclusion</h2><p>Do I like the game? Yes. I think it turned out well, albeit much
different from the original plan.</p><p>Many elements are something I&rsquo;ve never seen before in a game, or never
made myself before, which means it was <em>at least</em> a great learning
experience that added some new tools for my tool belt.</p><p>But besides that, it&rsquo;s just a game that&rsquo;s</p><ul><li><p>Extremely easy to pick up and play. (Reach the finish first. Roll
left/right to do this.)</p></li><li><p>Has a great new tutorial system that works wonders. (Everything is
taught <em>inside the level</em>, <em>right before you need it</em>. Basically
removing the need for any upfront tutorials or boring &ldquo;reading a
wall of text with a group of people who just wanna play a game&rdquo;)</p></li><li><p>And looks colorful, fun, juicy, varied, like a real party game.</p></li></ul><p>Is it perfect? Nope. Only once I was finishing up the project, did I
realize what I actually needed.</p><ul><li><p>More platforming sections, created by randomly placed items. Now we
only have some basics: a trampoline, a cannon with bullets to dodge,
some slopes and simple platforms.</p></li><li><p>More <em>items</em> that use the coin system. (In fact, the coin system is
<em>fine</em>, but not <em>great</em>, and I might have entirely removed it if I
could.)</p></li><li><p>More stuff that&rsquo;s applicable when playing in <em>solo mode</em>. (I
realized I had to scrap a lot of terrains/items because they only
did something useful when you have 2+ players.)</p></li><li><p>More variation in the level generation, both in visuals (it only
uses a basic tileset, no extra flowers, or variations, or whatever)
and by pattern-matching situations that are annoying to players.</p></li></ul><p>I&rsquo;ve written all of these as a &ldquo;future to do&rdquo;. I think this game would
get a huge boost (in content and fun) with these additions, but I just
don&rsquo;t have any more time to spare on this project. It was supposed to be
a &ldquo;one week game&rdquo; (OWG), now it&rsquo;s a &ldquo;three week game&rdquo;, and I really
don&rsquo;t want to blow it up any further.</p><p>(Additionally, it was set up as a small project, which means increasing
scope wouldn&rsquo;t work well, as the code and systems just aren&rsquo;t there to
support it.)</p><p>Additionally, being a OWG, the plan was to release it for free. However,
the amount of work I put in, the quality of the final product, the fact
that I learned putting a price tag on your work is generally the way to
go &mldr; steered me towards making it a paid release.</p><p>So that&rsquo;s what I did. Finished another project, it became better than I
anticipated (but still some way from a big professional release), now
onto the next one.</p><p>Until the next devlog,</p><p>Pandaqi</p></div></article><div><nav class=pagination><ul><li><a href=/blog/videogames/one-week-games/devlog-totems-of-tag/ class="masked-link big-mask mask-1" style=--rotation:-1deg>&lt;&lt; Previous Page</a></li><li>Continue reading</li><li><a href=/blog/videogames/one-week-games/devlog-carving-pumpkins-and-dwarfing-dumplings/ class="masked-link big-mask mask-2" style=--rotation:2deg>>> Next Page</a></li></ul></nav></div></main><footer id=site-footer><div class="padding center-block"><h3>More Pandaqi</h3><p>You could <a href=https://pandaqi.com>visit the game studio</a>.
Or my <a href=https://pandaqi.com/tutorials/>free tutorial website</a>.
Or my <a href=https://rodepanda.com/>portfolio</a> with easy access to absolutely everything I ever made.
Or my <a href=https://nietdathetuitmaakt.nl/>(mostly) Dutch online store</a> that sells unique merchandise.</p><h3>Latest</h3><nav class=latest><ul><li><a href=/blog/news-and-updates/2026/my-online-store-has-launched/>My Online Store Has Launched!
(üõí)</a></li><li><a href=/blog/news-and-updates/2026/pandaqi-games-version-4/>Pandaqi Games: Version 4.0?
(üêº)</a></li><li><a href=/blog/boardgames/death-by-digits/>Death by Digits
(üïµÔ∏è‚Äç‚ôÇÔ∏è)</a></li><li><a href=/blog/boardgames/fiddlefoo/>Fiddlefoo
(üéª)</a></li><li><a href=/blog/news-and-updates/2026/how-i-coded-my-own-webshop/>How I Coded My Own Webshop
(üõí)</a></li><li><a href=/blog/boardgames/the-luck-legends/a-little-white-die/>A Little White Die
(üé≤)</a></li><li><a href=/blog/boardgames/the-luck-legends/champions-of-chance/>Champions of Chance
(üé≤)</a></li><li><a href=/blog/boardgames/the-luck-legends/chaos-contract/>Chaos Contract
(üòà)</a></li><li><a href=/blog/boardgames/the-luck-legends/deceptidice/>Deceptidice
(ü§•)</a></li><li><a href=/blog/boardgames/the-luck-legends/folly-and-fortune/>Folly & Fortune
(ü§•)</a></li></ul></nav><h3>Sections</h3><nav><ul><li><a href=/blog/boardgames/>Boardgames
(üé≤)</a></li><li><a href=/blog/news-and-updates/>News & Updates
(üì¢)</a></li><li><a href=/blog/reviews-and-thoughts/>Reviews & Thoughts
(üí≠)</a></li><li><a href=/blog/tutorials/>Tutorials
(üë©‚Äçüéì)</a></li><li><a href=/blog/videogames/>Videogames
(üéÆ)</a></li></ul></nav><h3>Credits</h3><p>Theme by me (<a href=https://pandaqi.com>Pandaqi</a> üêº) &#183;
with ‚ù§Ô∏è &#183;
using <a href=https://gohugo.io>Hugo</a> &#183;
&copy; 2018&ndash;2026 Pandaqi Blog</p></div></footer><link rel=stylesheet type=text/css href=/blog/css/style.css><script src=/blog/js/main.bundle.min.js async defer></script></body></html>